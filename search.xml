<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>十八 算法-贪心算法</title>
      <link href="/2023/05/10/18/"/>
      <url>/2023/05/10/18/</url>
      
        <content type="html"><![CDATA[<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>什么是贪心？</p><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p><p><strong>说实话贪心算法并没有固定的套路</strong>。</p><p>所以唯一的难点就是如何通过局部最优，推出整体最优。</p><p>贪心算法一般分为如下四步：</p><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><p>这个四步其实过于理论化了，我们平时在做贪心类的题目 很难去按照这四步去思考，真是有点“鸡肋”。</p><p>做题的时候，只要想清楚 <strong>局部最优</strong> 是什么，如果推导出全局最优，其实就够了</p><h3 id="1-分发饼干"><a href="#1-分发饼干" class="headerlink" title="1. 分发饼干"></a>1. 分发饼干</h3><p>455</p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></table></figure><p><strong>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p><p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。</p><p>然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">g</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findContentChildren = <span class="keyword">function</span>(<span class="params">g, s</span>) &#123;</span><br><span class="line">    g.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b)</span><br><span class="line">    s.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b)</span><br><span class="line">    <span class="keyword">let</span> index=s.<span class="property">length</span>-<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> result=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=g.<span class="property">length</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=<span class="number">0</span>&amp;&amp;s[index]&gt;=g[i])&#123;</span><br><span class="line">            index--</span><br><span class="line">            result++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="1、数组的快慢指针"><a href="#1、数组的快慢指针" class="headerlink" title="1、数组的快慢指针"></a>1、数组的快慢指针</h2><h2 id="2、递归和尾递归"><a href="#2、递归和尾递归" class="headerlink" title="2、递归和尾递归"></a>2、递归和尾递归</h2><h2 id="3、-回溯算法"><a href="#3、-回溯算法" class="headerlink" title="3、 回溯算法"></a>3、 回溯算法</h2><p>回溯法 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将<strong>取消上一步甚至是上几步的计算</strong>，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，</p><p>回溯法的模板代码 比如：力扣46题全排列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> res=[], path=[]</span><br><span class="line">        <span class="keyword">const</span> used=[]</span><br><span class="line">        <span class="title function_">backtracking</span>(nums,nums.<span class="property">length</span>,used)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">backtracking</span>(<span class="params">n, k, used</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(path.<span class="property">length</span>===k)&#123;</span><br><span class="line">                <span class="keyword">return</span> res.<span class="title function_">push</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(path))</span><br><span class="line">            &#125;<span class="comment">// 递归终止条件</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;<span class="comment">//横向遍历完所有元素</span></span><br><span class="line">                <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span></span><br><span class="line">                path.<span class="title function_">push</span>(n[i])<span class="comment">//进行操作</span></span><br><span class="line">                used[i]=<span class="literal">true</span></span><br><span class="line">                <span class="title function_">backtracking</span>(n,k,used)<span class="comment">//递归</span></span><br><span class="line">                path.<span class="title function_">pop</span>()<span class="comment">//撤销操作</span></span><br><span class="line">                used[i]=<span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4、动态规划"><a href="#4、动态规划" class="headerlink" title="4、动态规划"></a>4、动态规划</h2><p>​    我们先来了解一下动态规划的几个步骤</p><p><strong>1，确定状态</strong></p><p><strong>2，找到转移公式</strong></p><p><em>f</em>(<em>i</em>,<em>j</em>)=<em>f</em>(<em>i</em>−1,<em>j</em>)+<em>f</em>(<em>i</em>,<em>j</em>−1)</p><p><strong>3，确定初始条件以及边界条件</strong></p><p><strong>4，计算结果。</strong></p><h2 id="5、数字翻转"><a href="#5、数字翻转" class="headerlink" title="5、数字翻转"></a>5、数字翻转</h2><p>​    给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>​    回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：x = <span class="number">121</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：x = -<span class="number">121</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：从左向右读, 为 -<span class="number">121</span> 。 从右向左读, 为 <span class="number">121</span>- 。因此它不是一个回文数。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：x = <span class="number">10</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：从右向左读, 为 <span class="number">01</span> 。因此它不是一个回文数。</span><br><span class="line"></span><br><span class="line">来源：力扣（<span class="title class_">LeetCode</span>）</span><br><span class="line">链接：<span class="attr">https</span>:<span class="comment">//leetcode.cn/problems/palindrome-number</span></span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||(x%<span class="number">10</span>==<span class="number">0</span>&amp;&amp;x!=<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> remeber=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(x&gt;remeber)&#123;</span><br><span class="line">        remeber=remeber*<span class="number">10</span>+x%<span class="number">10</span></span><br><span class="line">        x=<span class="title class_">Math</span>.<span class="title function_">floor</span>(x/<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x==<span class="title class_">Math</span>.<span class="title function_">floor</span>(remeber/<span class="number">10</span>)||x==remeber</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于数字翻转 可用变为字符串，然后前后指针一一对比。<strong>这里采用%10,/10的方法 实现了翻转，Math.floor() 向下取整，Math.ceil()向上取整</strong></p><h2 id="6、二叉树"><a href="#6、二叉树" class="headerlink" title="6、二叉树"></a>6、二叉树</h2><p>dfs深度优先遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定一个二叉树，找出其最大深度。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+<span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title function_">maxDepth</span>(root.<span class="property">left</span>),<span class="title function_">maxDepth</span>(root.<span class="property">right</span>))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>bfs广度优先遍历</p><p><strong>队列先进先出，符合一层一层遍历的逻辑</strong></p><p>力扣102题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</span></span><br><span class="line"><span class="comment">// 输入：root = [3,9,20,null,null,15,7]</span></span><br><span class="line"><span class="comment">// 输出：[[3],[9,20],[15,7]]</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">//二叉树的层序遍历</span></span><br><span class="line">    <span class="keyword">let</span> queue=[]</span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    queue.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> length=queue.<span class="property">length</span> <span class="comment">// 记录当前层级节点数</span></span><br><span class="line">        <span class="keyword">let</span> curNode=[]</span><br><span class="line">        <span class="keyword">while</span>(length--)&#123;</span><br><span class="line">            <span class="keyword">let</span> node=queue.<span class="title function_">shift</span>()</span><br><span class="line">            curNode.<span class="title function_">push</span>(node.<span class="property">val</span>) <span class="comment">//存放每一层的节点 </span></span><br><span class="line">            node.<span class="property">left</span> &amp;&amp; queue.<span class="title function_">push</span>(node.<span class="property">left</span>)  <span class="comment">// 存放当前层下一层的节点</span></span><br><span class="line">            node.<span class="property">right</span> &amp;&amp; queue.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="title function_">push</span>(curNode) <span class="comment">//把每一层的结果放到结果数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-二维数组的创建"><a href="#7-二维数组的创建" class="headerlink" title="7. 二维数组的创建"></a>7. 二维数组的创建</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建二维数组的方法：</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(n), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><h2 id="8-异或运算"><a href="#8-异或运算" class="headerlink" title="8. 异或运算"></a>8. 异或运算</h2><p>1、任何数和自己做异或运算，结果为 0，即 a⊕a=0。<br>2、任何数和 0 做异或运算，结果还是自己，即 a⊕0=a。<br>3、异或运算中，满足交换律和结合律，也就是 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Operator</span>: x ^= y</span><br><span class="line"><span class="title class_">Meaning</span>:  x  = x ^ y</span><br></pre></td></tr></table></figure><p>按位异或赋值 (^=)</p><h2 id="9-字符串转数字"><a href="#9-字符串转数字" class="headerlink" title="9. 字符串转数字"></a>9. 字符串转数字</h2><p><a href="https://www.jb51.net/article/261613.htm">https://www.jb51.net/article/261613.htm</a></p><p>JavaScript中将字符串转换为数字的七种方法总结</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用 parseInt()</span></span><br><span class="line"><span class="comment">// 2. 使用 Number()</span></span><br><span class="line"><span class="comment">// 3. 使用一元运算符 (+)</span></span><br><span class="line"><span class="comment">// 4. 使用parseFloat()</span></span><br><span class="line"><span class="comment">// 5. 使用 Math.floor()</span></span><br><span class="line"><span class="comment">// 6. 乘以数字1</span></span><br><span class="line"><span class="comment">// 7. 双波浪号 (~~) 运算符</span></span><br></pre></td></tr></table></figure><h2 id="10-隐式转换"><a href="#10-隐式转换" class="headerlink" title="10. 隐式转换"></a>10. 隐式转换</h2><h2 id="11-sort快速排序"><a href="#11-sort快速排序" class="headerlink" title="11. sort快速排序"></a>11. sort快速排序</h2><p>时间复杂度为nlogn</p><p>二维数组的排序比如力扣347题</p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> topKFrequent = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> map=<span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        map.<span class="title function_">set</span>(item,(map.<span class="title function_">get</span>(item)||<span class="number">0</span>)+<span class="number">1</span>) <span class="comment">//统计各个数字出现的次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [...map].<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>b[<span class="number">1</span>]-a[<span class="number">1</span>]).<span class="title function_">map</span>(<span class="function"><span class="params">item</span>=&gt;</span>item[<span class="number">0</span>]).<span class="title function_">slice</span>(<span class="number">0</span>,k) <span class="comment">//通过数字出现的次数进行排序</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十七 算法-动态规划</title>
      <link href="/2023/05/02/17/"/>
      <url>/2023/05/02/17/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动规基础、背包问题、打家劫舍、股票问题、子序列问题</p><ol><li>确定dp数组（dp table）以及 dp[i] 的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>打印dp数组</li></ol><h3 id="1-斐波那契数"><a href="#1-斐波那契数" class="headerlink" title="1. 斐波那契数"></a>1. 斐波那契数</h3><p>509简单</p><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0，F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure><p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fib = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-爬楼梯"><a href="#2-爬楼梯" class="headerlink" title="2. 爬楼梯"></a>2. 爬楼梯</h3><p>70</p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i]： 爬到第i层楼梯，有dp[i]种方法</p><ol><li>确定递推公式</li></ol><p>dp[i] = dp[i - 1] + dp[i - 2] </p><ol><li>dp数组如何初始化    dp[1] = 1，dp[2] = 2</li><li>确定遍历顺序            遍历顺序一定是从前向后遍历的</li><li>举例推导dp数组</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> dp=[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">       dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>]</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-使用最小花费爬楼梯"><a href="#3-使用最小花费爬楼梯" class="headerlink" title="3. 使用最小花费爬楼梯"></a>3. 使用最小花费爬楼梯</h3><p>746</p><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p>解题思路：</p><ol><li><p><strong>dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]</strong></p></li><li><p>dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。</p><p>dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。</p><p>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</p></li><li><p>dp数组如何初始化  dp[0] = 0，dp[1] = 0;</p></li><li><p>确立遍历顺序</p></li><li><p>打印dp数组</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">cost</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minCostClimbingStairs = <span class="keyword">function</span>(<span class="params">cost</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> len=cost.<span class="property">length</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        dp[i]=<span class="title class_">Math</span>.<span class="title function_">min</span>(dp[i-<span class="number">1</span>]+cost[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+cost[i-<span class="number">2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[len]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-不同路径"><a href="#4-不同路径" class="headerlink" title="4. 不同路径"></a>4. 不同路径</h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>1、 dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。</p><p>2、dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。</p><p>3、 首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。</p><p>4、dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。</p><p>5、举例推导dp数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> uniquePaths = <span class="keyword">function</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> arr=<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(m).<span class="title function_">fill</span>(<span class="number">1</span>), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">1</span>))</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                arr[i][j] = arr[i - <span class="number">1</span>][j] + arr[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-不同路径II"><a href="#5-不同路径II" class="headerlink" title="5. 不同路径II"></a>5. 不同路径II</h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p>初始化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; <span class="title function_">dp</span>(m, vector&lt;int&gt;(n, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="keyword">function</span>(<span class="params">obstacleGrid</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> m = obstacleGrid.<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> n = obstacleGrid[<span class="number">0</span>].<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="title class_">Array</span>(m).<span class="title function_">fill</span>().<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] === <span class="number">0</span>; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][i] === <span class="number">0</span>; ++i) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            dp[i][j] = obstacleGrid[i][j] === <span class="number">1</span> ? <span class="number">0</span> : dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-整数拆分"><a href="#6-整数拆分" class="headerlink" title="6. 整数拆分"></a>6. 整数拆分</h3><p>343</p><p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p><p>返回 <em>你可以获得的最大乘积</em> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</span><br></pre></td></tr></table></figure><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>​    dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</p><ol><li>确定递推公式</li></ol><p>​    dp[i] = max({dp[i], (i - j) <em> j, dp[i - j] </em> j});</p><p>​    比如 整数i:，拆分成j和（i-j）,或者i-j再拆分，取他们的积最大的max({dp[i], (i - j) <em> j, dp[i - j] </em> j}); 同时j的值也是变化的</p><ol><li><p>dp的初始化</p><p>dp[0]=0,dp[1]=0;dp[2]=1</p></li></ol><ol><li>确定遍历顺序</li></ol><p>​    dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。</p><ol><li>举例推导dp数组</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> integerBreak = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;i;j++)&#123; <span class="comment">// 这里可以写成j&lt;i/2,因为4*6和6*4一样</span></span><br><span class="line">            dp[i]=<span class="title class_">Math</span>.<span class="title function_">max</span>(j*(i-j),j*dp[i-j],dp[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-两个字符串中的最长公共子串"><a href="#7-两个字符串中的最长公共子串" class="headerlink" title="7. 两个字符串中的最长公共子串"></a>7. 两个字符串中的最长公共子串</h3><h3 id="8-最长回文子串"><a href="#8-最长回文子串" class="headerlink" title="8. 最长回文子串"></a>8. 最长回文子串</h3><h3 id="9-不同的二叉搜索树"><a href="#9-不同的二叉搜索树" class="headerlink" title="9. 不同的二叉搜索树"></a>9. 不同的二叉搜索树</h3><p>96 中等</p><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><ol><li><strong>dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]</strong></li><li>确定递推公式</li></ol><p>​    dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p><ol><li><p>dp数组如何初始化</p><p>dp[0]=1 dp[1]=1</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">numTrees</span> =(<span class="params">n</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            dp[i] += dp[j-<span class="number">1</span>] * dp[i-j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><!-- https://leetcode.cn/problems/unique-binary-search-trees/solutions/550154/96-bu-tong-de-er-cha-sou-suo-shu-dong-ta-vn6x/ --><div class="tag link"><a class="link-card" title="不同的二叉搜索树" href="https://leetcode.cn/problems/unique-binary-search-trees/solutions/550154/96-bu-tong-de-er-cha-sou-suo-shu-dong-ta-vn6x/"><div class="left"><img src="/img/icon/wwwicon.png"/></div><div class="right"><p class="text">不同的二叉搜索树</p><p class="url">https://leetcode.cn/problems/unique-binary-search-trees/solutions/550154/96-bu-tong-de-er-cha-sou-suo-shu-dong-ta-vn6x/</p></div></a></div><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h3 id="10-0-1背包问题"><a href="#10-0-1背包问题" class="headerlink" title="10. 0-1背包问题"></a>10. 0-1背包问题</h3><p>​    这里有4个物品，重量分别为[1, 3, 4, 5]，价值分别为[15, 20, 30, 55]，有个背包能装重量为6的东西，怎么才能装价值最大的。</p><ol><li>确定dp数组以及下标的含义</li></ol><p>​    对于背包问题，有一种写法， 是使用二维数组，即<strong>dp [i] [j] </strong>表示从下标为[0-i]的物品里任意取，放进容量为j的背    包，价值总和最大是多少</p><ol><li>确定递推公式</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//**不放物品i**：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</span></span><br><span class="line"> <span class="comment">//**放物品i**：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</span></span><br></pre></td></tr></table></figure><ol><li>dp数组如何初始化</li></ol><p>dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p><p>那么很明显当 j &lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。</p><p>当j &gt;= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int j = <span class="number">0</span> ; j &lt; weight[<span class="number">0</span>]; j++) &#123;  <span class="comment">// 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。</span></span><br><span class="line">    dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正序遍历</span></span><br><span class="line"><span class="keyword">for</span> (int j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">------------------------------</span><br><span class="line"><span class="comment">// 其他下标应该初始化多少呢 零比较好，所以只用初始化第一行能装下物品的部分</span></span><br><span class="line"><span class="keyword">for</span> (int j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>确定遍历顺序</li></ol><p>有两个遍历的维度：物品与背包重量</p><p>​    5….</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testWeightBagProblem</span> (weight, value, size) &#123;</span><br><span class="line">    <span class="comment">// 定义 dp 数组</span></span><br><span class="line">    <span class="keyword">const</span> len = weight.<span class="property">length</span>,</span><br><span class="line">          dp = <span class="title class_">Array</span>(len).<span class="title function_">fill</span>().<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="title class_">Array</span>(size + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = weight[<span class="number">0</span>]; j &lt;= size; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weight 数组的长度len 就是物品个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= size; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">table</span>(dp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[len - <span class="number">1</span>][size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">testWeightBagProblem</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">55</span>], <span class="number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>();</span><br></pre></td></tr></table></figure><h3 id="11-01背包滚动数组"><a href="#11-01背包滚动数组" class="headerlink" title="11. 01背包滚动数组"></a>11. 01背包滚动数组</h3><ol><li><p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]</p></li><li><p>```js<br>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 都为0</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">4. ```js</span><br><span class="line">   for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品</span><br><span class="line">       for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量</span><br><span class="line">           dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">   </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><p>​        <strong>倒叙遍历</strong></p><ol><li><p>一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">function</span> <span class="title function_">testWeightBagProblem</span>(<span class="params">wight, value, size</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> len = wight.<span class="property">length</span>, </span><br><span class="line">      dp = <span class="title class_">Array</span>(size + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = size; j &gt;= wight[i]; j--) &#123;</span><br><span class="line">          dp[j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], value[i] + dp[j - wight[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(dp)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[size];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">testWeightBagProblem</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">55</span>], <span class="number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>();</span><br></pre></td></tr></table></figure></li></ol><h3 id="12-分割等和子集"><a href="#12-分割等和子集" class="headerlink" title="12. 分割等和子集"></a>12. 分割等和子集</h3><p>416</p><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure><p>只有确定了如下四点，才能把01背包问题套到本题上来。</p><p>背包的体积为sum / 2<br>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值<br>背包如果正好装满，说明找到了总和为 sum / 2 的子集。<br>背包中每一个元素是不可重复放入。</p><ol><li>确定dp数组以及下标的含义</li></ol><p>​    01背包中，dp[j] 表示： 容量为j的背包，所背的物品价值最大可以为dp[j]。</p><p>​    本题中每一个元素的数值既是重量，也是价值。</p><ol><li>确定递推公式</li></ol><p>​    01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p><p>​    所以本题递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</p><ol><li>dp数组如何初始化</li></ol><p>​    都初始化为0</p><p>​    4. 确定遍历顺序</p><p>​    倒叙遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始 01背包</span></span><br><span class="line"><span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; nums.<span class="title function_">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(int j = target; j &gt;= nums[i]; j--) &#123; <span class="comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span></span><br><span class="line">        dp[j] = <span class="title function_">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>举例推导dp数组</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canPartition = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sum = (nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">p, v</span>) =&gt;</span> p + v));<span class="comment">// 累加</span></span><br><span class="line">    <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 判断奇数偶数</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="title class_">Array</span>(sum / <span class="number">2</span> + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = sum / <span class="number">2</span>; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">            dp[j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (dp[j] === sum / <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[sum / <span class="number">2</span>] === sum / <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="13-最后一块石头重量II"><a href="#13-最后一块石头重量II" class="headerlink" title="13. 最后一块石头重量II"></a>13. 最后一块石头重量II</h3><p>1049</p><p>和上一道题特别像</p><p>分成大小相近的两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。最后相减</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">stones</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lastStoneWeightII = <span class="keyword">function</span>(<span class="params">stones</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum=stones.<span class="title function_">reduce</span>(<span class="function">(<span class="params">p,c</span>)=&gt;</span>p+c)</span><br><span class="line">    <span class="keyword">let</span> target=<span class="title class_">Math</span>.<span class="title function_">floor</span>(sum/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(target+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;stones.<span class="property">length</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=target;j&gt;=stones[i];--j)&#123;</span><br><span class="line">            dp[j]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], dp[j-stones[i]] + stones[i] )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum-dp[target]-dp[target]</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="14-目标和"><a href="#14-目标和" class="headerlink" title="14. 目标和"></a>14. 目标和</h3><p>494</p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><p>left代表+之数的和，right代表-之数的和   </p><p>left+right=sum, left-right=target       ——————&gt;         left=(sum+target)/2</p><p>1、dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</p><p>2、例如：dp[j]，j 为5，</p><ul><li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。</li><li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。</li><li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包</li><li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包</li><li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包</li></ul><p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] += dp[j - nums[i]]</span><br></pre></td></tr></table></figure><p>3、dp数组如何初始化 dp[0]=1</p><p>4、先遍历物品，再遍历背包</p><p>5、举例推导dp数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findTargetSumWays = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sum = nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a+b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(target) &gt; sum) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((target + sum) % <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> halfSum = (target + sum) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(halfSum+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = halfSum; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">            dp[j] += dp[j - nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[halfSum];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong></p><p>同样leetcode上没有纯完全背包问题，都是需要完全背包的各种应用，需要转化成完全背包问题，所以我这里还是以纯完全背包问题进行讲解理论和原理</p><p>和01背包滚动数组的区别是，遍历顺序从<strong>前往后遍历</strong>，两个for循环可以互换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先在回顾一下01背包的核心代码</span></span><br><span class="line"><span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; weight.<span class="title function_">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(int j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="title function_">max</span>(dp[j], dp[j - weight[i]] + value[i]); <span class="comment">// 倒序遍历 每个物品只遍历一次 递推过来的时候 之前的值才初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完全背包</span></span><br><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; weight.<span class="title function_">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(int j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量 </span></span><br><span class="line">        dp[j] = <span class="title function_">max</span>(dp[j], dp[j - weight[i]] + value[i]); <span class="comment">// 顺序遍历</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-零钱兑换II"><a href="#15-零钱兑换II" class="headerlink" title="15. 零钱兑换II"></a>15. 零钱兑换II</h3><p>518</p><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p><p>1、 dp[j]：凑成总金额j的货币组合数为dp[j]</p><p>2、dp[j] += dp[j - coins[i]]  为什么是这样在<strong>14题</strong> 目标和  中给出了</p><p>3、dp[0]=1 ,其他为0</p><p>4、<strong>外层for循环遍历物品，内层for遍历背包</strong>为组合数，就是不讲究顺序。如本体</p><p>​    <strong>外层for循环遍历背包，内层for遍历物品</strong>为排列数，就是讲究顺序。如下一题</p><p>5、dp打印</p><!-- <img src="img/image-20230322160833928.png" alt="image-20230322160833928" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230322160833928.png" style="width:80%;"/></div></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">change</span> = (<span class="params">amount, coins</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="title class_">Array</span>(amount + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>; i &lt; coins.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = coins[i]; j &lt;= amount; j++) &#123;</span><br><span class="line">            dp[j] += dp[j - coins[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-组合总和IV"><a href="#16-组合总和IV" class="headerlink" title="16. 组合总和IV"></a>16. 组合总和IV</h3><p>377</p><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><ol><li><strong>dp[i]: 凑成目标正整数为i的排列个数为dp[i]</strong></li><li>dp[i] += dp[i - nums[j]];</li><li>dp[0]=1 其他为0</li><li><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</li><li>举例来推导dp数组</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum4 = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(target+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;  <span class="comment">// 遍历背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;  <span class="comment">// 遍历物品</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=nums[i])&#123;    <span class="comment">// 判断背包是否能装下物品               </span></span><br><span class="line">                dp[j]+=dp[j-nums[i]] </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="17-零钱兑换"><a href="#17-零钱兑换" class="headerlink" title="17. 零钱兑换"></a>17. 零钱兑换</h3><p>322</p><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p>1、 <strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p><p>2、递推公式：<strong>dp[j] = min(dp[j - coins[i]] + 1, dp[j]);</strong></p><p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]，所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p><p>3、dp数组如何初始化</p><p>首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0;下标非0的元素都是应该是最大值。</p><p>4、确定遍历顺序 两种都行</p><p>5、打印dp</p><!-- <img src="C:\Users\Administrator\Desktop\前端\同步typora笔记\img\image-20230324230934807.png" alt="image-20230324230934807" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230324230934807.png" style="width:80%;"/></div></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">coins</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">amount</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> coinChange = <span class="keyword">function</span>(<span class="params">coins, amount</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(amount+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="title class_">Infinity</span>)</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;coins.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">            dp[j]=<span class="title class_">Math</span>.<span class="title function_">min</span>(dp[j-coins[i]]+<span class="number">1</span>,dp[j])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]==<span class="title class_">Infinity</span>?-<span class="number">1</span>:dp[amount]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="18-完全平方数"><a href="#18-完全平方数" class="headerlink" title="18. 完全平方数"></a>18. 完全平方数</h3><p>279</p><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p><p>这道题的解题思路和上面的完全一样。</p><p>1、dp[j]：凑足和为j所需完全平方数的最少个数为dp[j]</p><p>2、dp[j]=Math.min(dp[j-i*i]+1,dp[j])</p><p>3、dp[0]=0  其他为Infinity</p><p>4、都行</p><p>5、打印dp</p><!-- ![image-20230324230907540](C:\Users\Administrator\Desktop\前端\同步typora笔记\img\image-20230324230907540.png) --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230324230907540.png" style="width:80%;"/></div></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numSquares = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="title class_">Infinity</span>)</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i*i;j&lt;=n;j++)</span><br><span class="line">        dp[j]=<span class="title class_">Math</span>.<span class="title function_">min</span>(dp[j-i*i]+<span class="number">1</span>,dp[j])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="19-打家劫舍"><a href="#19-打家劫舍" class="headerlink" title="19. 打家劫舍"></a>19. 打家劫舍</h3><p>198</p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p>1、<strong>dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]</strong>。</p><p>2、决定dp[i]的因素就是第i房间偷还是不偷。dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);</p><p>3、dp数组如何初始化，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值，其他什么都行</p><p>4、确定遍历顺序，dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！</p><p>5、举例推导dp数组 以示例二，输入[2,7,9,3,1]为例</p><!-- <img src="C:\Users\Administrator\Desktop\前端\同步typora笔记\img\image-20230325220408112.png" alt="image-20230325220408112" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230325220408112.png" style="width:80%;"/></div></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rob = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>-<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    dp[<span class="number">0</span>]=nums[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        dp[i]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">2</span>]+nums[i],dp[i-<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.<span class="property">length</span>-<span class="number">1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="20-打家劫舍II"><a href="#20-打家劫舍II" class="headerlink" title="20. 打家劫舍II"></a>20. 打家劫舍II</h3><p>213</p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p><p><strong>思路</strong>：这道题目和<a href="https://programmercarl.com/0198.打家劫舍.html">198.打家劫舍 (opens new window)</a>是差不多的，唯一区别就是成环了。</p><p>1、考虑不包含首尾元素</p><p>2、考虑包含首元素，不包含尾元素</p><p>3、考虑包含尾元素，不包含首元素</p><p><strong>而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了</strong>。</p><!-- <img src="img/image-20230326150915480.png" alt="image-20230326150915480" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230326150915480.png" style="width:80%;"/></div></div><p>然后把数据的数组进行拆分，然后传到打家劫舍I的函数中去，最后比较结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rob = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="property">length</span>==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打家劫舍I的函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">steal</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(arr.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">        dp[<span class="number">0</span>]=arr[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(arr[<span class="number">0</span>],arr[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            dp[i]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">2</span>]+arr[i],dp[i-<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[arr.<span class="property">length</span>-<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把数组拆分两段，传入进去，最后比较结果</span></span><br><span class="line">    <span class="keyword">let</span> res1=<span class="title function_">steal</span>(nums.<span class="title function_">slice</span>(<span class="number">0</span>,nums.<span class="property">length</span>-<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">let</span> res2=<span class="title function_">steal</span>(nums.<span class="title function_">slice</span>(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(res1,res2)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="21-打家劫舍III"><a href="#21-打家劫舍III" class="headerlink" title="21. 打家劫舍III"></a>21. 打家劫舍III</h3><p>337</p><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p><strong>思路：</strong>这是一个树状的结构</p><!-- <img src="img/image-20230326154632296.png" alt="image-20230326154632296" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230326154632296.png" style="width:80%;"/></div></div><p>采用后序遍历，如果抢了当前节点，两个孩子就不能动，如果没抢当前节点，就可以考虑抢左右孩子（<strong>注意这里说的是“考虑”</strong>）</p><p>1、确定递归函数的参数和返回值</p><p>这里我们要求一个节点 偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组。dp[0]代表不偷当前结点，dp[1]代表偷</p><p>2、确定终止条件</p><p>在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回</p><p>3、确定遍历顺序</p><p>首先明确的是使用后序遍历。 因为要通过递归函数的返回值来做下一步计算。</p><p>通过递归左节点，得到左节点偷与不偷的金钱。</p><p>通过递归右节点，得到右节点偷与不偷的金钱。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> leftdp=<span class="title function_">dfs</span>(cur.<span class="property">left</span>)</span><br><span class="line"><span class="keyword">let</span> rightdp=<span class="title function_">dfs</span>(cur.<span class="property">right</span>)</span><br></pre></td></tr></table></figure><p>4、确定单层递归的逻辑</p><p>如果是偷当前节点，那么左右孩子就不能偷，val1 = cur-&gt;val + left[0] + right[0];</p><p>如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：val2 = max(left[0], left[1]) + max(right[0], right[1]);</p><p>5、举例推导dp数组</p><p>以示例1为例，dp数组状态如下：（<strong>注意用后序遍历的方式推导</strong>）</p><!-- <img src="img/image-20230326154953992.png" alt="image-20230326154953992" style="zoom:67%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230326154953992.png" style="width:80%;"/></div></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rob = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span>=(<span class="params">cur</span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">null</span>) <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> leftdp=<span class="title function_">dfs</span>(cur.<span class="property">left</span>)</span><br><span class="line">        <span class="keyword">let</span> rightdp=<span class="title function_">dfs</span>(cur.<span class="property">right</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> valSteal=cur.<span class="property">val</span>+leftdp[<span class="number">0</span>]+rightdp[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> valNoSteal=<span class="title class_">Math</span>.<span class="title function_">max</span>(leftdp[<span class="number">0</span>],leftdp[<span class="number">1</span>])+<span class="title class_">Math</span>.<span class="title function_">max</span>(rightdp[<span class="number">0</span>],rightdp[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> [valNoSteal,valSteal]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="title function_">dfs</span>(root)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">0</span>],dp[<span class="number">1</span>])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="22-买卖股票的最佳时机"><a href="#22-买卖股票的最佳时机" class="headerlink" title="22. 买卖股票的最佳时机"></a>22. 买卖股票的最佳时机</h3><p>121</p><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>可以用贪心算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">prices</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> minPrices=prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> profitMax=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;prices.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i]&lt;minPrices)&#123;</span><br><span class="line">            minPrices=prices[i]</span><br><span class="line">        &#125;</span><br><span class="line">        profitMax=<span class="title class_">Math</span>.<span class="title function_">max</span>(prices[i]-minPrices,profitMax)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profitMax</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以用动态规划</p><p>1、 dp[i] [0] 表示第i天不持有股票所得最多现金，dp[i] [1] 表示第i天持有股票所得最多现金 </p><p>2、</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][0]</span></span><br><span class="line"><span class="comment">//第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1][1]</span></span><br><span class="line">dp[i][<span class="number">0</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line"></span><br><span class="line"><span class="comment">//第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][1]</span></span><br><span class="line"><span class="comment">//第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]</span></span><br><span class="line">dp[i][<span class="number">1</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>],-prices[i])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、dp数组如何初始化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span> <span class="comment">// 未持有</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>] <span class="comment">// 持有</span></span><br></pre></td></tr></table></figure><p>4、从前往后</p><p>5、dp</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">prices</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(prices.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span> <span class="comment">// 未持有</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>] <span class="comment">// 持有</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;prices.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">        dp[i][<span class="number">1</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>],-prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.<span class="property">length</span>-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="23-买卖股票的最佳时机II"><a href="#23-买卖股票的最佳时机II" class="headerlink" title="23. 买卖股票的最佳时机II"></a>23. 买卖股票的最佳时机II</h3><p>122</p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>和上一题的唯一区别就是在递推公式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp[i][1]=Math.max(dp[i-1][1],-prices[i]) 区别在这里</span></span><br><span class="line">dp[i][<span class="number">1</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>],d[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i])  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">prices</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(prices.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span> <span class="comment">// 未持有</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>] <span class="comment">// 持有</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;prices.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">        dp[i][<span class="number">1</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.<span class="property">length</span>-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这道题用贪心算法很快的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">prices</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> total=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;prices.<span class="property">length</span>-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        total+=<span class="title class_">Math</span>.<span class="title function_">max</span>(prices[i+<span class="number">1</span>]-prices[i],<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="24-买卖股票最佳时机III"><a href="#24-买卖股票最佳时机III" class="headerlink" title="24. 买卖股票最佳时机III"></a>24. 买卖股票最佳时机III</h3><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>1、确定dp数组以及下标的含义</p><p>一天一共就有五个状态，</p><ol><li>没有操作 （其实我们也可以不设置这个状态）</li><li>第一次持有股票     dp[i] [1]</li><li>第一次不持有股票 dp[i] [2]</li><li>第二次持有股票     dp[i] [3]</li><li>第二次不持有股票 dp[i] [4]</li></ol><p>2、确定递推公式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">dp[i][<span class="number">2</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">2</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">dp[i][<span class="number">3</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">3</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]-prices[i])</span><br><span class="line">dp[i][<span class="number">4</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">4</span>],dp[i-<span class="number">1</span>][<span class="number">3</span>]+prices[i])</span><br></pre></td></tr></table></figure><p>3、dp数组如何初始化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>  <span class="comment">// 第0天没有操作</span></span><br><span class="line">   dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>] <span class="comment">// 第0天做第一次买入的操作</span></span><br><span class="line">   dp[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span><span class="comment">// 第0天做第一次卖出的操作</span></span><br><span class="line">   dp[<span class="number">0</span>][<span class="number">3</span>]=-prices[<span class="number">0</span>] <span class="comment">// 第0天第二次买入操作</span></span><br><span class="line">   dp[<span class="number">0</span>][<span class="number">4</span>]=<span class="number">0</span><span class="comment">// 第0天做第二次卖出的操作</span></span><br></pre></td></tr></table></figure><p>4、确定遍历顺序</p><p>从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</p><p>5、举例推导dp数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">prices</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(prices.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">4</span>).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br><span class="line">    </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">3</span>]=-prices[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">4</span>]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;prices.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">1</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        dp[i][<span class="number">2</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">2</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">        dp[i][<span class="number">3</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">3</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]-prices[i])</span><br><span class="line">        dp[i][<span class="number">4</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">4</span>],dp[i-<span class="number">1</span>][<span class="number">3</span>]+prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.<span class="property">length</span>-<span class="number">1</span>][<span class="number">4</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">prices</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = prices.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">5</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">1</span>], dp[<span class="number">0</span>] - prices[i]);</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">2</span>], dp[<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">3</span>], dp[<span class="number">2</span>] - prices[i]);</span><br><span class="line">        dp[<span class="number">4</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">4</span>], dp[<span class="number">3</span>] + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">4</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="25-买卖股票的最佳时机IV"><a href="#25-买卖股票的最佳时机IV" class="headerlink" title="25. 买卖股票的最佳时机IV"></a>25. 买卖股票的最佳时机IV</h3><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>这道题思路和上一道一样，只是变成了k次交易</p><p>1、同上</p><p>2、确定递推公式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*k;j+=<span class="number">2</span>)&#123;</span><br><span class="line">   dp[i][j+<span class="number">1</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][j+<span class="number">1</span>],dp[i-<span class="number">1</span>][j]-prices[i])</span><br><span class="line">   dp[i][j+<span class="number">2</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][j+<span class="number">2</span>],dp[i-<span class="number">1</span>][j+<span class="number">1</span>]+prices[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、dp数组如何初始化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;<span class="number">2</span>*k;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i]=-prices[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、同上</p><p>5、同上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">prices</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">k, prices</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(prices.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>*k+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;<span class="number">2</span>*k;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i]=-prices[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;prices.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*k;j+=<span class="number">2</span>)&#123;</span><br><span class="line">            dp[i][j+<span class="number">1</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][j+<span class="number">1</span>],dp[i-<span class="number">1</span>][j]-prices[i])</span><br><span class="line">            dp[i][j+<span class="number">2</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][j+<span class="number">2</span>],dp[i-<span class="number">1</span>][j+<span class="number">1</span>]+prices[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.<span class="property">length</span>-<span class="number">1</span>][<span class="number">2</span>*k]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">k, prices</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>*k+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;<span class="number">2</span>*k;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        dp[i]=-prices[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;prices.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*k;j+=<span class="number">2</span>)&#123;</span><br><span class="line">            dp[j+<span class="number">1</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j+<span class="number">1</span>],dp[j]-prices[i])</span><br><span class="line">            dp[j+<span class="number">2</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j+<span class="number">2</span>],dp[j+<span class="number">1</span>]+prices[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">2</span>*k]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="26-买卖股票的最佳时机含冷冻期"><a href="#26-买卖股票的最佳时机含冷冻期" class="headerlink" title="26. 买卖股票的最佳时机含冷冻期"></a>26. 买卖股票的最佳时机含冷冻期</h3><p>309</p><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p>示例:</p><ul><li>输入: [1,2,3,0,2]</li><li>输出: 3</li><li>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</li></ul><p>1、确定dp数组以及下标的含义</p><p>dp[i] [j]，第i天状态为j，所剩的最多现金为dp[i][j]。</p><p><strong>其实本题很多同学搞的比较懵，是因为出现冷冻期之后，状态其实是比较复杂度</strong>，例如今天买入股票、今天卖出股票、今天是冷冻期，都是不能操作股票的。</p><p>具体可以区分出如下四个状态：</p><ul><li>状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）</li><li>不持有股票状态，这里就有两种卖出股票状态<ul><li>状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）</li><li>状态三：今天卖出股票</li></ul></li><li>状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</li></ul><p>2、递推公式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) - prices[i]); <span class="comment">// 持有</span></span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);   <span class="comment">// 保持卖出股票的状态</span></span><br><span class="line">dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];                                       <span class="comment">// 卖出股票</span></span><br><span class="line">dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];   <span class="comment">// 冷冻期</span></span><br></pre></td></tr></table></figure><p>3、初始化</p><p>dp[0] [0] = -prices[0] 其他为0</p><p>4、遍历顺序就是正常的顺序</p><p>5、dp数组</p><!-- <img src="img/image-20230403211114451.png" alt="image-20230403211114451" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230403211114451.png" style="width:80%;"/></div></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">prices</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.<span class="property">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(prices.<span class="property">length</span> &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, prices[<span class="number">1</span>] - prices[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title class_">Array</span>(prices.<span class="property">length</span>), <span class="function">() =&gt;</span> <span class="title class_">Array</span>(<span class="number">4</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> - prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">3</span>]) - prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i -<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">        dp[i][<span class="number">2</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">        dp[i][<span class="number">3</span>] = dp[i-<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[prices.<span class="property">length</span> - <span class="number">1</span>][<span class="number">1</span>], dp[prices.<span class="property">length</span> - <span class="number">1</span>][<span class="number">2</span>], dp[prices.<span class="property">length</span> - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="27-买卖股票的最佳时机含手续费"><a href="#27-买卖股票的最佳时机含手续费" class="headerlink" title="27. 买卖股票的最佳时机含手续费"></a>27. 买卖股票的最佳时机含手续费</h3><p>714</p><p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p>这道题很简单 和23II差不多</p><p>递推公式：</p><p>dp[i] [0] 表示第i天持有股票所省最多现金。 dp[i] [1] 表示第i天不持有股票所得最多现金</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = <span class="title function_">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="title function_">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//简化：</span></span><br><span class="line">dp[<span class="number">0</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">0</span>],dp[<span class="number">1</span>]-prices[i]) </span><br><span class="line">dp[<span class="number">1</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">1</span>],dp[<span class="number">0</span>]+prices[i]-fee)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">maxProfit</span> = (<span class="params">prices,fee</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title class_">Array</span>(prices.<span class="property">length</span>), <span class="function">() =&gt;</span> <span class="title class_">Array</span>(<span class="number">2</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> - prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee, dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[prices.<span class="property">length</span> - <span class="number">1</span>][<span class="number">0</span>], dp[prices.<span class="property">length</span> - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">prices</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">fee</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices, fee</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=[-prices[<span class="number">0</span>],<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;prices.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">0</span>],dp[<span class="number">1</span>]-prices[i])</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">1</span>],dp[<span class="number">0</span>]+prices[i]-fee)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="28-最长连续递增序列"><a href="#28-最长连续递增序列" class="headerlink" title="28. 最长连续递增序列"></a>28. 最长连续递增序列</h3><p>674</p><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p><p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p><p>1、<strong>dp[i]：以下标i为结尾的连续递增的子序列长度为dp[i]</strong>。</p><p>2、确定递推公式。if(nums[i] &gt; nums[i - 1]) dp[i] = dp[i - 1] + 1;</p><p>3、以下标i为结尾的连续递增的子序列长度最少也应该是1，即就是nums[i]这一个元素。所以dp[i]应该初始1;</p><p>4、遍历顺序，就是从前往后遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123; <span class="comment">// 连续记录</span></span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、打印dp</p><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findLengthOfLCIS = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">        &#125; </span><br><span class="line">        res=<span class="title class_">Math</span>.<span class="title function_">max</span>(res,dp[i]) <span class="comment">// 找到最大dp值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="29-最长上升子序列"><a href="#29-最长上升子序列" class="headerlink" title="29. 最长上升子序列"></a>29. 最长上升子序列</h3><p>300</p><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p>1、dp[i]表示<strong>以nums[i]结尾的最长递增子序列的长度</strong></p><p>2、位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p><p>所以：if (nums[i] &gt; nums[j])     dp[i] = max(dp[i], dp[j] + 1);</p><p>3、dp[i]的初始化，每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1.</p><p>4、确定遍历顺序，dp[i] 是有0到i-1各个位置的最长递增子序列 推导而来，那么遍历i一定是从前向后遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt; nums.<span class="title function_">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = <span class="title function_">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[i] &gt; result) result = dp[i]; <span class="comment">// 取长的子序列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[j])</span><br><span class="line">            dp[i]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j]+<span class="number">1</span>,dp[i])</span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i],res)  <span class="comment">// 需要遍历dp[i]取得最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="30-最长重复子数组"><a href="#30-最长重复子数组" class="headerlink" title="30. 最长重复子数组"></a>30. 最长重复子数组</h3><p>718</p><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：长度最长的公共子数组是 [3,2,1] 。</span><br></pre></td></tr></table></figure><p>解题思路：二维数组，横轴和纵轴上相等的为一，不等的为0，找出最长连续的斜线</p><p>1、dp[i] [j] 表示以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度</p><p>2、即当A[i - 1] 和B[j - 1]相等的时候，dp[i] [j] = dp[i - 1] [j - 1] + 1;</p><p>3、根据dp[i][j]的定义，dp[i] [0] 和dp[0] [j]其实都是没有意义的！但dp[i] [0] 和dp[0] [j]要初始值，因为 为了方便递归公式dp[i] [j] = dp[i - 1] [j - 1] + 1;所以dp[i] [0] 和dp[0] [j]初始化为0。</p><p>4、</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=nums1.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=nums2.<span class="property">length</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i-<span class="number">1</span>]==nums2[j-<span class="number">1</span>])&#123;</span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i][j],res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、 打印dp</p><!-- <img src="img/image-20230405161331968.png" alt="image-20230405161331968" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230405161331968.png" style="width:80%;"/></div></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findLength = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(nums1.<span class="property">length</span>+<span class="number">1</span>).<span class="title function_">fill</span>().<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(nums2.<span class="property">length</span>+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=nums1.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=nums2.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i-<span class="number">1</span>]==nums2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            res=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i][j],res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="31-最长公共子序列"><a href="#31-最长公共子序列" class="headerlink" title="31. 最长公共子序列"></a>31. 最长公共子序列</h3><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> </p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p>1、dp[i] [j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i] [j]</p><p>2、 text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dp[i][j] = <span class="title function_">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、 dp数组如何初始化</p><p>dp[i] [0] =0，dp[0] [j]也是0。</p><p>4、有三个方向可以推出dp[i] [j]</p><!-- <img src="img/image-20230405170112288.png" alt="image-20230405170112288" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230405170112288.png" style="width:80%;"/></div></div><p>5、以输入：text1 = “abcde”, text2 = “ace” 为例，dp状态如图：</p><!-- <img src="img/image-20230405170154061.png" alt="image-20230405170154061" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230405170154061.png" style="width:80%;"/></div></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">text1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">text2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestCommonSubsequence = <span class="keyword">function</span>(<span class="params">text1, text2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(text1.<span class="property">length</span>+<span class="number">1</span>).<span class="title function_">fill</span>().<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(text2.<span class="property">length</span>+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=text1.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=text2.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text1[i-<span class="number">1</span>]==text2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[text1.<span class="property">length</span>][text2.<span class="property">length</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="33-不相交的线"><a href="#33-不相交的线" class="headerlink" title="33. 不相交的线"></a>33. 不相交的线</h3><p>1035</p><p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p><p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足满足：</p><ul><li><code>nums1[i] == nums2[j]</code></li><li>且绘制的直线不与任何其他连线（非水平线）相交。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,4,2], nums2 = [1,2,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：可以画出两条不交叉的线，如上图所示。 </span><br><span class="line">但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。</span><br></pre></td></tr></table></figure><p><strong>本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！</strong></p><p>思路算法都和上一题一样</p><h3 id="34-最大子序和"><a href="#34-最大子序和" class="headerlink" title="34. 最大子序和"></a>34. 最大子序和</h3><p>53</p><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6</p><p>1、<strong>dp[i]：以nums[i]为结尾的最大连续子序列和为dp[i]</strong>。</p><p>2、dp[i]只有两个方向可以推出来：</p><ul><li>dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和</li><li>nums[i]，即：从头开始计算当前连续子序列和</li></ul><p>dp[i] = max(dp[i - 1] + nums[i], nums[i]);</p><p>3、初始化，从递推公式可以看出来dp[i]是依赖于dp[i - 1]的状态，dp[0]就是递推公式的基础。dp[0] = nums[0]</p><p>4、递推公式中dp[i]依赖于dp[i - 1]的状态，需要从前向后遍历。</p><p>5、举例推导dp数组</p><!-- <img src="img/image-20230406110157392.png" alt="image-20230406110157392" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230406110157392.png" style="width:80%;"/></div></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">maxSubArray</span> = nums =&gt; &#123;</span><br><span class="line">    <span class="comment">// 数组长度，dp初始化</span></span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(len).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 最大值初始化为dp[0]</span></span><br><span class="line">    <span class="keyword">let</span> max = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">        <span class="comment">// 更新最大值</span></span><br><span class="line">        max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="35-不同的子序列"><a href="#35-不同的子序列" class="headerlink" title="35. 不同的子序列"></a>35. 不同的子序列</h3><p>115</p><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数。</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">如下所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。</span><br><span class="line">rabbbit</span><br><span class="line">rabbbit</span><br><span class="line">rabbbit</span><br></pre></td></tr></table></figure><p>1、dp[i] [j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i] [j]。</p><p>2、这一类问题，基本是要分析两种情况</p><ul><li><p>s[i - 1] 与 t[j - 1]相等    dp[i] [j]可以有两部分组成。</p><p>一部分是用s[i - 1]来匹配，那么个数为dp[i - 1] [j - 1]。即不需要考虑当前s子串和t子串的最后一位字母，所以只需要 dp[i-1] [j-1]。</p><p>一部分是不用s[i - 1]来匹配，个数为dp[i - 1] [j]。例如s：bagg 和 t：bag ，s[3] 和 t[2]是相同的</p><p>dp[i] [j] = dp[i - 1] [j - 1] + dp[i - 1] [j];</p></li><li><p>s[i - 1] 与 t[j - 1] 不相等  dp[i] [j]只有一部分组成，不用s[i - 1]来匹配（就是模拟在s中删除这个元素），即：dp[i - 1] [j]</p></li></ul><p>3、从递推公式dp[i][j] = dp[i - 1] [j - 1] + dp[i - 1] [j]; 和 dp[i][j] = dp[i - 1] [j]; 中可以看出dp[i][j] 是从上方和左上方推导而来，如图：，那么 dp[i] [0] 和dp[0] [j]是一定要初始化的。</p><!-- <img src="img/image-20230410105039247.png" alt="image-20230410105039247" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230410105039247.png" style="width:80%;"/></div></div><p>dp[i] [0]=1   dp[0] [0]=1   dp[0] [j]=0</p><p>dp[i] [0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。</p><p>dp[0] [j]：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。</p><p>4、遍历顺序</p><p>可以看出dp[i][j]都是根据左上方和正上方推出来的。</p><p>5、打印dp<br><!-- <img src="img/image-20230410105248004.png" alt="image-20230410105248004" style="zoom:80%;" /> --><br><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230410105248004.png" style="width:80%;"/></div></div><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">t</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numDistinct = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(s.<span class="property">length</span>+<span class="number">1</span>).<span class="title function_">fill</span>().<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(t.<span class="property">length</span>+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=t.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i-<span class="number">1</span>]==t[j-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+dp[i-<span class="number">1</span>][j]</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="property">length</span>][t.<span class="property">length</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="36-两个字符串的删除操作"><a href="#36-两个字符串的删除操作" class="headerlink" title="36. 两个字符串的删除操作"></a>36. 两个字符串的删除操作</h3><p>583</p><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和 <code>word2</code> <strong>相同</strong>所需的<strong>最小步数</strong>。</p><p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: word1 = &quot;sea&quot;, word2 = &quot;eat&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 第一步将 &quot;sea&quot; 变为 &quot;ea&quot; ，第二步将 &quot;eat &quot;变为 &quot;ea&quot;</span><br></pre></td></tr></table></figure><p>另一种思路：本题和动态规划：1143.最长公共子序列基本相同，只要求出两个字符串的最长公共子序列长度即可，那么除了最长公共子序列之外的字符都是必须删除的，最后用两个字符串的总长度减去两个最长公共子序列的长度就是删除的最少步数。</p><p>1、dp[i] [j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</p><p>2、</p><ul><li>当word1[i - 1] 与 word2[j - 1]相同的时候  dp[i] [j] = dp[i - 1] [j - 1]</li><li>当word1[i - 1] 与 word2[j - 1]不相同的时候 </li></ul><p>情况一：删word1[i - 1]，最少操作次数为dp[i - 1] [j] + 1</p><p>情况二：删word2[j - 1]，最少操作次数为dp[i] [j - 1] + 1</p><p>情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1] [j - 1] + 2</p><p>dp[i] [j] = min(dp[i - 1] [j] + 1, dp[i] [j - 1] + 1);</p><p>3、初始化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= word1.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  dp[i][<span class="number">0</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= word2.<span class="property">length</span>; j++) &#123;</span><br><span class="line">  dp[<span class="number">0</span>][j] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、顺序</p><p>5、dp</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">word1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">word2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDistance = <span class="keyword">function</span>(<span class="params">word1, word2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(word1.<span class="property">length</span> + <span class="number">1</span>), <span class="function">() =&gt;</span><span class="title class_">Array</span>(word2.<span class="property">length</span> + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= word1.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= word2.<span class="property">length</span>; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= word1.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= word2.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] === word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">min</span>(</span><br><span class="line">                dp[i - <span class="number">1</span>][j] + <span class="number">1</span>,</span><br><span class="line">                dp[i][j - <span class="number">1</span>] + <span class="number">1</span>,</span><br><span class="line">                dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[word1.<span class="property">length</span>][word2.<span class="property">length</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="37-编辑距离"><a href="#37-编辑距离" class="headerlink" title="37. 编辑距离"></a>37. 编辑距离</h3><p>72 难</p><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><br><span class="line">rorse -&gt; rose (删除 &#x27;r&#x27;)</span><br><span class="line">rose -&gt; ros (删除 &#x27;e&#x27;)</span><br></pre></td></tr></table></figure><p>1、<strong>dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i] [j]</strong>。</p><p>2、确定递推公式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] <span class="comment">//不操作</span></span><br><span class="line"><span class="keyword">if</span> (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>])</span><br><span class="line">    <span class="comment">// 下面取min</span></span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="number">1</span> <span class="comment">// word1删除一个元素</span></span><br><span class="line">    dp[i][j] = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;<span class="comment">// 增， word2删除一个元素，其实就是word1增加一个元素</span></span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span> <span class="comment">// 换,比如ab和ac在dp[i-1][j-1]的基础上，进行替换</span></span><br></pre></td></tr></table></figure><p>3、初始化</p><p>那么dp[i] [0]就应该是i，对word1里的元素全部做删除操作，即：dp[i] [0] = i; 同理dp[0] [j] = j;</p><p>4、</p><!-- <img src="img/image-20230411105108761.png" alt="image-20230411105108761" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230411105108761.png" style="width:80%;"/></div></div><p>5、打印dp</p><!-- <img src="img/image-20230411105153777.png" alt="image-20230411105153777" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articlesimage-20230411105153777.png" style="width:80%;"/></div></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">word1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">word2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDistance = <span class="keyword">function</span>(<span class="params">word1, word2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(word1.<span class="property">length</span>+<span class="number">1</span>).<span class="title function_">fill</span>().<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(word2.<span class="property">length</span>+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=word1.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;=word2.<span class="property">length</span>;j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j]=j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历顺序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=word1.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=word2.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            <span class="comment">// 递推公式</span></span><br><span class="line">            <span class="keyword">if</span>(word1[i-<span class="number">1</span>]==word2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=<span class="title class_">Math</span>.<span class="title function_">min</span>(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>,dp[i][j-<span class="number">1</span>]+<span class="number">1</span>,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[word1.<span class="property">length</span>][word2.<span class="property">length</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="38-回文子串"><a href="#38-回文子串" class="headerlink" title="38. 回文子串"></a>38. 回文子串</h3><p>647 中</p><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><p>1、布尔类型的dp[i] [j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i] [j]为true，否则为false。</p><p>2、就是s[i]与s[j]相等，s[i]与s[j]不相等这两种</p><p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p><ul><li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li><li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li><li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1] [j - 1]是否为true</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">        result++;</span><br><span class="line">        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">        result++;</span><br><span class="line">        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>result就是统计回文子串的数量。</p><p>3、dp[i] [j]可以初始化为true么？ 当然不行，怎能刚开始就全都匹配上了。</p><p>所以dp[i] [j]初始化为false。</p><p>4、情况三是根据dp[i + 1] [j - 1]是否为true，在对dp[i] [j]进行赋值true的。dp[i + 1] [j - 1] 在 dp[i][j]的左下角，如图：</p><!-- <img src="img/image-20230412151838388.png" alt="image-20230412151838388" style="zoom: 67%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230412151838388.png" style="width:80%;"/></div></div><p><strong>所以一定要从下到上，从左到右遍历，这样保证dp[i + 1] [j - 1]都是经过计算的</strong></p><p>5、</p><!-- <img src="img/image-20230412151923939.png" alt="image-20230412151923939" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230412151923939.png" style="width:80%;"/></div></div><p><strong>注意因为dp[i] [j]的定义，所以j一定是大于等于i的，那么在填充dp[i][j]的时候一定是只填充右上半部分</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countSubstrings = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(s.<span class="property">length</span>).<span class="title function_">fill</span>().<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(s.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="literal">false</span>))</span><br><span class="line">    <span class="keyword">let</span> numOfPalindromicStr=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=s.<span class="property">length</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&lt;s.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]===s[j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="literal">true</span></span><br><span class="line">                    numOfPalindromicStr+=<span class="number">1</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j]=<span class="literal">true</span></span><br><span class="line">                    numOfPalindromicStr+=<span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numOfPalindromicStr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="39-最长回文子串"><a href="#39-最长回文子串" class="headerlink" title="39. 最长回文子串"></a>39. 最长回文子串</h3><p>5</p><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p>1、布尔类型的dp[i] [j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i] [j]为true，否则为false。</p><p>2、就是s[i]与s[j]相等，s[i]与s[j]不相等这两种</p><p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p><ul><li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li><li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li><li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1] [j - 1]是否为true</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dp[i][j]&amp;&amp;j-i+<span class="number">1</span>&gt;maxLength)&#123; <span class="comment">// 判断是否最大长度</span></span><br><span class="line">                maxLength=j-i+<span class="number">1</span></span><br><span class="line">                left=i</span><br><span class="line">                right=j</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>后面和上一题完全一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(s.<span class="property">length</span>).<span class="title function_">fill</span>().<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(s.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="literal">false</span>))</span><br><span class="line">    <span class="keyword">let</span> maxLength=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=s.<span class="property">length</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&lt;s.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="literal">true</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j-<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j]=<span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]&amp;&amp;j-i+<span class="number">1</span>&gt;maxLength)&#123;</span><br><span class="line">                maxLength=j-i+<span class="number">1</span></span><br><span class="line">                left=i</span><br><span class="line">                right=j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">slice</span>(left,right+<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="40-最长回文子序列"><a href="#40-最长回文子序列" class="headerlink" title="40. 最长回文子序列"></a>40. 最长回文子序列</h3><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;bbbab&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。</span><br></pre></td></tr></table></figure><p><strong>回文子串是要连续的，回文子序列可不是连续的</strong></p><p>1、dp[i] [j]：字符串s在[i, j]范围内最长的回文子序列的长度</p><p>2、如果s[i]与s[j]相同，那么dp[i] [j] = dp[i + 1] [j - 1] + 2;</p><p>​      如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。加入s[j]的回文子序列长度为dp[i + 1] [j]。加入s[i]的回文子序列长度为dp[i] [j - 1]。</p><p>那么dp[i] [j]一定是取最大的，即：dp[i] [j] = max(dp[i + 1] [j], dp[i] [j - 1]);</p><p>3、首先要考虑当i 和j 相同的情况，从递推公式：dp[i] [j] = dp[i + 1] [j - 1] + 2; 可以看出 递推公式是计算不到 i 和j相同时候的情况。</p><p>所以需要手动初始化一下，当i与j相同，那么dp[i] [j]一定是等于1的，其他情况dp[i][j]初始为0就行。</p><p>4、遍历顺序</p><!-- <img src="img/image-20230413203247108.png" alt="image-20230413203247108" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230413203247108.png" style="width:80%;"/></div></div><!-- 5、<img src="img/image-20230413203311292.png" alt="image-20230413203311292" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230413203311292.png" style="width:80%;"/></div></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestPalindromeSubseq = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp=<span class="keyword">new</span> <span class="title class_">Array</span>(s.<span class="property">length</span>).<span class="title function_">fill</span>().<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(s.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        dp[i][i]=<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=s.<span class="property">length</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;s.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                dp[i][j]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">2</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i][j-<span class="number">1</span>],dp[i+<span class="number">1</span>][j])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][s.<span class="property">length</span>-<span class="number">1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十六 算法-几种排序</title>
      <link href="/2023/04/30/16/"/>
      <url>/2023/04/30/16/</url>
      
        <content type="html"><![CDATA[<h2 id="几种排序"><a href="#几种排序" class="headerlink" title="几种排序"></a>几种排序</h2><!-- ![image-20230215103226860](img/image-20230215103226860.png) --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230215103226860.png" style="width:80%;"/></div></div><p><strong>稳定性</strong>：保证排序前两个相等的数据其在序列中的先后位置顺序与排序后它们两个先后位置顺序相同</p><!-- ![image-20230217153452930](img/image-20230217153452930.png) --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230217153452930.png" style="width:80%;"/></div></div><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><p>冒泡排序算法的原理如下：</p><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</p><p>针对所有的元素重复以上的步骤，除了最后一个。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">      <span class="comment">//每轮循环都从最后一个元素开始 比较并交换 一次循环会把最小的数顶到最上面</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;nums.<span class="property">length</span>-<span class="number">1</span>-i;j++)&#123;<span class="comment">// 控制比较的次数</span></span><br><span class="line">          <span class="comment">// 交换</span></span><br><span class="line">          <span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">let</span> temp=nums[j+<span class="number">1</span>]</span><br><span class="line">            nums[j+<span class="number">1</span>]=nums[j]</span><br><span class="line">            nums[j]=temp</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//test</span></span><br><span class="line">    nums = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>];</span><br><span class="line">    <span class="title function_">bubbleSort</span>(nums);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(nums);</span><br></pre></td></tr></table></figure><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h3><p>第一次从待排序的数据元素中选出最小的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。</p><p>算法思路：</p><p>1）假设未排序序列的第一个是最小值，记下该元素的位置，从后往前比较<br>2）找出最小的一个元素<br>3）然后将最小元素与记录元素交换位置<br>4）重复第二，三个步骤，直到找完未排序的部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectSort</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="comment">//和冒泡排序类似，但是并不在每次比较后交换 而是记录最小值(初识最小值为nums[i]) 最后再交换一次 </span></span><br><span class="line">  <span class="comment">//每次循环也是从最后开始 把最小元素放到最顶部</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123; <span class="comment">//n -1循环</span></span><br><span class="line">    <span class="keyword">let</span> index=i</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=arr.<span class="property">length</span>-<span class="number">1</span>;j&gt;i;j--)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j]&lt;arr[index])&#123;</span><br><span class="line">        index=j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">    <span class="keyword">let</span> temp=arr[i]</span><br><span class="line">    arr[i]=arr[index]</span><br><span class="line">    arr[index]=temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr=[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line"><span class="title function_">selectSort</span>(arr)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br></pre></td></tr></table></figure><h3 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3. 直接插入排序"></a>3. 直接插入排序</h3><p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><strong>算法描述：</strong></p><p>一般来说，插入排序都采用 in-place 在数组上实现：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素a，在已经排序的元素序列中从后向前扫描；</li><li>如果a比之前的元素小，就交换位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertionSort</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="comment">//插入排序 从第二个元素开始 把元素插入到合适的位置 每次比较（除了最后一次）都要交换</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j]&lt;arr[j-<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[j-<span class="number">1</span>]</span><br><span class="line">        arr[j-<span class="number">1</span>]=arr[j]</span><br><span class="line">        arr[j]=temp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//test</span></span><br><span class="line">nums = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>];</span><br><span class="line"><span class="title function_">insertionSort</span>(nums);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nums);</span><br></pre></td></tr></table></figure><h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4. 快速排序"></a>4. 快速排序</h3><p>选择数组中的一个值作为基准(arr[0])，将数组中小于该值的数置于该数之前，大于该值的数置于该数之后，接着对该数前后的两个数组进行重复操作直至排序完成。</p><p>算法步骤：</p><p>1.定义一个函数，传入参数，判断这个参数的长度，如果长度是1，直接ruturn出去，如果是进入下一步。<br>2.将这个数组头部的值作为中位数，定义两个新的数组left，right，然后让原数组中剩余的数与这个中位数比较，比中位数小的放到left数组，比中位数大的放到right,然后再对这两个数组进行递归。<br>3.最后将arrleft, 中位数，arrright拼接，return出去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quckSort</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr.<span class="property">length</span>&lt;=<span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">let</span> mid=arr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> left=[], right=[]</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i]&lt;mid) left.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    <span class="keyword">else</span> right.<span class="title function_">push</span>(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="title function_">quckSort</span>(left),mid,...<span class="title function_">quckSort</span>(right)]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr=[<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">quckSort</span>(arr))</span><br></pre></td></tr></table></figure><h3 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5. 堆排序"></a>5. 堆排序</h3><p>一、什么是堆<br>堆首先是一个完全二叉树，堆分为大顶堆和小顶堆</p><p>大顶堆：每个节点的值大于或等于其左右孩子节点的值，称为大顶堆。<br>小顶堆：每个节点的值小于或等于其左右孩子节点的值。</p><p>注意：每个节点的左右孩子节点的大小关系并没有限定。</p><!-- <img src="img/image-20230216201523994.png" alt="image-20230216201523994" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230216201523994.png" style="width:80%;"/></div></div><p><strong>堆排序基本思想</strong></p><p>以大顶堆为例，算法步骤如下：</p><p>1、首先将待排序序列构建成一个大顶堆(<strong>存入数组中</strong>)，那么这时，整个序列的最大值就是堆顶的根节点；</p><p>2、将堆顶元素与最后一个元素交换，那么末尾元素就存入了最大值；</p><p>3、将剩余的 n - 1个元素重新构建成一个大顶堆，重复上面的操作；</p><p>反复执行，就能得到一个有序序列了。</p><!-- 原文链接：https://blog.csdn.net/qq_48315043/article/details/121405814 --><div class="tag link"><a class="link-card" title="堆排序" href="https://blog.csdn.net/qq_48315043/article/details/121405814"><div class="left"><img src="/img/icon/wwwicon.png"/></div><div class="right"><p class="text">堆排序</p><p class="url">https://blog.csdn.net/qq_48315043/article/details/121405814</p></div></a></div><h3 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h3><p>归并排序使用<strong>分而治之</strong>的概念对给定的元素列表进行排序。它将问题分解为较小的子问题，直到它们变得足够简单以至可以直接解决为止。</p><p>归并排序，顾名思义，就是把两个已经排好序的数组进行归并，成为一个新排序好的序列。</p><!-- https://blog.csdn.net/weixin_46726346/article/details/115025135 --><div class="tag link"><a class="link-card" title="归并排序" href="https://blog.csdn.net/weixin_46726346/article/details/115025135"><div class="left"><img src="/img/icon/wwwicon.png"/></div><div class="right"><p class="text">归并排序</p><p class="url">https://blog.csdn.net/weixin_46726346/article/details/115025135</p></div></a></div><p>以下是归并排序的步骤：</p><p>1、将给定的列表分为两半（如果列表中的元素数为奇数，则使其大致相等）。</p><p>2、以相同的方式继续划分子数组，直到只剩下单个元素数组。</p><p>3、从单个元素数组开始，<strong>合并</strong>子数组，以便对每个合并的子数组进行排序。</p><p>4、重复第 3 步单元，直到最后得到一个排好序的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr.<span class="property">length</span>===<span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">      <span class="comment">// 将一个数组拆分为两个</span></span><br><span class="line">      <span class="keyword">let</span> mid=<span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span>/<span class="number">2</span>)</span><br><span class="line">      <span class="keyword">let</span> leftArr=arr.<span class="title function_">slice</span>(<span class="number">0</span>,mid)</span><br><span class="line">      <span class="keyword">let</span> rightArr=arr.<span class="title function_">slice</span>(mid)</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">mergeSort</span>(leftArr),<span class="title function_">mergeSort</span>(rightArr))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行归并 将两个有序的数组，归并为一个有序的数组</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">left,right</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> res=[]</span><br><span class="line">      <span class="keyword">while</span>(left.<span class="property">length</span>&gt;<span class="number">0</span>&amp;&amp;right.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>( left[<span class="number">0</span>]&lt;right[<span class="number">0</span>])&#123;</span><br><span class="line">          res.<span class="title function_">push</span>(left.<span class="title function_">shift</span>())</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          res.<span class="title function_">push</span>(right.<span class="title function_">shift</span>())</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res.<span class="title function_">concat</span>(left,right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//test</span></span><br><span class="line">    nums = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> res = <span class="title function_">mergeSort</span>(nums);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><h3 id="7-希尔排序"><a href="#7-希尔排序" class="headerlink" title="7. 希尔排序"></a>7. 希尔排序</h3><p>思想是指定一个间隔（增量）将待排序的元素进行分组，然后再对每一组进行排序，直到间隔（增量）减至1时，整个序列恰好被分成一组，（再进行直接插入排序）最后排成有序序列。</p><p>其中增量序列的选择是非常关键的，但通常我们取步长为 n/2（数组长度的一般）然后一直取半直到 1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shellSort</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> gap = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span>/<span class="number">2</span>);gap &gt; <span class="number">0</span>;gap = <span class="title class_">Math</span>.<span class="title function_">floor</span>(gap/<span class="number">2</span>))&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> i = gap;i &lt; arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">              <span class="keyword">let</span> j = i;</span><br><span class="line">              <span class="keyword">let</span> tmp = arr[j];</span><br><span class="line">              <span class="keyword">if</span>(arr[j] &lt; arr[j-gap])&#123;</span><br><span class="line">                  <span class="comment">// 如果同一组中 前数大于后数，则交换他们</span></span><br><span class="line">                  <span class="keyword">while</span>(j - gap &gt;= <span class="number">0</span> &amp;&amp; arr[j-gap] &gt; tmp)&#123;</span><br><span class="line">                      arr[j] = arr[j-gap];</span><br><span class="line">                      j = j-gap;</span><br><span class="line">                  &#125;</span><br><span class="line">                  arr[j] = tmp;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">let</span> arr = [<span class="number">9</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>];</span><br><span class="line">  <span class="title function_">shellSort</span>(arr)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure><!-- https://blog.csdn.net/weixin_51445423/article/details/124572331 --><div class="tag link"><a class="link-card" title="希尔排序" href="https://blog.csdn.net/weixin_51445423/article/details/124572331"><div class="left"><img src="/img/icon/wwwicon.png"/></div><div class="right"><p class="text">希尔排序</p><p class="url">https://blog.csdn.net/weixin_51445423/article/details/124572331</p></div></a></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十五 算法-回溯算法</title>
      <link href="/2023/04/20/15/"/>
      <url>/2023/04/20/15/</url>
      
        <content type="html"><![CDATA[<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h3 id="1-组合"><a href="#1-组合" class="headerlink" title="1. 组合"></a>1. 组合</h3><p>77</p><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围</strong>。</p><p><strong>图中可以发现n相当于树的宽度，k相当于树的深度</strong>。</p><p>剪枝优化：</p><p>接下来看一下优化过程如下：</p><p>已经选择的元素个数：path.size();</p><p>还需要的元素个数为: k - path.size();</p><p>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</p><p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = startIndex; i &lt;= n; i++) </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> combine = <span class="keyword">function</span>(<span class="params">n, k</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = []</span><br><span class="line"><span class="keyword">let</span> path=[]</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">combineHelper</span> = (<span class="params">n, k, startIndex</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (path.<span class="property">length</span> === k) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>([...path]) <span class="comment">//这里拷贝一下</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex; i &lt;= n; ++i) &#123; <span class="comment">//这里进行剪枝操作 i &lt;= n - (k - path.length) + 1</span></span><br><span class="line">    path.<span class="title function_">push</span>(i)</span><br><span class="line">    <span class="title function_">combineHelper</span>(n, k, i + <span class="number">1</span>)</span><br><span class="line">    path.<span class="title function_">pop</span>() <span class="comment">// 回溯</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">combineHelper</span>(n, k, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-组合总和"><a href="#2-组合总和" class="headerlink" title="2. 组合总和|||"></a>2. 组合总和|||</h3><p>216</p><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong> </li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p>本题就是在[1,2,3,4,5,6,7,8,9]这个集合中找到和为n的k个数的组合。</p><p>相对于77. 组合，无非就是多了一个限制，本题是要找到和为n的k个数的组合，而整个集合已经是固定的了[1,…,9]。</p><p>想到这一点了，做过77. 组合之后，本题是简单一些了。</p><p>本题k相当于树的深度，9（因为整个集合就是9个数）就是树的宽度。</p><p>例如 k = 2，n = 4的话，就是在集合[1,2,3,4,5,6,7,8,9]中求 k（个数） = 2, n（和） = 4的组合。</p><p><img src="img/image-20230307202923321.png" alt="image-20230307202923321" style="zoom:80%;" /></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum3 = <span class="keyword">function</span>(<span class="params">k, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> targetSum=n</span><br><span class="line">    <span class="keyword">let</span> path=[]</span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backTraval</span>=(<span class="params">sum,startIndex</span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;targetSum) <span class="keyword">return</span> <span class="comment">// 剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="property">length</span>==k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(targetSum==sum)&#123;</span><br><span class="line">                res.<span class="title function_">push</span>([...path])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=startIndex;i&lt;=<span class="number">9</span>-(k-path.<span class="property">length</span>)+<span class="number">1</span>;i++)&#123; <span class="comment">// 剪枝</span></span><br><span class="line">            sum+=i</span><br><span class="line">            path.<span class="title function_">push</span>(i)</span><br><span class="line">            <span class="title function_">backTraval</span>(sum,i+<span class="number">1</span>)</span><br><span class="line">            sum-=i</span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTraval</span>(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十四 算法-二叉树</title>
      <link href="/2023/04/15/14/"/>
      <url>/2023/04/15/14/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TreeNode</span>(<span class="params">val, left, right</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = (val===<span class="literal">undefined</span> ? <span class="number">0</span> : val)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = (left===<span class="literal">undefined</span> ? <span class="literal">null</span> : left)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = (right===<span class="literal">undefined</span> ? <span class="literal">null</span> : right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-二叉树的前-中-后序遍历"><a href="#1-二叉树的前-中-后序遍历" class="headerlink" title="1. 二叉树的前/中/后序遍历"></a>1. 二叉树的前/中/后序遍历</h3><p><strong>递归法</strong></p><p>这里帮助大家确定下来递归算法的三个要素。每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p></li><li><p><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p></li><li><p><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p></li></ol><p>144 前序遍历</p><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法 一</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result=[]</span><br><span class="line">    <span class="title function_">dfs</span>(root,result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dfs</span>=(<span class="params">root,result</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="title function_">push</span>(root.<span class="property">val</span>) <span class="comment">// 只需要调整它的位置 就能确定是前中后序遍历</span></span><br><span class="line">    <span class="title function_">dfs</span>(root.<span class="property">left</span>,result)</span><br><span class="line">    <span class="title function_">dfs</span>(root.<span class="property">right</span>,result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法 二</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getMinimumDifference = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="title class_">Infinity</span></span><br><span class="line">    <span class="keyword">let</span> pre=<span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">traversal</span>=(<span class="params">cur</span>)=&gt;&#123;</span><br><span class="line">        <span class="comment">// 确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(!cur) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 确定单层递归逻辑</span></span><br><span class="line">        <span class="title function_">traversal</span>(cur.<span class="property">left</span>)</span><br><span class="line">        <span class="keyword">if</span>(pre)&#123;</span><br><span class="line">            res=<span class="title class_">Math</span>.<span class="title function_">min</span>(res,cur.<span class="property">val</span>-pre.<span class="property">val</span>) <span class="comment">// 中序遍历时 进行逻辑处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre=cur</span><br><span class="line">        <span class="title function_">traversal</span>(cur.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">traversal</span>(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>94 中序遍历 </p><p>145 后序遍历</p><p><strong>迭代法</strong></p><p>为什么可以用迭代法（非递归的方式）来实现二叉树的前后中序遍历呢？</p><p>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><p>此时大家应该知道我们用栈也可以是实现二叉树的前后中序遍历了。</p><p>我们先看一下<strong>前序遍历</strong>。</p><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><p>再来看<strong>后序遍历</strong>，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序。</p><p><strong>中序遍历</strong></p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。</p><p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序迭代</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代法</span></span><br><span class="line">    <span class="keyword">let</span> stack=[]</span><br><span class="line">    <span class="keyword">let</span> result=[]</span><br><span class="line">    stack.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp=stack.<span class="title function_">pop</span>()</span><br><span class="line">        result.<span class="title function_">push</span>(temp.<span class="property">val</span>)</span><br><span class="line">        temp.<span class="property">right</span> &amp;&amp; stack.<span class="title function_">push</span>(temp.<span class="property">right</span>)</span><br><span class="line">        temp.<span class="property">left</span> &amp;&amp; stack.<span class="title function_">push</span>(temp.<span class="property">left</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序迭代</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> nums = [], stack = []</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> nums</span><br><span class="line">    stack.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> cur = stack.<span class="title function_">pop</span>()</span><br><span class="line">        <span class="comment">// 向前添加元素，构造反向顺序</span></span><br><span class="line">        nums.<span class="title function_">unshift</span>(cur.<span class="property">val</span>)</span><br><span class="line">        <span class="comment">// 与先序的左右顺序相反</span></span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="property">left</span>) stack.<span class="title function_">push</span>(cur.<span class="property">left</span>)</span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="property">right</span>) stack.<span class="title function_">push</span>(cur.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序迭代 比较难理解</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> stk = [];</span><br><span class="line">    <span class="keyword">while</span> (root || stk.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            stk.<span class="title function_">push</span>(root);</span><br><span class="line">            root = root.<span class="property">left</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stk.<span class="title function_">pop</span>();</span><br><span class="line">        res.<span class="title function_">push</span>(root.<span class="property">val</span>);</span><br><span class="line">        root = root.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-二叉树的层序遍历"><a href="#2-二叉树的层序遍历" class="headerlink" title="2. 二叉树的层序遍历"></a>2. 二叉树的层序遍历</h3><p>102</p><p>bfs广度优先遍历</p><p><strong>队列先进先出，符合一层一层遍历的逻辑</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/ 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</span><br><span class="line"><span class="comment">// 输入：root = [3,9,20,null,null,15,7]</span></span><br><span class="line"><span class="comment">// 输出：[[3],[9,20],[15,7]]</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">//二叉树的层序遍历</span></span><br><span class="line">    <span class="keyword">let</span> queue=[]</span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    queue.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> length=queue.<span class="property">length</span> <span class="comment">// 记录当前层级节点数</span></span><br><span class="line">        <span class="keyword">let</span> curNode=[]</span><br><span class="line">        <span class="keyword">while</span>(length--)&#123;</span><br><span class="line">            <span class="keyword">let</span> node=queue.<span class="title function_">shift</span>()</span><br><span class="line">            curNode.<span class="title function_">push</span>(node.<span class="property">val</span>) <span class="comment">//存放每一层的节点 </span></span><br><span class="line">            node.<span class="property">left</span> &amp;&amp; queue.<span class="title function_">push</span>(node.<span class="property">left</span>)  <span class="comment">// 存放当前层下一层的节点</span></span><br><span class="line">            node.<span class="property">right</span> &amp;&amp; queue.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="title function_">push</span>(curNode) <span class="comment">//把每一层的结果放到结果数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-翻转二叉树"><a href="#3-翻转二叉树" class="headerlink" title="3. 翻转二叉树"></a>3. 翻转二叉树</h3><p>226 简单难理解</p><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>解析</strong>:这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点 root\textit{root}root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 root\textit{root}root 为根节点的整棵子树的翻转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> right=<span class="title function_">invertTree</span>(root.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">const</span> left=<span class="title function_">invertTree</span>(root.<span class="property">left</span>)</span><br><span class="line">    root.<span class="property">left</span>=right</span><br><span class="line">    root.<span class="property">right</span>=left</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-对称二叉树"><a href="#4-对称二叉树" class="headerlink" title="4. 对称二叉树"></a>4. 对称二叉树</h3><p>101</p><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p>本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。</p><p>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</p><p>但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。</p><p>其实后序也可以理解为是一种回溯，当然这是题外话，讲回溯的时候会重点讲的。</p><p>递归三部曲</p><ol><li>确定递归函数的参数和返回值</li></ol><p>​    因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是</p><p>​    个树，参数自然也是左子树节点和右子树节点。</p><p>​    返回值自然是bool类型。</p><ol><li>确定终止条件</li></ol><p>要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。</p><p>节点为空的情况有：（注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点）</p><p>左节点为空，右节点不为空，不对称，return false<br>左不为空，右为空，不对称 return false<br>左右都为空，对称，返回true<br>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p><p>左右都不为空，比较节点数值，不相同就return false</p><ol><li><p>确定单层递归的逻辑</p><p>此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。</p><p>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。<br>比较内测是否对称，传入左节点的右孩子，右节点的左孩子。<br>如果左右都对称就返回true ，有一侧不对称就返回false 。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">//使用递归遍历左右子树 递归三部曲</span></span><br><span class="line">    <span class="keyword">if</span>(root===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">compareNode</span>(root.<span class="property">left</span>,root.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1. 确定递归的参数 root.left root.right和返回值true false </span></span><br><span class="line">    <span class="keyword">const</span> compareNode=<span class="keyword">function</span>(<span class="params">left,right</span>)&#123;</span><br><span class="line">        <span class="comment">//2. 确定终止条件 空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(left!==<span class="literal">null</span>&amp;&amp;right===<span class="literal">null</span>||left===<span class="literal">null</span>&amp;&amp;right!==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left===<span class="literal">null</span>&amp;&amp;right===<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left.<span class="property">val</span>!==right.<span class="property">val</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 确定单层递归逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">compareNode</span>(left.<span class="property">left</span>,right.<span class="property">right</span>)&amp;&amp;<span class="title function_">compareNode</span>(left.<span class="property">right</span>,right.<span class="property">left</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-二叉树的最大深度"><a href="#5-二叉树的最大深度" class="headerlink" title="5. 二叉树的最大深度"></a>5. 二叉树的最大深度</h3><p>104</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。</p><p>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）<br>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数后者节点数（取决于高度从0开始还是从1开始）<br>而根节点的高度就是二叉树的最大深度，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="comment">// 终止递归条件</span></span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定单层递归逻辑</span></span><br><span class="line">    <span class="keyword">let</span> leftHeight=<span class="title function_">maxDepth</span>(root.<span class="property">left</span>)</span><br><span class="line">    <span class="keyword">let</span> rightHeight=<span class="title function_">maxDepth</span>(root.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">let</span> height=<span class="number">1</span>+<span class="title class_">Math</span>.<span class="title function_">max</span>(leftHeight,rightHeight)</span><br><span class="line">    <span class="keyword">return</span> height</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-二叉树的最小深度"><a href="#6-二叉树的最小深度" class="headerlink" title="6. 二叉树的最小深度"></a>6. 二叉树的最小深度</h3><p>111</p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><p><strong>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</strong>，注意是<strong>叶子节点</strong>。</p><p>注意一个重点，不然容易陷入误区：</p><p>如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。</p><p>反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。 </p><p>最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 确定递归函数的参数和返回值</span></span><br><span class="line"><span class="keyword">var</span> minDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 2. 确定终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 确定单层递归逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">left</span>===<span class="literal">null</span>&amp;&amp;root.<span class="property">right</span>!==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="title function_">minDepth</span>(root.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">left</span>!==<span class="literal">null</span>&amp;&amp;root.<span class="property">right</span>===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="title function_">minDepth</span>(root.<span class="property">left</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+<span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="title function_">minDepth</span>(root.<span class="property">left</span>),<span class="title function_">minDepth</span>(root.<span class="property">right</span>))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-完全二叉树的节点个数"><a href="#7-完全二叉树的节点个数" class="headerlink" title="7. 完全二叉树的节点个数"></a>7. 完全二叉树的节点个数</h3><p>222</p><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><a href="https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2h</code> 个节点。</p><p>普通二叉树的解法 , 时间复杂度为O(n)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countNodes = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">countNodes</span>(root.<span class="property">left</span>)+<span class="title function_">countNodes</span>(root.<span class="property">right</span>)+<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完全二叉树</p><p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p><p>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。</p><p>对于情况二，分别递归左<strong><em>，和右</em></strong>，递归到某一深度一定会有左或者右为满二叉树，然后依然可以按照情况1来计算。</p><!-- <img src="C:\Users\Administrator\Desktop\前端\同步typora笔记\img\image-20230105150755150.png" alt="image-20230105150755150" style="zoom: 50%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230105150755150.png" style="width:80%;"/></div></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countNodes = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 确定终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否为满二叉树，如果是就采用2^深度-1,计算节点数</span></span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> node=root</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        left++</span><br><span class="line">        node=node.<span class="property">left</span></span><br><span class="line">    &#125;</span><br><span class="line">    node=root</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        right++</span><br><span class="line">        node=node.<span class="property">right</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> ** left)-<span class="number">1</span> <span class="comment">// ** 可以看做是Math.pow（x , y）的语法糖，其作用与Math.pow()一致</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定单层递归逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+<span class="title function_">countNodes</span>(root.<span class="property">left</span>)+<span class="title function_">countNodes</span>(root.<span class="property">right</span>)</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="8-平衡二叉树"><a href="#8-平衡二叉树" class="headerlink" title="8. 平衡二叉树"></a>8. 平衡二叉树</h3><p>110 易</p><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><p>解析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isBalanced = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getBalanced</span>=(<span class="params">root</span>)=&gt;&#123;</span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        <span class="comment">// 2. 确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 确定单层递归逻辑</span></span><br><span class="line">        <span class="keyword">let</span> rootLeft=<span class="title function_">getBalanced</span>(root.<span class="property">left</span>)</span><br><span class="line">        <span class="keyword">if</span>(rootLeft==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> rootRight=<span class="title function_">getBalanced</span>(root.<span class="property">right</span>)</span><br><span class="line">        <span class="keyword">if</span>(rootRight==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment">// 判断是否平衡，若不平衡返回-1，若平衡则返回最大高度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(rootLeft-rootRight)&gt;<span class="number">1</span> ? -<span class="number">1</span> :<span class="number">1</span>+ <span class="title class_">Math</span>.<span class="title function_">max</span>(rootLeft,rootRight)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  !(<span class="title function_">getBalanced</span>(root) === -<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="9-二叉树的所有路径"><a href="#9-二叉树的所有路径" class="headerlink" title="9. 二叉树的所有路径"></a>9. 二叉树的所有路径</h3><p>257 简单</p><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p>采用了回溯的算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> binaryTreePaths = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用的回溯算法</span></span><br><span class="line">    <span class="keyword">let</span> path=[] <span class="comment">// 保存每一条路径</span></span><br><span class="line">    <span class="keyword">let</span> res=[]  <span class="comment">// 保存所有路径</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span>=(<span class="params">root,path,res</span>)=&gt;&#123;</span><br><span class="line">        <span class="comment">// 先放入经过的节点</span></span><br><span class="line">        path.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">        <span class="comment">// 遇到叶子节点，就将路径推入结果</span></span><br><span class="line">        <span class="keyword">if</span>(!root.<span class="property">left</span>&amp;&amp;!root.<span class="property">right</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> temp=path</span><br><span class="line">            res.<span class="title function_">push</span>(temp.<span class="title function_">join</span>(<span class="string">&#x27;-&gt;&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 节点存在就遍历</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">left</span>)&#123;</span><br><span class="line">            <span class="title function_">dfs</span>(root.<span class="property">left</span>,path,res)</span><br><span class="line">            <span class="comment">// 遍历完后就实行回溯，吐出来遍历过的节点</span></span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">right</span>)&#123;</span><br><span class="line">            <span class="title function_">dfs</span>(root.<span class="property">right</span>,path,res)</span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>(root,path,res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 字符串作为参数传递,不符合引用数据类型的规则。即对传进来的值做修改后，不会影响原来的值。(正常情况下，引用数据类型在传递参数时，传的是地址，即形参实参指向同一地址，形参变化会导致实参也变化，但是string例外。)</span></span><br></pre></td></tr></table></figure><h3 id="10-左叶子之和"><a href="#10-左叶子之和" class="headerlink" title="10. 左叶子之和"></a>10. 左叶子之和</h3><p>404</p><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sumOfLeftLeaves = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span>=(<span class="params">root</span>)=&gt;&#123;</span><br><span class="line">        <span class="comment">// 确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="comment">// 在父节点处判断</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">left</span>&amp;&amp;!root.<span class="property">left</span>.<span class="property">left</span>&amp;&amp;!root.<span class="property">left</span>.<span class="property">right</span>)&#123;</span><br><span class="line">            sum+=root.<span class="property">left</span>.<span class="property">val</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">dfs</span>(root.<span class="property">left</span>,sum)</span><br><span class="line">        <span class="title function_">dfs</span>(root.<span class="property">right</span>,sum)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>(root)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="11-找树左下角的值"><a href="#11-找树左下角的值" class="headerlink" title="11. 找树左下角的值"></a>11. 找树左下角的值</h3><p>513</p><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广度优先搜索 层序遍历</span></span><br><span class="line"><span class="comment">//使用广度优先搜索遍历每一层的节点。在遍历一个节点时，需要先把它的非空右子节点放入队列，然后再把它的非空左子节点放入队列，这样才能保证从右到左遍历每一层的节点。广度优先搜索所遍历的最后一个节点的值就是最底层最左边节点的值。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ret=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> queue=[]</span><br><span class="line">    queue.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> curNode=queue.<span class="title function_">shift</span>()</span><br><span class="line">        curNode.<span class="property">right</span> &amp;&amp; queue.<span class="title function_">push</span>(curNode.<span class="property">right</span>)</span><br><span class="line">        curNode.<span class="property">left</span> &amp;&amp; queue.<span class="title function_">push</span>(curNode.<span class="property">left</span>)</span><br><span class="line">        ret=curNode.<span class="property">val</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 深度优先搜索 递归</span></span><br><span class="line"><span class="comment">// 递归版本：</span></span><br><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">//首先考虑递归遍历 前序遍历 找到最大深度的叶子节点即可</span></span><br><span class="line">    <span class="keyword">let</span> maxPath = <span class="number">0</span>,resNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 1. 确定递归函数的函数参数</span></span><br><span class="line">    <span class="keyword">const</span> dfsTree = <span class="keyword">function</span>(<span class="params">node,curPath</span>)&#123;</span><br><span class="line">    <span class="comment">// 2. 确定递归函数终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">left</span>===<span class="literal">null</span>&amp;&amp;node.<span class="property">right</span>===<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curPath&gt;maxPath)&#123;</span><br><span class="line">            maxPath = curPath;</span><br><span class="line">            resNode = node.<span class="property">val</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// return ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        node.<span class="property">left</span>&amp;&amp;<span class="title function_">dfsTree</span>(node.<span class="property">left</span>,curPath+<span class="number">1</span>);<span class="comment">// 这里其实有一个回溯的过程</span></span><br><span class="line">        node.<span class="property">right</span>&amp;&amp;<span class="title function_">dfsTree</span>(node.<span class="property">right</span>,curPath+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfsTree</span>(root,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> resNode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="12-路径总和"><a href="#12-路径总和" class="headerlink" title="12. 路径总和"></a>12. 路径总和</h3><p>112 </p><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">targetSum</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasPathSum = <span class="keyword">function</span>(<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">traversal</span>=(<span class="params">root,targetSum</span>)=&gt;&#123;</span><br><span class="line">        <span class="comment">// 遇到叶子节点，并且计数为0</span></span><br><span class="line">        <span class="keyword">if</span>(!root.<span class="property">left</span>&amp;&amp;!root.<span class="property">right</span>&amp;&amp;targetSum===<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  左（空节点不遍历）.若遇到叶子节点返回true，则直接返回true</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">left</span>&amp;&amp;<span class="title function_">traversal</span>(root.<span class="property">left</span>,targetSum-root.<span class="property">left</span>.<span class="property">val</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  右（空节点不遍历）.若遇到叶子节点返回true，则直接返回true</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">right</span>&amp;&amp;<span class="title function_">traversal</span>(root.<span class="property">right</span>,targetSum-root.<span class="property">right</span>.<span class="property">val</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">traversal</span>(root,targetSum-root.<span class="property">val</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="13-从中序与后序遍历序列构造二叉树"><a href="#13-从中序与后序遍历序列构造二叉树" class="headerlink" title="13. 从中序与后序遍历序列构造二叉树"></a>13. 从中序与后序遍历序列构造二叉树</h3><p>106</p><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p>前序和中序可以唯一确定一棵二叉树。</p><p>后序和中序可以唯一确定一棵二叉树。</p><p>那么前序和后序可不可以唯一确定一棵二叉树呢？</p><p><strong>前序和后序不能唯一确定一棵二叉树！</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">inorder</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">postorder</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="keyword">function</span>(<span class="params">inorder, postorder</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!inorder.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> rootVal = postorder.<span class="title function_">pop</span>(); <span class="comment">// 从后序遍历的数组中获取中间节点的值， 即数组最后一个值</span></span><br><span class="line">    <span class="keyword">let</span> rootIndex = inorder.<span class="title function_">indexOf</span>(rootVal); <span class="comment">// 获取中间节点在中序遍历中的下标</span></span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal); <span class="comment">// 创建中间节点</span></span><br><span class="line"></span><br><span class="line">    root.<span class="property">left</span> = <span class="title function_">buildTree</span>(inorder.<span class="title function_">slice</span>(<span class="number">0</span>, rootIndex), postorder.<span class="title function_">slice</span>(<span class="number">0</span>, rootIndex)); <span class="comment">// 创建左节点</span></span><br><span class="line">    root.<span class="property">right</span> = <span class="title function_">buildTree</span>(inorder.<span class="title function_">slice</span>(rootIndex + <span class="number">1</span>), postorder.<span class="title function_">slice</span>(rootIndex)); <span class="comment">// 创建右节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="14-最大二叉树"><a href="#14-最大二叉树" class="headerlink" title="14. 最大二叉树"></a>14. 最大二叉树</h3><p>654</p><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p><ol><li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li></ol><p>返回 <em><code>nums</code> 构建的</em> <strong><em>最大二叉树\</em></strong> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> constructMaximumBinaryTree = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 确定终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(!nums.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单层递归逻辑</span></span><br><span class="line">    <span class="keyword">let</span> maxval=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(item&gt;maxval)&#123;</span><br><span class="line">            maxval=item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> index=nums.<span class="title function_">indexOf</span>(maxval)</span><br><span class="line">    <span class="keyword">let</span> node=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxval) <span class="comment">// 中</span></span><br><span class="line">    <span class="keyword">let</span> leftArr=nums.<span class="title function_">slice</span>(<span class="number">0</span>,index) <span class="comment">// 左</span></span><br><span class="line">    <span class="keyword">let</span> rightArr=nums.<span class="title function_">slice</span>(index+<span class="number">1</span>) <span class="comment">// 右</span></span><br><span class="line">    </span><br><span class="line">    node.<span class="property">left</span>=<span class="title function_">constructMaximumBinaryTree</span>(leftArr)</span><br><span class="line">    node.<span class="property">right</span>=<span class="title function_">constructMaximumBinaryTree</span>(rightArr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="15-合并二叉树"><a href="#15-合并二叉树" class="headerlink" title="15. 合并二叉树"></a>15. 合并二叉树</h3><p>617</p><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p>解题思路：</p><p>两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。</p><p>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</p><p>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</p><p>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。</p><p>对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//  对树1进行改造 返回新的树1</span></span><br><span class="line"><span class="keyword">var</span> mergeTrees = <span class="keyword">function</span>(<span class="params">root1, root2</span>) &#123;</span><br><span class="line">    <span class="comment">// 未重叠部分</span></span><br><span class="line">    <span class="keyword">if</span>(!root1) <span class="keyword">return</span> root2</span><br><span class="line">    <span class="keyword">if</span>(!root2) <span class="keyword">return</span> root1</span><br><span class="line">    <span class="comment">// 重叠部分</span></span><br><span class="line">    root1.<span class="property">val</span>+=root2.<span class="property">val</span></span><br><span class="line">    root1.<span class="property">left</span>=<span class="title function_">mergeTrees</span>(root1.<span class="property">left</span>,root2.<span class="property">left</span>)</span><br><span class="line">    root1.<span class="property">right</span>=<span class="title function_">mergeTrees</span>(root1.<span class="property">right</span>,root2.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">return</span> root1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="16-二叉搜索树中的搜索"><a href="#16-二叉搜索树中的搜索" class="headerlink" title="16. 二叉搜索树中的搜索"></a>16. 二叉搜索树中的搜索</h3><p>700</p><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> searchBST = <span class="keyword">function</span> (<span class="params">root, val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || root.<span class="property">val</span> === val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">val</span> &gt; val)</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">searchBST</span>(root.<span class="property">left</span>, val);</span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">val</span> &lt; val)</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">searchBST</span>(root.<span class="property">right</span>, val);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="17-验证二叉搜索树"><a href="#17-验证二叉搜索树" class="headerlink" title="17. 验证二叉搜索树"></a>17. 验证二叉搜索树</h3><p>98</p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValidBST = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span>=(<span class="params">root</span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span></span><br><span class="line">        <span class="title function_">dfs</span>(root.<span class="property">left</span>)</span><br><span class="line">        res.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">        <span class="title function_">dfs</span>(root.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>(root)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;res.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(res[i]&lt;=res[i-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="18-二叉搜索树中的众树"><a href="#18-二叉搜索树中的众树" class="headerlink" title="18. 二叉搜索树中的众树"></a>18. 二叉搜索树中的众树</h3><p>501</p><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <a href="https://baike.baidu.com/item/众数/44796">众数</a>（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMode = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count=<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> maxCount=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> pre=<span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    <span class="comment">// 使用双指针的方法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">traversal</span>=(<span class="params">cur</span>)=&gt;&#123;</span><br><span class="line">        <span class="comment">// 确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(!cur) <span class="keyword">return</span> </span><br><span class="line">        <span class="comment">// 确定单层递归逻辑</span></span><br><span class="line">        <span class="title function_">traversal</span>(cur.<span class="property">left</span>)</span><br><span class="line">        <span class="keyword">if</span>(pre &amp;&amp; pre.<span class="property">val</span>==cur.<span class="property">val</span>)&#123;</span><br><span class="line">            count++ <span class="comment">// 前后指针一样计数加一</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            count=<span class="number">1</span> <span class="comment">// 新值置1</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre=cur</span><br><span class="line">        <span class="comment">// 如果计数等于最大计数，加入结果数组，但是这里的最大计数不知道是不是真的最大计数</span></span><br><span class="line">        <span class="keyword">if</span>(maxCount==count)&#123;    </span><br><span class="line">            res.<span class="title function_">push</span>(cur.<span class="property">val</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxCount&lt;count)&#123;</span><br><span class="line">            maxCount=count</span><br><span class="line">            res=[]  <span class="comment">// 若不是最大计数，res清空 重新记录</span></span><br><span class="line">            res.<span class="title function_">push</span>(cur.<span class="property">val</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">traversal</span>(cur.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">traversal</span>(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还一种简单的是 建立Map哈希表，键为数字，值为出现的次数</p><h3 id="19-二叉树的最近公共祖先"><a href="#19-二叉树的最近公共祖先" class="headerlink" title="19. 二叉树的最近公共祖先"></a>19. 二叉树的最近公共祖先</h3><p>236</p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>后序遍历从下往上搜索，类似于回溯</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">q</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="keyword">function</span>(<span class="params">root, p, q</span>) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用递归的方法</span></span><br><span class="line">    <span class="comment">// 需要从下到上，所以使用后序遍历</span></span><br><span class="line">    <span class="comment">// 1. 确定递归的函数</span></span><br><span class="line">    <span class="keyword">const</span> travelTree = <span class="keyword">function</span>(<span class="params">root,p,q</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. 确定递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root === <span class="literal">null</span> || root === p||root === q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 确定递归单层逻辑</span></span><br><span class="line">        <span class="keyword">let</span> left = <span class="title function_">travelTree</span>(root.<span class="property">left</span>,p,q);</span><br><span class="line">        <span class="keyword">let</span> right = <span class="title function_">travelTree</span>(root.<span class="property">right</span>,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left !== <span class="literal">null</span>&amp;&amp;right !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left ===<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span>  <span class="title function_">travelTree</span>(root,p,q);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="20-二叉搜索树的公共祖先"><a href="#20-二叉搜索树的公共祖先" class="headerlink" title="20. 二叉搜索树的公共祖先"></a>20. 二叉搜索树的公共祖先</h3><p>235</p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>只要一个结点在p和q的中间，就是最近公共祖先</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">q</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="keyword">function</span>(<span class="params">root, p, q</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ancestor=root</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ancestor.<span class="property">val</span>&gt;p.<span class="property">val</span> &amp;&amp; ancestor.<span class="property">val</span>&gt;q.<span class="property">val</span>)&#123;</span><br><span class="line">            ancestor=ancestor.<span class="property">left</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ancestor.<span class="property">val</span>&lt;p.<span class="property">val</span> &amp;&amp; ancestor.<span class="property">val</span>&lt;q.<span class="property">val</span>)&#123;</span><br><span class="line">            ancestor=ancestor.<span class="property">right</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ancestor</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="21-二叉搜索树中插入节点"><a href="#21-二叉搜索树中插入节点" class="headerlink" title="21.二叉搜索树中插入节点"></a>21.二叉搜索树中插入节点</h3><p>701</p><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p>思路:只要遍历二叉树，和节点值比较，若小往左子树，若大往右子树，节点不存在时就是插入的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @param &#123;number&#125; val</span><br><span class="line"> * @return &#123;TreeNode&#125;</span><br><span class="line"> */</span><br><span class="line">var insertIntoBST = function(root, val) &#123;</span><br><span class="line">    if(!root)&#123;</span><br><span class="line">        return new TreeNode(val)</span><br><span class="line">    &#125;</span><br><span class="line">    if(val&lt;root.val)&#123;</span><br><span class="line">       root.left= insertIntoBST(root.left,val)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">       root.right=insertIntoBST(root.right,val)</span><br><span class="line">    &#125;</span><br><span class="line">    return root</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="22-删除二叉搜索树中的节点"><a href="#22-删除二叉搜索树中的节点" class="headerlink" title="22. 删除二叉搜索树中的节点"></a>22. 删除二叉搜索树中的节点</h3><p>450</p><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p><strong>思路：</strong></p><p>节点可能不存在，返回null<br>可能为叶子节点，左孩子为空，右也为空 返回null<br>节点左孩子存在，右孩子为空  返回左孩子<br>节点右孩子为空，左孩子存在 返回右孩子<br>几点左右孩子都存在，就将节点左子树移到右子树最左下节点的左孩子位置 返回右孩子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="keyword">function</span>(<span class="params">root, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span>===key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root.<span class="property">left</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.<span class="property">right</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!root.<span class="property">right</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.<span class="property">left</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> cur=root.<span class="property">right</span></span><br><span class="line">            <span class="keyword">while</span>(cur.<span class="property">left</span>)&#123;</span><br><span class="line">                cur=cur.<span class="property">left</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur.<span class="property">left</span>=root.<span class="property">left</span></span><br><span class="line">            root=root.<span class="property">right</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span>&gt;key)&#123;</span><br><span class="line">        root.<span class="property">left</span>= <span class="title function_">deleteNode</span>(root.<span class="property">left</span>,key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span>&lt;key)&#123;</span><br><span class="line">        root.<span class="property">right</span>=<span class="title function_">deleteNode</span>(root.<span class="property">right</span>,key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="23-修剪二叉搜索树"><a href="#23-修剪二叉搜索树" class="headerlink" title="23. 修剪二叉搜索树"></a>23. 修剪二叉搜索树</h3><p>669</p><p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">low</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">high</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> trimBST = <span class="keyword">function</span>(<span class="params">root, low, high</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span>&lt;low)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">trimBST</span>(root.<span class="property">right</span>,low,high) <span class="comment">// 如果root（当前节点）的元素小于low的数值，那么应该递归右子树，并返回右子树符合条件的头结点。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span>&gt;high)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">trimBST</span>(root.<span class="property">left</span>,low,high) <span class="comment">// 同理</span></span><br><span class="line">    &#125;</span><br><span class="line">    root.<span class="property">left</span>=<span class="title function_">trimBST</span>(root.<span class="property">left</span>,low,high)</span><br><span class="line">    root.<span class="property">right</span>=<span class="title function_">trimBST</span>(root.<span class="property">right</span>,low,high)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="24-将有序数组转换为二叉搜索树"><a href="#24-将有序数组转换为二叉搜索树" class="headerlink" title="24. 将有序数组转换为二叉搜索树"></a>24. 将有序数组转换为二叉搜索树</h3><p>108</p><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><strong>本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedArrayToBST = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 确定递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="property">length</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span> </span><br><span class="line">    <span class="comment">// 确定单层递归逻辑</span></span><br><span class="line">    <span class="keyword">let</span> mid=<span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span>/<span class="number">2</span>) <span class="comment">// 找到中间值</span></span><br><span class="line">    <span class="keyword">let</span> node=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid])</span><br><span class="line">    node.<span class="property">left</span>=<span class="title function_">sortedArrayToBST</span>(nums.<span class="title function_">slice</span>(<span class="number">0</span>,mid))</span><br><span class="line">    node.<span class="property">right</span>=<span class="title function_">sortedArrayToBST</span>(nums.<span class="title function_">slice</span>(mid+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="25-把二叉搜索树转变为累加树"><a href="#25-把二叉搜索树转变为累加树" class="headerlink" title="25. 把二叉搜索树转变为累加树"></a>25. 把二叉搜索树转变为累加树</h3><p>538</p><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>解题思路：采用右中左遍历，然后用前后指针法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> convertBST = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre=<span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">bfs</span>=(<span class="params">root</span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span></span><br><span class="line">        <span class="title function_">bfs</span>(root.<span class="property">right</span>)</span><br><span class="line">        <span class="keyword">if</span>(pre)&#123;</span><br><span class="line">            root.<span class="property">val</span>+=pre.<span class="property">val</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pre=root</span><br><span class="line">        <span class="title function_">bfs</span>(root.<span class="property">left</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">bfs</span>(root)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十三 算法-stack和queue</title>
      <link href="/2023/04/03/13/"/>
      <url>/2023/04/03/13/</url>
      
        <content type="html"><![CDATA[<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="1-用栈实现队列"><a href="#1-用栈实现队列" class="headerlink" title="1. 用栈实现队列"></a>1. 用栈实现队列</h3><p>232</p><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p>使用栈来模式队列的行为，如果仅仅用一个栈，是一定不行的，所以需要两个栈<strong>一个输入栈，一个输出栈</strong>，这里要注意输入栈和输出栈的关系。</p><p>在push数据的时候，只要数据放进输入栈就好，但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyQueue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackIn</span>=[]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackOut</span>=[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> size=<span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span>(size)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">pop</span>()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="property">length</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="title function_">pop</span>())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">pop</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">peek</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x=<span class="variable language_">this</span>.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">push</span>(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="property">length</span> &amp;&amp; !<span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="property">length</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyQueue()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="2-用队列实现栈"><a href="#2-用队列实现栈" class="headerlink" title="2. 用队列实现栈"></a>2. 用队列实现栈</h3><p>225</p><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p>在此用一个队列来实现的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyStack</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">queue</span>=[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> size=<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span></span><br><span class="line">    <span class="keyword">while</span>(size--&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x=<span class="variable language_">this</span>.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyStack()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="3-有效的括号"><a href="#3-有效的括号" class="headerlink" title="3. 有效的括号"></a>3. 有效的括号</h3><p>20</p><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p>1.创建一个HashMap，把括号配对放进去。<br>2.创建一个stack（array），for循环遍历字符串，对于每一个字符，如果map里有这个key，那说明它是个左括号，从map里取得相对应的右括号（为什么？）把它push进stack里。否则的话，它就是右括号，需要pop出stack里的最上层字符然后看它是否等于当前的字符。如果不相符，则返回false。<br>3.循环结束后如果stack不为空，说明还剩一些左括号没有被闭合，返回false。否则返回true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> isValidMap=<span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    isValidMap.<span class="title function_">set</span>(<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">    isValidMap.<span class="title function_">set</span>(<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">    isValidMap.<span class="title function_">set</span>(<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> stack=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isValidMap.<span class="title function_">has</span>(item))&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(isValidMap.<span class="title function_">get</span>(item))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.<span class="title function_">pop</span>()!==item)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stack.<span class="property">length</span>!==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-删除字符串中的所有相邻重复项"><a href="#4-删除字符串中的所有相邻重复项" class="headerlink" title="4. 删除字符串中的所有相邻重复项"></a>4. 删除字符串中的所有相邻重复项</h3><p>1047</p><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>而消除一对相邻重复项可能会导致新的相邻重复项出现，如从字符串 abba\text{abba}abba 中删除 bb\text{bb}bb 会导致出现新的相邻重复项 aa\text{aa}aa 出现。因此我们需要保存当前还未被删除的字符。一种显而易见的数据结构呼之欲出：栈。我们只需要遍历该字符串，如果当前字符和栈顶字符相同，我们就贪心地将其消去，否则就将其入栈即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">let</span> c=<span class="literal">null</span></span><br><span class="line">        <span class="keyword">if</span>(stack.<span class="property">length</span> &amp;&amp; item===(c=stack.<span class="title function_">pop</span>()))&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        c&amp;&amp;stack.<span class="title function_">push</span>(c)</span><br><span class="line">        stack.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-逆波兰表达式求值"><a href="#5-逆波兰表达式求值" class="headerlink" title="5. 逆波兰表达式求值"></a>5. 逆波兰表达式求值</h3><p>150</p><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/逆波兰式/128437">逆波兰表示法</a> 表示的算术表达式。</p><p>请你计算该表达式。返回一个表示表达式值的整数。</p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul><li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li><li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + *</code>也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string[]</span>&#125; <span class="variable">tokens</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> evalRPN = <span class="keyword">function</span>(<span class="params">tokens</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> tokens)&#123;</span><br><span class="line">        <span class="keyword">if</span>(item===<span class="string">&#x27;+&#x27;</span>||item===<span class="string">&#x27;-&#x27;</span>||item===<span class="string">&#x27;*&#x27;</span>||item===<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> num2=stack.<span class="title function_">pop</span>()</span><br><span class="line">            <span class="keyword">let</span> num1=stack.<span class="title function_">pop</span>()</span><br><span class="line">            <span class="keyword">switch</span>(item)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stack.<span class="title function_">push</span>(num1 + num2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stack.<span class="title function_">push</span>(num1 - num2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    stack.<span class="title function_">push</span>(num1 * num2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    stack.<span class="title function_">push</span>(num1 / num2 &gt; <span class="number">0</span> ? <span class="title class_">Math</span>.<span class="title function_">floor</span>(num1 / num2) : <span class="title class_">Math</span>.<span class="title function_">ceil</span>(num1 / num2)); <span class="comment">//注意除法时正数向下取整，负数向上取整</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(<span class="built_in">parseInt</span>(item))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="title function_">pop</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-滑动窗口最大值"><a href="#6-滑动窗口最大值" class="headerlink" title="6. 滑动窗口最大值"></a>6. 滑动窗口最大值</h3><p>239 难</p><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设计单调队列的时候，pop，和push操作要保持如下规则：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</span></span><br><span class="line"><span class="comment">// push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-前k个高频元素"><a href="#7-前k个高频元素" class="headerlink" title="7. 前k个高频元素"></a>7. 前k个高频元素</h3><p>347</p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>这道题目主要涉及到如下三块内容：</p><ol><li>要统计元素出现频率</li><li><p>对频率排序</p></li><li><p>找出前K个高频元素</p></li></ol><p>首先统计元素出现的频率，这一类的问题可以使用map来进行统计。</p><p>然后是对频率进行排序，这里我们可以使用一种 容器适配器就是<strong>优先级队列</strong>。</p><p><strong>因为js中没有堆这种数据结构，如果有梦想的人，可以自己通过类去实现一个堆的结构，然后再去做本题目</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> topKFrequent = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> map=<span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        map.<span class="title function_">set</span>(item,(map.<span class="title function_">get</span>(item)||<span class="number">0</span>)+<span class="number">1</span>) <span class="comment">// 通过哈希表统计各个数字出现的次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [...map].<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>b[<span class="number">1</span>]-a[<span class="number">1</span>]).<span class="title function_">map</span>(<span class="function"><span class="params">item</span>=&gt;</span>item[<span class="number">0</span>]).<span class="title function_">slice</span>(<span class="number">0</span>,k) <span class="comment">// 找出前k个高频的元素</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十一 算法-List</title>
      <link href="/2023/03/15/11/"/>
      <url>/2023/03/15/11/</url>
      
        <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="1-移除链表元素"><a href="#1-移除链表元素" class="headerlink" title="1. 移除链表元素"></a>1. 移除链表元素</h3><p>203</p><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> </p><p>通过创建虚拟头结点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElements = <span class="keyword">function</span>(<span class="params">head, val</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dummy=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">    dummy.<span class="property">next</span>=head</span><br><span class="line">    <span class="keyword">let</span> cur=dummy</span><br><span class="line">    <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cur.<span class="property">next</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.<span class="property">next</span>.<span class="property">val</span>==val)&#123;</span><br><span class="line">            cur.<span class="property">next</span>=cur.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur=cur.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-设计链表"><a href="#2-设计链表" class="headerlink" title="2. 设计链表"></a>2. 设计链表</h3><p>707 难</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ListNode</span>(<span class="params">val, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = (val===<span class="literal">undefined</span> ? <span class="number">0</span> : val)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = (next===<span class="literal">undefined</span> ? <span class="literal">null</span> : next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-反转链表"><a href="#3-反转链表" class="headerlink" title="3. 反转链表"></a>3. 反转链表</h3><p>206</p><p>双指针：</p><p>首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。</p><p>然后就要开始反转了，首先要把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。</p><p>为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向了，将cur-&gt;next 指向pre ，此时已经反转了第一个节点了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pre=<span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> cur=head</span><br><span class="line">    <span class="keyword">let</span> temp</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        temp=cur.<span class="property">next</span></span><br><span class="line">        cur.<span class="property">next</span>=pre</span><br><span class="line">        pre=cur</span><br><span class="line">        cur=temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当cur为空的时候循环结束，不断将cur指向pre的过程。关键是初始化的地方，可能有的同学会不理解， 可以看到双指针法中初始化 cur = head，pre = NULL，在递归法中可以从如下代码看出初始化的逻辑也是一样的，只不过写法变了。具体可以看代码（已经详细注释），双指针法写出来之后，理解如下递归写法就不难了，代码逻辑都是一样的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reverse</span>(head,<span class="literal">null</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reverse</span>=(<span class="params">cur,pre</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(!cur)&#123;</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> temp=cur.<span class="property">next</span></span><br><span class="line">    cur.<span class="property">next</span>=pre</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reverse</span>(temp,cur)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-两两交换链表中的节点"><a href="#4-两两交换链表中的节点" class="headerlink" title="4. 两两交换链表中的节点"></a>4. 两两交换链表中的节点</h3><p>24</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>()</span><br><span class="line">  dummy.<span class="property">next</span> = head</span><br><span class="line">  <span class="keyword">let</span> current = dummy</span><br><span class="line">  <span class="keyword">while</span> (current.<span class="property">next</span> !== <span class="literal">null</span> &amp;&amp; current.<span class="property">next</span>.<span class="property">next</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n1 = current.<span class="property">next</span></span><br><span class="line">    <span class="keyword">let</span> n2 = current.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    n1.<span class="property">next</span> = n2.<span class="property">next</span></span><br><span class="line">    current.<span class="property">next</span> = n2</span><br><span class="line">    n2.<span class="property">next</span> = n1</span><br><span class="line">    current = n1</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dummy.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-删除链表中倒数第n个节点"><a href="#5-删除链表中倒数第n个节点" class="headerlink" title="5. 删除链表中倒数第n个节点"></a>5. 删除链表中倒数第n个节点</h3><p>19 </p><p>由于我们需要找到倒数第 nnn 个节点，因此我们可以使用两个指针 first和 second同时对链表进行遍历，并且 first比 second超前 nnn 个节点。当 first\textit{first}first 遍历到链表的末尾时，second就恰好处于倒数第 n 个节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span>(<span class="params">head, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dummy=<span class="keyword">new</span> <span class="title class_">ListNode</span>()</span><br><span class="line">    dummy.<span class="property">next</span>=head</span><br><span class="line">    <span class="keyword">let</span> p1=dummy</span><br><span class="line">    <span class="keyword">let</span> p2=dummy</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        p2=p2.<span class="property">next</span></span><br><span class="line">        n--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2.<span class="property">next</span>)&#123;</span><br><span class="line">        p1=p1.<span class="property">next</span></span><br><span class="line">        p2=p2.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    p1.<span class="property">next</span>=p1.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-环形链表II"><a href="#6-环形链表II" class="headerlink" title="6. 环形链表II"></a>6. 环形链表II</h3><p>142</p><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 <code>null</code>。</p><p>1.用哈希表</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> hash=<span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="keyword">while</span>(head!==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(head))&#123;</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line">        hash.<span class="title function_">add</span>(head)</span><br><span class="line">        head=head.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十二 算法-String</title>
      <link href="/2023/03/15/12/"/>
      <url>/2023/03/15/12/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="1-反转字符串"><a href="#1-反转字符串" class="headerlink" title="1. 反转字符串"></a>1. 反转字符串</h3><p>344</p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong><a href="https://baike.baidu.com/item/原地算法">原地</a>修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">character[]</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseString = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n=s.<span class="property">length</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> T=s[i]</span><br><span class="line">        s[i]=s[n-<span class="number">1</span>-i]</span><br><span class="line">        s[n-<span class="number">1</span>-i]=T</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-反转字符串II"><a href="#2-反转字符串II" class="headerlink" title="2. 反转字符串II"></a>2. 反转字符串II</h3><p>541</p><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseStr = <span class="keyword">function</span>(<span class="params">s, k</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> n = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">        <span class="title function_">reverse</span>(arr, i, <span class="title class_">Math</span>.<span class="title function_">min</span>(i + k, n) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reverse</span> = (<span class="params">arr, left, right</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-反转字符串中的单词"><a href="#3-反转字符串中的单词" class="headerlink" title="3. 反转字符串中的单词"></a>3. 反转字符串中的单词</h3><p>151</p><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="regexp">/\s+/</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 很多语言对字符串提供了 split（拆分），reverse（翻转）和 join（连接）等方法，因此我们可以简单的调用内置的 API 完成操作：</span></span><br></pre></td></tr></table></figure><p>另一种方法</p><p>所以解题思路如下：</p><ul><li>移除多余空格</li><li>将整个字符串反转</li><li>将每个单词反转</li></ul><p>难点在于去空格，我们采用双指针的方法，快指针遍历所有的字符串数组，如果遍历到单词，赋值给慢指针。同时注意去重空格</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">var</span> reverseWords = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">   <span class="comment">// 字符串转数组</span></span><br><span class="line">   <span class="keyword">const</span> strArr = <span class="title class_">Array</span>.<span class="title function_">from</span>(s);</span><br><span class="line">   <span class="comment">// 移除多余空格</span></span><br><span class="line">   <span class="title function_">removeExtraSpaces</span>(strArr);</span><br><span class="line">   <span class="comment">// 翻转</span></span><br><span class="line">   <span class="title function_">reverse</span>(strArr, <span class="number">0</span>, strArr.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= strArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (strArr[i] === <span class="string">&#x27; &#x27;</span> || i === strArr.<span class="property">length</span>) &#123;</span><br><span class="line">       <span class="comment">// 翻转单词</span></span><br><span class="line">       <span class="title function_">reverse</span>(strArr, start, i - <span class="number">1</span>);</span><br><span class="line">       start = i + <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> strArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除多余空格</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeExtraSpaces</span>(<span class="params">strArr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> fastIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(fastIndex &lt; strArr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="comment">// 移除开始位置和重复的空格</span></span><br><span class="line">    <span class="keyword">if</span> (strArr[fastIndex] === <span class="string">&#x27; &#x27;</span> &amp;&amp; (fastIndex === <span class="number">0</span> || strArr[fastIndex - <span class="number">1</span>] === <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">      fastIndex++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      strArr[slowIndex++] = strArr[fastIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除末尾空格</span></span><br><span class="line">  strArr.<span class="property">length</span> = strArr[slowIndex - <span class="number">1</span>] === <span class="string">&#x27; &#x27;</span> ? slowIndex - <span class="number">1</span> : slowIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转从 start 到 end 的字符</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">strArr, start, end</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = start;</span><br><span class="line">  <span class="keyword">let</span> right = end;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">    [strArr[left], strArr[right]] = [strArr[right], strArr[left]];</span><br><span class="line">    left++;</span><br><span class="line">    right--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十 算法-Array</title>
      <link href="/2023/03/02/10/"/>
      <url>/2023/03/02/10/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-二分法"><a href="#1-二分法" class="headerlink" title="1. 二分法"></a>1. 二分法</h3><p>704</p><p>这道题目的前提是数组为有序数组，同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n=nums.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>, right=n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid=<span class="title class_">Math</span>.<span class="title function_">floor</span>(left+ (right-left)/<span class="number">2</span>) <span class="comment">// let mid = (l + r) &gt;&gt; 1; 等价于二进制数往右移一位</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid-<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-移除元素"><a href="#2-移除元素" class="headerlink" title="2. 移除元素"></a>2. 移除元素</h3><p>27</p><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 原地 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并原地修改输入数组。</p><p>有的同学可能说了，<strong>多余的元素</strong>，删掉不就得了。</p><p><strong>要知道数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> k=<span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=val)&#123;</span><br><span class="line">            nums[k]=nums[i]</span><br><span class="line">            k++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k <span class="comment">// 快指针是i，慢指针是k</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</span></span><br><span class="line"><span class="comment">// 定义快慢指针</span></span><br><span class="line"><span class="comment">// 快指针：寻找新数组的元素(寻找过程遍历所有元素)，而新数组就是不含有目标元素的数组</span></span><br><span class="line"><span class="comment">// 慢指针：指向更新新数组下标的位置</span></span><br></pre></td></tr></table></figure><h3 id="3-有序数组的平方"><a href="#3-有序数组的平方" class="headerlink" title="3. 有序数组的平方"></a>3. 有序数组的平方</h3><p>977</p><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p>办法 （1）每个数平方之后，排个序，美滋滋，(2) 使用双指针：数组其实是有序的， 只不过负数平方之后可能成为最大数了。那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入：nums = [-4,-1,0,3,10]</span></span><br><span class="line"><span class="comment">// 输出：[0,1,9,16,100]</span></span><br><span class="line"><span class="comment">// 解释：平方后，数组变为 [16,1,0,9,100]</span></span><br><span class="line"><span class="comment">// 排序后，数组变为 [0,1,9,16,100]</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedSquares = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n=nums.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> result=<span class="keyword">new</span> <span class="title class_">Array</span>(n)</span><br><span class="line">    <span class="keyword">let</span> k=n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,j=n-<span class="number">1</span>;i&lt;=j;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(nums[i],<span class="number">2</span>)&gt;<span class="title class_">Math</span>.<span class="title function_">pow</span>(nums[j],<span class="number">2</span>))&#123;</span><br><span class="line">            result[k--]=<span class="title class_">Math</span>.<span class="title function_">pow</span>(nums[i++],<span class="number">2</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result[k--]=<span class="title class_">Math</span>.<span class="title function_">pow</span>(nums[j--],<span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-长度最小的子数组-滑动窗口"><a href="#4-长度最小的子数组-滑动窗口" class="headerlink" title="4. 长度最小的子数组|滑动窗口"></a>4. 长度最小的子数组|滑动窗口</h3><p>209</p><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p>解法一：暴力解法，这道题目暴力解法当然是 两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是O(n^2)。</p><p>解法二：滑动窗口，所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。可以发现滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="keyword">function</span>(<span class="params">target, nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result=<span class="title class_">Infinity</span> <span class="comment">// 最终结果的长度</span></span><br><span class="line">    <span class="keyword">let</span> subLength=<span class="number">0</span> <span class="comment">// 子序列的长度</span></span><br><span class="line">    <span class="keyword">let</span> sum=<span class="number">0</span> <span class="comment">// 子序列之和</span></span><br><span class="line">    <span class="keyword">let</span> s=<span class="number">0</span> <span class="comment">// 开始的指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> e=<span class="number">0</span>;e&lt;nums.<span class="property">length</span>;e++)&#123;<span class="comment">// e结束的指针</span></span><br><span class="line">        sum+=nums[e]</span><br><span class="line">        <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">            subLength=e-s+<span class="number">1</span></span><br><span class="line">            result=<span class="title class_">Math</span>.<span class="title function_">min</span>(result,subLength)</span><br><span class="line">            sum-=nums[s++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result==<span class="title class_">Infinity</span>?<span class="number">0</span>:result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-螺旋矩阵II"><a href="#5-螺旋矩阵II" class="headerlink" title="5. 螺旋矩阵II"></a>5. 螺旋矩阵II</h3><p>59  54</p><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p>二维数组创建方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(n), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n))</span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(n))</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generateMatrix = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [[<span class="number">1</span>]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>, right=n-<span class="number">1</span>, top=<span class="number">0</span>, bottom=n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> direction=<span class="string">&#x27;right&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(n), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n))</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right&amp;&amp;top&lt;=bottom)&#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="string">&#x27;right&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j=left;j&lt;=right;j++)&#123;</span><br><span class="line">                result[top][j]=i</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">            top++</span><br><span class="line">            direction=<span class="string">&#x27;down&#x27;</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(direction==<span class="string">&#x27;down&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j=top;j&lt;=bottom;j++)&#123;</span><br><span class="line">                result[j][right]=i</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">            right--</span><br><span class="line">            direction=<span class="string">&#x27;left&#x27;</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(direction==<span class="string">&#x27;left&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">let</span> j=right;j&gt;=left;j--)&#123;</span><br><span class="line">                result[bottom][j]=i</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--</span><br><span class="line">            direction=<span class="string">&#x27;top&#x27;</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(direction==<span class="string">&#x27;top&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j=bottom;j&gt;=top;j--)&#123;</span><br><span class="line">                result[j][left]=i</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">            direction=<span class="string">&#x27;right&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九 React interview-questions</title>
      <link href="/2023/02/14/9/"/>
      <url>/2023/02/14/9/</url>
      
        <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="1-对react的理解？有哪些特性？优势？-和vue的区别"><a href="#1-对react的理解？有哪些特性？优势？-和vue的区别" class="headerlink" title="1. 对react的理解？有哪些特性？优势？ 和vue的区别"></a>1. 对react的理解？有哪些特性？优势？ 和vue的区别</h2><p>React是一个简单的javascript UI库，用于构建高效、快速的用户界面。它是一个轻量级库，因此很受欢迎。它遵循组件设计模式、<strong><em>声明式编程范式</em></strong>和<strong><em>函数式编程</em></strong>概念，以使前端应用程序更高效。它使用虚拟DOM来有效地操作DOM。它遵循从父组件到子组件的单向数据流。</p><p>特点：</p><ul><li>JSX 语法</li><li>单向数据绑定</li><li>虚拟 DOM</li><li>声明式编程</li><li>组件</li></ul><p>优势：</p><p>通过上面的初步了解，可以感受到 <code>React</code> 存在的优势：</p><ul><li>高效灵活</li><li>声明式的设计，简单使用</li><li>组件式开发，提高代码复用率</li><li>单向响应的数据流会比双向绑定的更安全，速度更快</li></ul><p>react采用单向数据绑定，推崇结合immutable来实现数据不可变;vue思想是 响应式的，双向数据绑定</p><p>vue 采用了template， react采用了jsx</p><p>很多人认为 React 是 MVC 中的 V（视图），vue采用的是mvvm架构模式</p><h2 id="2-说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？"><a href="#2-说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？" class="headerlink" title="2. 说说 Real DOM 和 Virtual DOM 的区别？优缺点？"></a>2. 说说 Real DOM 和 Virtual DOM 的区别？优缺点？</h2><p>是什么？</p><p>Real DOM，真实 <code>DOM</code>，意思为文档对象模型，是一个结构化文本的抽象，在页面渲染出的每一个结点都是一个真实 <code>DOM</code> 结构。</p><p><code>Virtual Dom</code>，本质上是以 <code>JavaScript</code> 对象形式存在的对 <code>DOM</code> 的描述。</p><p>创建虚拟 <code>DOM</code> 目的就是为了更好将虚拟的节点渲染到页面视图中，虚拟 <code>DOM</code> 对象的节点与真实 <code>DOM</code> 的属性一一照应。</p><p>两者的区别如下：</p><ul><li>虚拟 DOM 不会进行排版与重绘操作，而真实 DOM 会频繁重排与重绘</li><li>虚拟 DOM 的总损耗是“虚拟 DOM 增删改+真实 DOM 差异增删改+排版与重绘”，真实 DOM 的总损耗是“真实 DOM 完全增删改+排版与重绘”</li></ul><p><strong>优缺点：</strong></p><p>真实 <code>DOM</code> 的优势：</p><ul><li>易用</li></ul><p>缺点：</p><ul><li>效率低，解析速度慢，内存占用量过高</li><li>性能差：频繁操作真实 DOM，易于导致重绘与回流</li></ul><p>使用虚拟 <code>DOM</code> 的优势如下：</p><ul><li>简单方便：如果使用手动操作真实 <code>DOM</code> 来完成页面，繁琐又容易出错。</li><li>性能方面：使用 Virtual DOM，能够有效避免真实 DOM 数频繁更新，减少多次引起重绘与回流，提高性能</li><li>跨平台：React 借助虚拟 DOM，带来了跨平台的能力，一套代码多端运行（将真实DOM映射为JavaScript对象，可以使代码不仅仅局限于对浏览器DOM的操作，只要支持JavaScript即可使用。）</li><li>防范xss攻击</li></ul><p>缺点：</p><ul><li>在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化</li><li>首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，速度比正常稍慢</li></ul><h2 id="3-react中的diff算法"><a href="#3-react中的diff算法" class="headerlink" title="3. react中的diff算法"></a>3. react中的diff算法</h2><p>React 的 diff 策略，将 将传统的复杂度为O(n3) 的问题转换成复杂度为 O(n) 的问题</p><p>diff策略分为三个层级</p><p><strong>tree diff</strong></p><p>只会对树相同层级的节点进行比较。只有删除、创建的操作</p><p><strong>component diff</strong></p><p>如果是同一类型的组件，则会继续往下diff运算。</p><p>不同类型的组件，则将该组件判断为 dirty component，删除组件和其所有子节点。</p><p><strong>element diff</strong></p><p>当节点处于同一层级时，每个节点在对应的层级用唯一的<code>key</code>作为标识。react diff提供了三种结点操作，分别为：<strong>INSERT_MARKUP</strong>（插入）、<strong>MOVE_EXISTING</strong>（移动）和 <strong>REMOVE_NODE</strong>（删除）。</p><p>面对全新的节点时，执行<strong>插入操作</strong>, 面对多余的节点时，执行<strong>删除操作</strong>, 面对换位的节点时，执行<strong>移动操作</strong></p><p>移动的<strong>细节：</strong></p><p>新旧节点会遍历后对比下标，新的下标称为lastIndex，旧的称为index，如果lastIndex大于index，需要将节点旧的节点移动到新的位置，相反则位置不变，index的值赋给lastIndex(lastIndex=index)。<br>如果没有找到对应位置节点，则执行新增； 如果旧的节点在新的节点组用不到，则执行删除；一般是在最后做删除操作。</p><p><strong>经典面试题:</strong><br>      1). react/vue中的key有什么作用？（key的内部原理是什么？）<br>      2). 为什么遍历列表时，key最好不要用index?</p><pre><code>  1. 虚拟DOM中key的作用：      1). 简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。      2). 详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】,                     随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：      ​        a. 旧虚拟DOM中找到了与新虚拟DOM相同的key：      ​              (1).若虚拟DOM中内容没变, 直接使用之前的真实DOM      ​              (2).若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM      ​        b. 旧虚拟DOM中未找到与新虚拟DOM相同的key      ​              根据数据创建新的真实DOM，随后渲染到到页面      ​                2. 用index作为key可能会引发的问题：                  1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:                     会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。                        2. 如果结构中还包含输入类的DOM：                    会产生错误DOM更新 ==&gt; 界面有问题。                        3. 注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，                              仅用于渲染列表用于展示，使用index作为key是没有问题的。        3. 开发中如何选择key?:                  1. 最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。                  2. 如果确定只是简单的展示数据，用index也是可以的。</code></pre><h2 id="4-生命周期"><a href="#4-生命周期" class="headerlink" title="4. 生命周期"></a>4. 生命周期</h2><p>可以分成三个阶段：</p><ul><li>创建阶段</li><li>更新阶段</li><li>卸载阶段</li></ul><p><strong>创建阶段</strong></p><p>创建阶段主要分成了以下几个生命周期方法：</p><ul><li>constructor</li><li>getDerivedStateFromProps</li><li>render</li><li>componentDidMount</li></ul><p><strong>更新阶段</strong></p><p>该阶段的函数主要为如下方法：</p><ul><li>getDerivedStateFromProps  当state需要从props初始化时，使用</li><li>shouldComponentUpdate </li><li>render</li><li>getSnapshotBeforeUpdate  查看更新前 state 对象的值</li><li>componentDidUpdate</li></ul><p><strong>卸载阶段</strong></p><p>componentWillUnmount</p><p>此方法用于组件卸载前，清理一些定时器，或者取消订阅的网络请求等</p><p>一旦一个组件实例被卸载，其不会被再次挂载，而只可能是被重新创建</p><!-- <img src="img/react生命周期(新).png" alt="react生命周期(新)" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/react生命周期(新).png" alt="react生命周期(新)" style="width:80%;"/></div><span class="image-caption">react生命周期(新)</span></div><h2 id="5-state-和-props-有什么区别？"><a href="#5-state-和-props-有什么区别？" class="headerlink" title="5. state 和 props 有什么区别？"></a>5. state 和 props 有什么区别？</h2><p>一个组件的显示形态可以由数据状态和外部参数所决定，而数据状态就是 <code>state</code>，外部参数就是props</p><p>区别</p><p><strong>相同点</strong>：</p><ul><li>两者都是 JavaScript 对象</li><li>两者都是用于保存信息</li><li>props 和 state 都能触发渲染更新</li></ul><p><strong>不同点</strong>：</p><ul><li>props 是外部传递给组件的，而 state 是在组件内被组件自己管理的，一般在 constructor 中初始化</li><li>props 在组件内部是不可修改的，但 state 在组件内部可以进行修改</li><li>state 是多变的、可以修改</li></ul><h2 id="6-调用setState-useState发生异步吗？"><a href="#6-调用setState-useState发生异步吗？" class="headerlink" title="6. 调用setState/useState发生异步吗？"></a>6. 调用setState/useState发生异步吗？</h2><p>会</p><p>为了提高性能React将setState设置为批次更新，即是异步操作函数，将 setState() 视为请求而不是立即更新组件的命令。为了更好的感知性能，React 会延迟调用它，然后通过一次传递更新多个组件。React 并不会保证 state 的变更会立即生效。setState() 并不总是立即更新组件。它会批量推迟更新。这使得在调用 setState() 后立即读取 this.state 成为了隐患</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line"></span><br><span class="line">       <span class="attr">count</span>:<span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line"></span><br><span class="line">       <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>);<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加载完成&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>useState</p><p>useState 返回的更新对象的方法是异步的，要在下次重绘才能获取新值，不要试图在更改状态之后立即获取状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一 不确定是否有效</span></span><br><span class="line"><span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_">setData</span>(<span class="function">(<span class="params">prev</span>) =&gt;</span> prev + <span class="number">1</span>); <span class="comment">// prev 是data 改变之前的值，return 返回的值会作为新状态覆盖data</span></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="comment">//先使用 useRef 进行存储数据，再使用 useEffect 监听数据变化，并进行更新。</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Index</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> [info, setInfo] = <span class="title function_">useState</span>()</span><br><span class="line"><span class="keyword">const</span> infoRef = <span class="title function_">useRef</span>()</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">infoRef.<span class="property">current</span> = info</span><br><span class="line">&#125;, [info])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在之后需要使用 info 数据的地方只需要获取 infoRef.current 即可获取最新的 info 数据内容。</span></span><br></pre></td></tr></table></figure><h2 id="7-react事件机制"><a href="#7-react事件机制" class="headerlink" title="7. react事件机制"></a>7. react事件机制</h2><p>react自身实现了一套事件机制叫合成事件。合成事件是 <code>React</code>模拟原生 <code>DOM</code>事件所有能力的一个事件对象。</p><p>总结：</p><p>React 16上注册的事件最终会绑定在<strong>document</strong>这个 DOM 上，而不是 React 组件对应的 DOM</p><p>React17注册的事件绑定<strong>容器结点</strong>，比如root</p><p>如果想要获得原生<code>DOM</code>事件，可以通过<code>e.nativeEvent</code>属性获取</p><p>React 自身实现了一套事件冒泡机制，阻止合成事件向上的冒泡，用e.stopPropagation()。阻止合成事件本级间的冒泡以及向上冒泡，用e.nativeEvent.stopImmediatePropagation()</p><p>react16事件执行顺序。先执行原生事件，再执行react事件。原生捕获-&gt;原生冒泡-&gt;react捕获-&gt;react冒泡</p><p>react17事件执行顺序。react捕获-&gt;原生捕获-&gt;原生冒泡-&gt;react冒泡</p><h2 id="8-react构建组件的方式"><a href="#8-react构建组件的方式" class="headerlink" title="8. react构建组件的方式"></a>8. react构建组件的方式</h2><ul><li>函数式创建</li><li>通过 React.createClass 方法创建</li><li>继承 React.Component 创建</li></ul><p>在<code>React Hooks</code>出来之前，函数式组件可以视为无状态组件，只负责根据传入的<code>props</code>来展示视图，不涉及对<code>state</code>状态的操作。</p><p><code>React.createClass</code>是react刚开始推荐的创建组件的方式，目前这种创建方式已经不怎么用了</p><p>同样在<code>react hooks</code>出来之前，有状态的组件只能通过继承<code>React.Component</code>这种形式进行创建</p><p>有状态的组件也就是组件内部存在维护的数据，在类创建的方式中通过<code>this.state</code>进行访问</p><p>当调用<code>this.setState</code>修改组件的状态时，组价会再次会调用<code>render()</code>方法进行重新渲染</p><h2 id="9-React-refs的理解？"><a href="#9-React-refs的理解？" class="headerlink" title="9. React refs的理解？"></a>9. React refs的理解？</h2><p>ref 一种访问<code>DOM</code>节点的方式。</p><ol><li>字符串形式的ref</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p ref=<span class="string">&#x27;wenben&#x27;</span>&gt;文本&lt;/p&gt;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">wenben</span>)</span><br><span class="line"><span class="comment">// 已经过时了</span></span><br></pre></td></tr></table></figure><ol><li><code>React.createRef()</code>创建</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">myRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> node = <span class="variable language_">this</span>.<span class="property">myRef</span>.<span class="property">current</span>;</span><br></pre></td></tr></table></figure><ol><li>useRef中的hooks</li></ol><p><em>保存一个值,在整个生命周期中维持不变</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> myref = <span class="title function_">useRef</span>()</span><br><span class="line">  <span class="keyword">const</span> node = myref.<span class="property">current</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;myref&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-类组件和函数式组件的区别？"><a href="#10-类组件和函数式组件的区别？" class="headerlink" title="10. 类组件和函数式组件的区别？"></a>10. 类组件和函数式组件的区别？</h2><p>类组件，顾名思义，也就是通过使用<code>ES6</code>类的编写形式去编写组件，该类必须继承<code>React.Component</code></p><p>如果想要访问父组件传递过来的参数，可通过<code>this.props</code>的方式去访问</p><p>在组件中必须实现<code>render</code>方法，在<code>return</code>中返回<code>React</code>对象</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;hello 2005&#x27;</span>,</span><br><span class="line">        <span class="attr">count</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数式组件：就是通过函数编写的形式去实现一个<code>React</code>组件，是<code>React</code>中定义组件最简单的方式</p><p>函数第一个参数为<code>props</code>用于接收父组件传递过来的参数</p><p>区别：</p><p>函数组件语法更短、更简单，这使得它更容易开发、理解和测试</p><p>而类组件也会因大量使用 <code>this</code>而让人感到困惑</p><h2 id="11-受控组件与非受控组件"><a href="#11-受控组件与非受控组件" class="headerlink" title="11. 受控组件与非受控组件"></a>11. 受控组件与非受控组件</h2><p>受控组件的状态全程响应外部数据的变化，给input提供onchange事件，一旦检测到文本框内容有变化，马上执行onchange事件获取表单的内容。</p><p>非受控组件将真实数据存在 DOM 节点中,通过ref来获取。,ref属性接受一个回调函数，返回一个element节点 ， 通过节点获取到数据 ref={(element)=&gt;this.addressElement = element }</p><h2 id="12-高阶组件"><a href="#12-高阶组件" class="headerlink" title="12. 高阶组件"></a>12. 高阶组件</h2><p>高阶组件是一个函数：即接受一个或多个组件作为参数并且返回一个组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (<span class="title class_">WrappedComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">EnhancedComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对传入的原始组件 <code>WrappedComponent</code> 做一些你想要的操作（比如操作 props，提取 state，给原始组件包裹其他元素等），从而加工出想要的组件 <code>EnhancedComponent</code></p><p>好处：高阶组件能够提高代码的复用性</p><h2 id="13-引入css的方式有哪几种？"><a href="#13-引入css的方式有哪几种？" class="headerlink" title="13. 引入css的方式有哪几种？"></a>13. 引入css的方式有哪几种？</h2><ul><li>在组件内直接使用</li><li>组件中引入 .css 文件</li><li>组件中引入 .module.css 文件</li><li>CSS in JS</li></ul><p>区别</p><ul><li>在组件内直接使用<code>css</code>该方式编写方便，容易能够根据状态修改样式属性，但是大量的演示编写容易导致代码混乱</li><li>组件中引入 .css 文件符合我们日常的编写习惯，但是作用域是全局的，样式之间会层叠（<strong>样式污染</strong>）</li><li>引入.module.css 文件能够解决局部作用域问题。</li><li>通过css in js 这种方法，可以满足大部分场景的应用，可以类似于预处理器一样样式嵌套、定义、修改状态等</li></ul><p>至于使用<code>react</code>用哪种方案引入<code>css</code>，并没有一个绝对的答案，可以根据各自情况选择合适的方案</p><h2 id="14-react组件间过度动画如何实现？"><a href="#14-react组件间过度动画如何实现？" class="headerlink" title="14. react组件间过度动画如何实现？"></a>14. react组件间过度动画如何实现？</h2><p>在日常开发中，页面切换时的转场动画是比较基础的一个场景，当一个组件在显示与消失过程中存在过渡动画，可以很好的增加用户的体验。在<code>react</code>中实现过渡动画效果会有很多种选择，如<code>react-transition-group</code>，<code>react-motion</code>，<code>Animated</code>，以及原生的<code>CSS</code>都能完成切换动画</p><p>在<code>react</code>中，<code>react-transition-group</code>是一种很好的解决方案，其可以导出3个组件：</p><ul><li><p>CSSTransition：在前端开发中，结合 CSS 来完成过渡动画效果</p></li><li><p>SwitchTransition：两个组件显示和隐藏切换时，使用该组件</p></li><li>TransitionGroup：将多个动画组件包裹在其中，一般用于列表中元素的动画</li></ul><h2 id="15-redux的工作原理"><a href="#15-redux的工作原理" class="headerlink" title="15. redux的工作原理"></a>15. redux的工作原理</h2><p>redux可以对react组件做全局的状态管理。</p><p>三大原则</p><ul><li>单一数据源</li><li>state 是只读的</li><li>使用纯函数来执行修改</li></ul><p>三大核心 store，action，reducer </p><p>store:数据state都放在 <code>store</code>中统一管理 （将state、action、reducer<strong>联系在一起的对象</strong>）</p><p>reducer: 是个纯函数，根据传入的action，去返回新的state更新store中的数据</p><p>action：UI每一次状态的改变都会产生一个action</p><p>简易执行流程：组件的状态存放在store中，UI状态改变生成一个action，reducer接受到action然后进行处理产生新的state, 放到了store中，UI又从store中取得新状态。</p><p>API</p><ul><li>createStore可以帮助创建 store</li><li>store.dispatch 帮助派发 action , action 会传递给 store</li><li>store.getState 这个方法可以帮助获取 store 里边所有的数据内容</li><li>store.subscrible 方法订阅 store 的改变，只要 store 发生改变， store.subscrible 这个函数接收的这个回调函数就会被执行</li></ul><!-- <img src="img/image-20230309144100753.png" alt="image-20230309144100753" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230309144100753.png" style="width:80%;"/></div></div><h2 id="16-redux中间件"><a href="#16-redux中间件" class="headerlink" title="16. redux中间件"></a>16. redux中间件</h2><p>那么如果需要支持异步操作，或者支持错误处理、日志监控，这个过程需要用上中间件</p><p>其本质上一个函数，对<code>store.dispatch</code>方法进行了改造，在发出 <code>Action</code>和执行 <code>Reducer</code>这两步之间，添加了其他功能。</p><ul><li>redux-thunk：用于异步操作</li><li>redux-logger：用于日志记录</li></ul><p>上述的中间件都需要通过<code>applyMiddlewares</code>进行注册，作用是将所有的中间件组成一个数组，依次执行</p><p>然后作为第二个参数传入到<code>createStore</code>中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(</span><br><span class="line">  reducer,</span><br><span class="line">  <span class="title function_">applyMiddleware</span>(thunk, logger)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 异步逻辑</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getHomeMultidataAction</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch，getState</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;http://xxx.xx.xx.xx/test&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = res.<span class="property">data</span>.<span class="property">data</span>;</span><br><span class="line">      <span class="title function_">dispatch</span>(<span class="title function_">changeBannersAction</span>(data.<span class="property">banner</span>.<span class="property">list</span>));</span><br><span class="line">      <span class="title function_">dispatch</span>(<span class="title function_">changeRecommendsAction</span>(data.<span class="property">recommend</span>.<span class="property">list</span>));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-说说你对React-Router的理解？"><a href="#17-说说你对React-Router的理解？" class="headerlink" title="17. 说说你对React Router的理解？"></a>17. 说说你对React Router的理解？</h2><p>可以实现无刷新的条件下切换显示不同的页面。路由的本质就是页面的<code>URL</code>发生改变时，页面的显示结果可以根据<code>URL</code>的变化而变化，但是页面不会刷新。因此，可以通过前端路由可以实现单页(SPA)应用</p><p>组件：</p><p><BrowserRouter> <HashRouter></p><p><Routes/> 与 <Route/></p><p><Link> <NavLink></p><Navigate><Outlet><p>Hooks</p><p>useRoutes() 使用路由表</p><p>useNavigate() 作用：返回一个函数用来实现编程式导航。</p><p>useParams() 返回当前匹配路由的<code>params</code>参数，类似于5.x中的<code>match.params</code>。</p><p>useSearchParams() 用于读取和修改当前位置的 URL 中的查询字符串。返回一个包含两个值的数组，内容分别为：当前的seaech参数、更新search的函数。</p><p>useLocation() 获取当前 location 信息</p><h2 id="18-React-Router的模式是什么"><a href="#18-React-Router的模式是什么" class="headerlink" title="18. React Router的模式是什么"></a>18. React Router的模式是什么</h2><p>hash 模式  对应HashRouter组件</p><p>history 模式 对应BrowserRouter组件</p><h2 id="19-immutable-的理解？如何应用在react项目中？"><a href="#19-immutable-的理解？如何应用在react项目中？" class="headerlink" title="19. immutable 的理解？如何应用在react项目中？"></a>19. immutable 的理解？如何应用在react项目中？</h2><p>不可改变的，在计算机中，即指一旦创建，就不能再被更改的数据。</p><p><code>Immutable</code> 实现的原理是 <code>Persistent Data Structure</code>（持久化数据结构）:</p><p>也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免深拷贝把所有的节点都复制一遍带来的性能损耗，immutable使用了结构共享，<strong>即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其他节点则进行共享</strong></p><!-- <img src="img/2b4c801a7b40eefcd4ee6767fb984fdf_720w.gif" alt="img" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/2b4c801a7b40eefcd4ee6767fb984fdf_720w.gif" style="width:80%;"/></div></div><p>使用<code>Immutable</code>对象最主要的库是<code>immutable.js</code></p><p><strong>react中的应用</strong></p><p>使用 <code>Immutable</code>可以给 <code>React</code> 应用带来性能的优化，主要体现在减少渲染的次数。</p><p>在做<code>react</code>性能优化的时候，为了避免重复渲染，我们会在<code>shouldComponentUpdate()</code>中做对比，当返回<code>true</code>执行<code>render</code>方法</p><p><code>Immutable</code>通过<code>is</code>方法则可以完成对比，而无需像一样通过深度比较的方式比较</p><p>在使用<code>redux</code>过程中也可以结合<code>Immutable</code>，不使用<code>Immutable</code>前修改一个数据需要做一个深拷贝</p><p><strong>主要优势：</strong><br>1、节省CPU<br>避免深拷贝，复杂对象比较<br>2、节省内存<br>结构共享，复用已有结构</p><h2 id="20-说说React-render方法的原理？在什么时候触发更新"><a href="#20-说说React-render方法的原理？在什么时候触发更新" class="headerlink" title="20. 说说React render方法的原理？在什么时候触发更新"></a>20. 说说React render方法的原理？在什么时候触发更新</h2><ul><li>render函数里面可以编写JSX，经过bable转化成createElement这种形式，用于生成虚拟DOM，最终转化成真实DOM</li><li>在React 中，类组件只要执行了 setState 方法，就一定会触发 render 函数执行，函数组件使用useState更改状态不一定导致重新render比如 当数组的地址值不发生改变，就不会触发<code>render</code>。解决方法重新创建数组</li><li>组件的props 改变了，不一定触发 render 函数的执行，但是如果 props 的值来自于父组件或者祖先组件的 state。</li></ul><p><strong>父组件发生了render子组件就一定会render</strong></p><h2 id="21-如何提高组件的渲染效率的？在React中如何避免不必要的render？"><a href="#21-如何提高组件的渲染效率的？在React中如何避免不必要的render？" class="headerlink" title="21.如何提高组件的渲染效率的？在React中如何避免不必要的render？"></a>21.如何提高组件的渲染效率的？在React中如何避免不必要的render？</h2><p>我们了解到<code>render</code>的触发时机，简单来讲就是类组件通过调用<code>setState</code>方法， 就会导致<code>render</code>，父组件一旦发生<code>render</code>渲染，子组件一定也会执行<code>render</code>渲染</p><p>父组件渲染导致子组件渲染，<strong>子组件并没有发生任何改变</strong>，这时候就可以从避免无谓的渲染，具体实现的方式有如下：</p><ul><li>shouldComponentUpdate</li><li>PureComponent</li><li>React.memo</li></ul><p>通过<code>shouldComponentUpdate</code>生命周期函数来比对 <code>state</code>和 <code>props</code>，确定是否要重新渲染</p><p>默认情况下返回<code>true</code>表示重新渲染，如果不希望组件重新渲染，返回 <code>false</code> 即可</p><p>PureComponent和shouldComponentUpdate差不多。</p><p><code>React.memo</code>用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 <code>PureComponent</code> 十分类似。但不同的是， <code>React.memo</code> 只能用于<strong>函数组件</strong></p><h2 id="23-React-Jsx转换成真实DOM过程？"><a href="#23-React-Jsx转换成真实DOM过程？" class="headerlink" title="23.React Jsx转换成真实DOM过程？"></a>23.React Jsx转换成真实DOM过程？</h2><p>书写JSX代码 =&gt; Babel编译JSX =&gt;生成React.createElement的js形式 =&gt; 生成虚拟Dom =&gt; render渲染生成真实Dom</p><h2 id="24-React性能优化的手段？"><a href="#24-React性能优化的手段？" class="headerlink" title="24. React性能优化的手段？"></a>24. React性能优化的手段？</h2><p><code>React</code>凭借<code>virtual DOM</code>和<code>diff</code>算法拥有高效的性能，但是某些情况下，性能明显可以进一步提高。</p><ul><li>避免不必要的<code>render</code>    通过<code>shouldComponentUpdate</code>、<code>PureComponent</code>、<code>React.memo</code> useCallback、useMemo等</li><li>避免使用内联函数          使用内联函数，则每次调用<code>render</code>函数时都会创建一个新的函数实例</li><li>使用 React.Fragments 避免额外标记     使用空标签<></></li><li>使用 Immutable            shouldComponentUpdate时复杂对象比较  redux的reducer避免深拷贝浪费性能</li><li>懒加载组件                     路由懒加载就是加载首页时不加载其他组件  使用到了<code>Suspense</code>和 <code>lazy</code>组件</li><li>利用debounce、throttle 避免重复回调  在搜索组件中，当 input 中内容修改时就触发搜索回调。            </li><li>服务端渲染                    1 利于SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面 2 加速首屏加载，解决首屏白屏问题</li></ul><h2 id="25-usememo和useCallback的区别与应用场景"><a href="#25-usememo和useCallback的区别与应用场景" class="headerlink" title="25. usememo和useCallback的区别与应用场景"></a>25. usememo和useCallback的区别与应用场景</h2><p>react性能的优化点在于：</p><ol><li>调用setState，就会触发组件的重新渲染，无论前后的state是否不同</li><li>父组件更新，子组件也会自动的更新</li></ol><p>useCallback和useMemo的参数跟useEffect一致，他们之间最大的区别有是useEffect会用于处理副作用，而前两个hooks不能。</p><p>use Memo 和 <code>useCallback</code> 接收的参数都是一样,第一个参数为回调 第二个参数为要依赖的数据</p><p>共同作用：<br>1.仅仅 <code>依赖数据</code> 发生变化, 才会重新计算结果，也就是起到缓存的作用。</p><p>两者区别：<br>1.<code>useMemo</code> 计算结果是 <code>return</code> 回来的值, 主要用于 缓存计算结果的值 ，应用场景如： 如果你的页面上展示的数据是通过某个（某些）state计算得来的一个数据，那么你每次这个组件里面无关的state变化引起的重新渲染，都会去计算一下这个数据，这时候就需要用useMemo(()=&gt;{}, [])去包裹你的计算的方法体，这样那些无关的state改变引起的渲染不会重新计算这个方法体，而是返回之前计算的结果，达到一种缓存的效果。<br>2.<code>useCallback</code> 计算结果是 <code>函数</code>, 主要用于 缓存函数，应用场景如: 父组件中需要传递函数到子组件，父组件每次更新都会重新声明内部的函数，导致传递给子组件的函数变化，子组件也会进行没有必要的更新，这种情况就可以利用 useCallback 处理传递给子组件的函数，避免每次父组件更新导致子组件更新的情况，因为只要useCallback 的依赖项没有发生变化，传递给子组件的函数始终都是缓存的同一个函数。</p><h2 id="26、react-redux模型图"><a href="#26、react-redux模型图" class="headerlink" title="26、react-redux模型图"></a>26、react-redux模型图</h2><p>（1）所有的UI组件都应该包裹一个容器组件，他们是父子关系；</p><p>（2）容器组件是真正和redux打交道的，里面可以随意使用redux的api；负责处理业务逻辑，向UI组件传递参数。</p><p>（3）UI组件中不能使用任何redux的api；只负责渲染页面，没有逻辑功能。</p><p>（4）容器组件会传给UI组件：1.redux中保存的状态。 2.用于操作状态的方法；</p><p>（5）备注：容器给UI传递：状态、操作状态的方法，均通过props传递；</p><!-- <img src="img/v2-1b63aef607539525cd02eccebf385127_r-16860565706992.jpg" alt="img" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/v2-1b63aef607539525cd02eccebf385127_r-16860565706992.jpg" style="width:80%;"/></div></div>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八 VUE interview-questions</title>
      <link href="/2023/01/04/8/"/>
      <url>/2023/01/04/8/</url>
      
        <content type="html"><![CDATA[<h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="1、v-if和v-show的区别"><a href="#1、v-if和v-show的区别" class="headerlink" title="1、v-if和v-show的区别"></a>1、v-if和v-show的区别</h2><p>v-if 是删除dom结点，而v-show是通过设置display:none,实现的，dom结点还存在</p><ul><li><code>v-show</code> 由<code>false</code>变为<code>true</code>的时候不会触发组件的生命周期</li><li><code>v-if</code>由<code>false</code>变为<code>true</code>的时候，触发组件的<code>beforeCreate</code>、<code>create</code>、<code>beforeMount</code>、<code>mounted</code>钩子，由<code>true</code>变为<code>false</code>的时候触发组件的<code>beforeDestory</code>、<code>destoryed</code>方法</li></ul><p>性能消耗：<code>v-if</code>有更高的切换消耗</p><p>如果需要非常频繁地切换，则使用 v-show 较好</p><p>如果在运行时条件很少改变，则使用 v-if 较好</p><h2 id="2、v-if和v-for不建议一起用"><a href="#2、v-if和v-for不建议一起用" class="headerlink" title="2、v-if和v-for不建议一起用"></a>2、v-if和v-for不建议一起用</h2><p><code>v-for</code>优先级是比<code>v-if</code>高</p><p>一起用的话，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）</p><p>可以在v-for那个标签的外部进行v-if判断.</p><p>如果要把v-if放到v-for标签之内，可以先通过计算属性<code>computed</code>提前过滤掉那些不需要显示的项</p><h2 id="3、组件通讯"><a href="#3、组件通讯" class="headerlink" title="3、组件通讯"></a>3、组件通讯</h2><ul><li>父子关系的组件数据传递选择 <code>props</code> 与 <code>$emit</code>进行传递，也可选择<code>ref</code></li><li>兄弟关系的组件数据传递可选择<code>$bus</code>，</li><li>祖先与后代组件数据传递可选择<code>attrs</code>与<code>listeners</code>或者 <code>Provide</code>与 <code>Inject</code></li><li>复杂关系的组件数据传递可以通过<code>vuex</code>存放共享的变量</li></ul><p>props 父向子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Children</span> name=<span class="string">&quot;jack&quot;</span> age=<span class="number">18</span> /&gt;</span><br><span class="line">    </span><br><span class="line"><span class="attr">props</span>:&#123;  </span><br><span class="line">    <span class="comment">// 字符串形式  </span></span><br><span class="line"> <span class="attr">name</span>:<span class="title class_">String</span> <span class="comment">// 接收的类型参数  </span></span><br><span class="line">    <span class="comment">// 对象形式  </span></span><br><span class="line">    <span class="attr">age</span>:&#123;    </span><br><span class="line">        <span class="attr">type</span>:<span class="title class_">Number</span>, <span class="comment">// 接收的类型为数值  </span></span><br><span class="line">        <span class="attr">defaule</span>:<span class="number">18</span>,  <span class="comment">// 默认值为18  </span></span><br><span class="line">       <span class="attr">require</span>:<span class="literal">true</span> <span class="comment">// age属性必须传递  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$emit 子向父 </p><p>触发自定义事件</p><ul><li>适用场景：子组件传递数据给父组件</li><li>子组件通过<code>$emit触发</code>自定义事件，<code>$emit</code>第二个参数为传递的数值</li><li>父组件绑定监听器获取到子组件传递过来的参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  子</span></span><br><span class="line"><span class="title function_">deleteItem</span>(<span class="params">id</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.$emit(<span class="string">&#x27;delete&#x27;</span>, id)</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="comment">//  父</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">List</span> <span class="attr">:list</span>=<span class="string">&quot;list&quot;</span> @<span class="attr">delete</span>=<span class="string">&quot;deleteHandler&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="title function_">deleteHandler</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> !== id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// input封装成组件</span></span><br><span class="line">&lt;<span class="title class_">CustomInput</span> v-model=<span class="string">&quot;searchText&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="title class_">CustomInput</span>.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">defineProps</span>([<span class="string">&#x27;modelValue&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">defineEmits</span>([<span class="string">&#x27;update:modelValue&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:value</span>=<span class="string">&quot;modelValue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    @<span class="attr">input</span>=<span class="string">&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// vue3的写法</span></span><br><span class="line"><span class="comment">// 默认情况下，v-model 在组件上都是使用 modelValue 作为 prop，并以 update:modelValue 作为对应的事件。我们可以通过给 v-model 指定一个参数来更改这些名字</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-model:title</span>=<span class="string">&quot;bookTitle&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个例子中，子组件应声明一个 title prop，并通过触发 update:title 事件更新父组件值：</span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="title class_">MyComponent</span>.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">defineProps</span>([<span class="string">&#x27;title&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">defineEmits</span>([<span class="string">&#x27;update:title&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:value</span>=<span class="string">&quot;title&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    @<span class="attr">input</span>=<span class="string">&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>$bus 兄弟传值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$root</span>.<span class="property">bus</span>.$emit(<span class="string">&#x27;dong&#x27;</span>, <span class="variable language_">this</span>.<span class="property">number</span>)  <span class="comment">// 触发 dong 事件，并传递 number</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// created 生命周期函数：实例创建完成， 但是还没有挂载到 DOM</span></span><br><span class="line">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="variable language_">this</span>    <span class="comment">// 这里为什么要把 this 保存起来？</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$root</span>.<span class="property">bus</span>.$on(<span class="string">&#x27;dong&#x27;</span>, <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">      that.<span class="property">number</span> = value  <span class="comment">// 因为如果在函数里面的函数直接用this，this的值可能会改变</span></span><br><span class="line">    &#125;)                     <span class="comment">// 上面把 this 赋值给 that，那么 that 就是 Vue实例</span></span><br><span class="line">  &#125;,                       <span class="comment">// 你也可以使用 ES6 中的 箭头函数，这样 this 的值就不会变了</span></span><br><span class="line"><span class="title function_">beforeDestory</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$root</span>.<span class="property">bus</span>.<span class="title function_">off</span>(<span class="string">&#x27;dong&#x27;</span>,xxx) <span class="comment">// 及时销毁，避免内存泄漏</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4、生命周期"><a href="#4、生命周期" class="headerlink" title="4、生命周期"></a>4、生命周期</h2><!-- ![](/img/articles/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjU0MDY1,size_16,color_FFFFFF,t_70.png) --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjU0MDY1,size_16,color_FFFFFF,t_70.png" style="width:60%;"/></div></div><h3 id="1、created-和-mouted的区别"><a href="#1、created-和-mouted的区别" class="headerlink" title="1、created 和 mouted的区别"></a>1、created 和 mouted的区别</h3><p>created 就是初始化vue的实例，而mounted是页面已经渲染完成</p><h3 id="2、父子组件生命周期执行顺序"><a href="#2、父子组件生命周期执行顺序" class="headerlink" title="2、父子组件生命周期执行顺序"></a>2、父子组件生命周期执行顺序</h3><p>加载渲染过程</p><p>父beforecreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted</p><p>更新过程</p><p>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p><p>销毁过程</p><p>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p><h2 id="5、自定义v-model"><a href="#5、自定义v-model" class="headerlink" title="5、自定义v-model"></a>5、自定义v-model</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;value&quot;</span> /&gt;</span><br><span class="line">    <span class="comment">// 上面是下面的语法糖</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;value&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;value = $event.target.value&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>父组件展示部分</p><!-- <img src="img/image-20230521110158760.png" alt="image-20230521110158760" style="zoom:80%;" /> --><p><img src="/img/articles/image-20230521110158760.png" alt=""><br>子组件CustomVmodel</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">------------父组件</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CustomInput</span> <span class="keyword">from</span> <span class="string">&#x27;./CustomInput.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">CustomInput</span> &#125;,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">CustomInput</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> /&gt;</span> &#123;&#123; message &#125;&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">-------------子组件</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;modelValue&#x27;</span>],</span><br><span class="line">  <span class="attr">emits</span>: [<span class="string">&#x27;update:modelValue&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:value</span>=<span class="string">&quot;modelValue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    @<span class="attr">input</span>=<span class="string">&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>展示结果</p><!-- <img src="img/image-20230704144132654.png" alt="image-20230704144132654" style="zoom:80%;" /> --><p><img src="/img/articles/image-20230704144132654.png" alt=""></p><h2 id="6、-nextTick"><a href="#6、-nextTick" class="headerlink" title="6、$nextTick"></a>6、$nextTick</h2><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</p><p><code>Vue</code> 在更新 <code>DOM</code> 时是异步执行的。当数据发生变化，<code>Vue</code>将开启一个异步更新队列，等队列中所有数据变化完成之后，再统一进行更新</p><p>第一个参数为：回调函数（可以获取最近的<code>DOM</code>结构）</p><p>第二个参数为：执行函数上下文</p><p>通过this.$nextTick（）调用</p><h2 id="7、动态组件和异步加载"><a href="#7、动态组件和异步加载" class="headerlink" title="7、动态组件和异步加载"></a>7、动态组件和异步加载</h2><div class="tag link"><a class="link-card" title="vue动态组件" href="https://blog.csdn.net/qq_57587705/article/details/124520495"><div class="left"><img src="/img/icon/wwwicon.png"/></div><div class="right"><p class="text">vue动态组件</p><p class="url">https://blog.csdn.net/qq_57587705/article/details/124520495</p></div></a></div><!-- https://blog.csdn.net/qq_57587705/article/details/124520495 --><p>vue 提供了一个内置的 <component> 组件，专门用来实现动态组件的渲染。示例代码如下：</p><!-- <img src="img/image-20230521152054664.png" alt="image-20230521152054664" style="zoom:67%;" /> --><p><img src="/img/articles/image-20230521152054664.png" alt=""></p><p>默认情况下，切换动态组件时无法保持组件的状态。此时可以使用vue 内置的 <keep-alive> 组件保持动态组 件的状态。示例代码如下：</p><!-- <img src="img/image-20230521152112412.png" alt="image-20230521152112412" style="zoom:67%;" /> --><p><img src="/img/articles/image-20230521152112412.png" alt=""></p><p>异步加载组件</p><!-- <img src="img/image-20230521152533259.png" alt="image-20230521152533259" style="zoom:80%;" /> --><p><img src="/img/articles/image-20230521152533259.png" alt=""></p><h2 id="8、mixin-混入"><a href="#8、mixin-混入" class="headerlink" title="8、mixin 混入"></a>8、mixin 混入</h2><p>抽离公共逻辑，利于代码复用</p><p>定义一个<code>mixin</code>对象，有组件<code>options</code>的<code>data</code>、<code>methods</code>属性</p><p>优先级</p><p>组件 data，methods优先级高于mixin data优先级<br>生命周期函数，先执行 mixin 里面的，再执行组件里面的</p><p>自定义的属性，组件中的属性优先级高于mixin属性的优先级</p><p><strong>局部使用</strong></p><!-- <img src="img/image-20230521154109305.png" alt="image-20230521154109305" style="zoom:80%;" /> --><p><img src="/img/articles/image-20230521154109305.png" alt=""></p><p><strong>全局使用</strong></p><!-- <img src="img/image-20230521154224270.png" alt="image-20230521154224270" style="zoom:67%;" /> --><p><img src="/img/articles/image-20230521154224270.png" alt=""></p><p><strong>问题</strong></p><p>变量来源不明确，不利于阅读</p><p>多mixin 可能会造成命名冲突</p><p>mixin和组件可能出现多对多的关系，复杂度较高</p><h2 id="9、v-for中为什么要用key"><a href="#9、v-for中为什么要用key" class="headerlink" title="9、v-for中为什么要用key"></a>9、v-for中为什么要用key</h2><!-- <img src="img/image-20230521223012666.png" alt="image-20230521223012666" style="zoom:50%;" /> --><p><img src="/img/articles/image-20230521223012666.png" alt=""></p><h2 id="10、何时使用beforeDestory"><a href="#10、何时使用beforeDestory" class="headerlink" title="10、何时使用beforeDestory"></a>10、何时使用beforeDestory</h2><!-- <img src="img/image-20230521223854366.png" alt="image-20230521223854366" style="zoom:50%;" /> --><p><img src="/img/articles/image-20230521223854366.png" alt=""></p><h2 id="11、vuex中action和mutaion的区别"><a href="#11、vuex中action和mutaion的区别" class="headerlink" title="11、vuex中action和mutaion的区别"></a>11、vuex中action和mutaion的区别</h2><!-- <img src="img/image-20230521224029245.png" alt="image-20230521224029245" style="zoom:67%;" /> --><p><img src="/img/articles/image-20230521224029245.png" alt=""></p><h2 id="12、vue如何监听数组变化"><a href="#12、vue如何监听数组变化" class="headerlink" title="12、vue如何监听数组变化"></a>12、vue如何监听数组变化</h2><!-- <img src="img/image-20230521224250754.png" alt="image-20230521224250754" style="zoom:80%;" /> --><p><img src="/img/articles/image-20230521224250754.png" alt=""></p><h2 id="13、vue常见的性能优化"><a href="#13、vue常见的性能优化" class="headerlink" title="13、vue常见的性能优化"></a>13、vue常见的性能优化</h2><p>合理使用 v-show 和 v-if</p><p>合理使用 computed </p><p>v-for 时加key，以及避免和v-if同时使用</p><p>自定义事件、DOM事件及时销毁<br>合理使用异步组件<br>合理使用keep-alive</p><p>data层级不能太深</p><h2 id="14、vue3和vue2的区别？"><a href="#14、vue3和vue2的区别？" class="headerlink" title="14、vue3和vue2的区别？"></a>14、vue3和vue2的区别？</h2><p>1、支持ts</p><p>2、代码组织更有逻辑</p><p>3、支持逻辑复用</p><h2 id="15、setup中如何获取vue的实例"><a href="#15、setup中如何获取vue的实例" class="headerlink" title="15、setup中如何获取vue的实例"></a>15、setup中如何获取vue的实例</h2><p>通过getCurrentUnstance（）这个方法</p><p>在setup和其他Composition API中没有this<br>可通过getCurrentInstance获取当前实例<br>若使用Options API可照常使用this</p><!-- <img src="img/image-20230522162008547.png" alt="image-20230522162008547" style="zoom:80%;" /> --><p><img src="/img/articles/image-20230522162008547.png" alt=""></p><h2 id="16、vue3为何比vue2快"><a href="#16、vue3为何比vue2快" class="headerlink" title="16、vue3为何比vue2快"></a>16、vue3为何比vue2快</h2><p>1、Proxy响应式<br>2、PatchFlag</p><p>编译模板时，<strong>动态节点做标记</strong></p><p>标记，分为不同的类型，如TEXT PROPS </p><p><strong>diff算法时，可以区分静态节点，以及不同类型的动态节点</strong></p><p>3、cacheHandler</p><p>缓存事件</p><p>4、SSR 优化<br>5、hoistStatic</p><p>将静态节点的定义，提升到父作用域，缓存起来</p><p>多个相邻的静态节点，会被合并起来</p><p>典型的拿<strong>空间换时间的优化</strong>策略</p><p>6、tree-shaking</p><p>动态引入需要的内容，不需要的不引入进来</p><h2 id="17、vue和react的区别"><a href="#17、vue和react的区别" class="headerlink" title="17、vue和react的区别"></a>17、vue和react的区别</h2><p>1、框架比较</p><p>vue简单、上手容易、框架功能完善。</p><p>react学习成本高、框架功能强大、很灵活、社区资源丰富。</p><p>2、监听数据方式不同</p><p>vue通过响应式的setter、getter监听数据</p><p>react数据不可变，需要setState驱动新的state替换老的state</p><p>3、diff算法不同</p><p><strong>相同点：</strong><br>Vue和react的diff算法，都是不进行跨层级比较，只做同级比较</p><p><strong>不同点：</strong></p><ol><li>vue会在patch函数中给被操作的节点打补丁（patchflag），在diff的时候更清晰</li><li>vue对比节点，当节点元素类型相同，但是className不同时，认为是不同类型的元素，删除重新创建；而react则认为是同类型节点，进行修改操作</li><li>diff策略，vue的性能优于react</li></ol><p>4、jsx和template</p><h2 id="18、vue3-v-for动态绑定ref问题"><a href="#18、vue3-v-for动态绑定ref问题" class="headerlink" title="18、vue3 v-for动态绑定ref问题"></a>18、vue3 v-for动态绑定ref问题</h2><div class="tag link"><a class="link-card" title="v-for动态绑定ref" href="https://segmentfault.com/q/1010000042019257"><div class="left"><img src="/img/icon/wwwicon.png"/></div><div class="right"><p class="text">v-for动态绑定ref</p><p class="url">https://segmentfault.com/q/1010000042019257</p></div></a></div><p>在setup中可以收集到到元素的ref引入，但是当childApp变化时如删除，新增，childAppRefs会push重复的元素。</p><p>不过不一定非得用数组，你也可以用个对象来装，以索引为 Key、然后过滤掉比数据源数组长度还大的那些 Key：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;child v-<span class="keyword">for</span>=<span class="string">&quot;(item, index) in list&quot;</span> :ref=<span class="string">&quot;el =&gt; setChildRef(el, index)&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 你也可以抽成一个 hooks，用起来更方便</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> childRefs = &#123;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> computedChildRefs = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(childRefs)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    .<span class="title function_">filter</span>(<span class="function">(<span class="params">[index, ref]</span>) =&gt;</span> +index &lt; list.<span class="property">length</span> &amp;&amp; !!ref)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    .<span class="title function_">map</span>(<span class="function">(<span class="params">[_, ref]</span>) =&gt;</span> ref)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> <span class="title function_">setChildRef</span> = (<span class="params">el, index</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  childRefs[index] = el</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七  项目角色和流程</title>
      <link href="/2022/12/15/7/"/>
      <url>/2022/12/15/7/</url>
      
        <content type="html"><![CDATA[<h1 id="项目角色和流程"><a href="#项目角色和流程" class="headerlink" title="项目角色和流程"></a>项目角色和流程</h1><!-- <img src="img/image-20230601201948892.png" alt="image-20230601201948892" style="zoom:70%;" /> --><p><img src="/img/articles/image-20230601201948892.png" alt=""></p><!-- <img src="img/image-20230601203822270.png" alt="image-20230601203822270" style="zoom:67%;" /> --><p><img src="/img/articles/image-20230601203822270.png" alt=""></p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul><li>了解背景</li><li>质疑需求是否合理</li><li>需求是否闭环</li><li>开发难度如何</li><li>是否需要其他支持</li><li>不要急于给排期</li></ul><!-- <img src="img/image-20230601204434636.png" alt="image-20230601204434636" style="zoom:67%;" /> --><p><img src="/img/articles/image-20230601204434636.png" alt=""></p><h2 id="技术方案设计"><a href="#技术方案设计" class="headerlink" title="技术方案设计"></a>技术方案设计</h2><ul><li>求简，不过渡设计</li><li>产出文档</li><li>找准设计重点</li><li>组内评审</li><li>和 RD CRD 沟通</li><li>发出会议结论</li></ul><!-- <img src="img/image-20230601204959094.png" alt="image-20230601204959094" style="zoom:67%;" /> --><p><img src="/img/articles/image-20230601204959094.png" alt=""></p><!-- <img src="img/image-20230602102905110.png" alt="image-20230602102905110" style="zoom:60%;" /> --><p><img src="/img/articles/image-20230602102905110.png" alt=""><br><!-- <img src="img/image-20230602103221439.png" alt="image-20230602103221439" style="zoom:67%;" /> --><br><img src="/img/articles/image-20230602103221439.png" alt=""><br><!-- <img src="img/image-20230602103238582.png" alt="image-20230602103238582" style="zoom:67%;" /> --><br><img src="/img/articles/image-20230602103238582.png" alt=""><br><!-- <img src="img/image-20230602103602361.png" alt="image-20230602103602361" style="zoom:67%;" /> --><br><img src="/img/articles/image-20230602103602361.png" alt=""><br><!-- <img src="img/image-20230602103630086.png" alt="image-20230602103630086" style="zoom:67%;" /> --><br><img src="/img/articles/image-20230602103630086.png" alt=""><br><!-- <img src="img/image-20230602103836045.png" alt="image-20230602103836045" style="zoom:67%;" /> --><br><img src="/img/articles/image-20230602103836045.png" alt=""><br><!-- <img src="img/image-20230602104218047.png" alt="image-20230602104218047" style="zoom:67%;" /> --><br><img src="/img/articles/image-20230602104218047.png" alt=""></p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>1、PM 想在项目开发过程中增加需求，该怎么办？</p><p>不能拒绝，走需求变更流程即可。如果公司有规定，则按规定走。否则，发起项目组和 leader 的评审，重新评估排期</p><p>2、项目即将延期了，该怎么办？</p><ul><li>整体调整，改变项目计划。</li><li>并行任务，缩短执行工时</li><li>增加资源，以成本换时间</li><li>协商谈判，先完成最“需要”</li></ul><p>3、你将如何保证项目质量？</p><ul><li>符合开发规范</li><li>及时单元测试</li><li>写出开发文档</li><li>Mock API</li><li>Code Review</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目角色和流程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目角色和流程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六 项目部署与上线</title>
      <link href="/2022/11/01/6/"/>
      <url>/2022/11/01/6/</url>
      
        <content type="html"><![CDATA[<h1 id="项目部署与上线"><a href="#项目部署与上线" class="headerlink" title="项目部署与上线"></a>项目部署与上线</h1><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>镜像，容器，仓库的三者关系</p><p><img src="/img/articles/image-20221110105214725.png" alt=""></p><p>常用命令</p><p><img src="/img/articles/image-20221110100215207.png" alt=""></p><p>docker操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull <span class="attr">centos</span>:</span><br></pre></td></tr></table></figure><h2 id="dockerfile和阿里云"><a href="#dockerfile和阿里云" class="headerlink" title="dockerfile和阿里云"></a>dockerfile和阿里云</h2><p>制作镜像 （<strong>使用时删掉//后的备注</strong>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># 第一个阶段: 拉取node镜像来打包<span class="title class_">React</span>项目</span><br><span class="line"><span class="variable constant_">FROM</span> <span class="attr">node</span>:<span class="number">14</span> <span class="keyword">as</span> build</span><br><span class="line"><span class="variable constant_">WORKDIR</span> /app</span><br><span class="line"><span class="variable constant_">COPY</span> package*.<span class="property">json</span> ./</span><br><span class="line"><span class="variable constant_">RUN</span> npm install</span><br><span class="line"><span class="variable constant_">COPY</span> jsconfig.<span class="property">json</span> ./</span><br><span class="line"><span class="variable constant_">COPY</span> craco.<span class="property">config</span>.<span class="property">js</span> ./</span><br><span class="line"><span class="variable constant_">COPY</span> public public/</span><br><span class="line"><span class="variable constant_">COPY</span> src src/</span><br><span class="line"><span class="variable constant_">RUN</span> npm run build</span><br><span class="line"></span><br><span class="line"># 第二个阶段: 创建并运行<span class="title class_">Ngnix</span>服务器，并且把打包好的文件复制粘贴到服务器文件夹中</span><br><span class="line"><span class="variable constant_">FROM</span> <span class="attr">nginx</span>:alpine</span><br><span class="line"><span class="variable constant_">COPY</span> --<span class="keyword">from</span>=build /app/build/ <span class="regexp">/usr/</span>share/nginx/html</span><br><span class="line"><span class="variable constant_">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="variable constant_">CMD</span> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"># 第一个阶段: 拉取node镜像来打包<span class="title class_">React</span>项目</span><br><span class="line">## 拉取node镜像 版本<span class="number">14</span> 命名为build</span><br><span class="line"><span class="variable constant_">FROM</span> <span class="attr">node</span>:<span class="number">14</span> <span class="keyword">as</span> build</span><br><span class="line">## 设置docker命令运行目录</span><br><span class="line"><span class="variable constant_">WORKDIR</span> /app</span><br><span class="line">## 复制对应文件到app文件夹中 app/</span><br><span class="line"><span class="variable constant_">COPY</span> package*.<span class="property">json</span> ./</span><br><span class="line">## 安装项目依赖</span><br><span class="line"><span class="variable constant_">RUN</span> npm install</span><br><span class="line">## 复制对应文件到app文件夹中 app/</span><br><span class="line"><span class="variable constant_">COPY</span> tsconfig.<span class="property">json</span> ./</span><br><span class="line">## 复制public文件夹并创建public文件夹</span><br><span class="line"><span class="variable constant_">COPY</span> public public/</span><br><span class="line">## 复制src文件夹并创建src文件夹</span><br><span class="line"><span class="variable constant_">COPY</span> src src/</span><br><span class="line">## 构建react项目</span><br><span class="line"><span class="variable constant_">RUN</span> npm run build</span><br><span class="line"></span><br><span class="line"># 第二个阶段: 创建并运行<span class="title class_">Ngnix</span>服务器，并且把打包好的文件复制粘贴到服务器文件夹中</span><br><span class="line">## 拉取nginx服务器镜像 :执行版本</span><br><span class="line"><span class="variable constant_">FROM</span> <span class="attr">nginx</span>:alpine</span><br><span class="line">## 将第一阶段通过npm run build构建好的react项目复制到nginx服务器镜像中</span><br><span class="line"><span class="variable constant_">COPY</span> --<span class="keyword">from</span>=build /app/build/ <span class="regexp">/usr/</span>share/nginx/html</span><br><span class="line">## 暴露nginx服务器端口</span><br><span class="line"><span class="variable constant_">EXPOSE</span> <span class="number">80</span></span><br><span class="line">## 使用<span class="variable constant_">CMD</span>命令来启动nginx命令</span><br><span class="line"><span class="variable constant_">CMD</span> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为<span class="variable constant_">CSDN</span>博主「陈坚泓」的原创文章，遵循<span class="variable constant_">CC</span> <span class="number">4.0</span> <span class="variable constant_">BY</span>-<span class="variable constant_">SA</span>版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：<span class="attr">https</span>:<span class="comment">//blog.csdn.net/weixin_42752574/article/details/122594056</span></span><br></pre></td></tr></table></figure><ol><li><p>在此文件夹的cmd命令窗口输入 docker build -t react-web .    // (react-web)是自己取的镜像名 构建react-web镜像</p></li><li><p>然后docker images 查看当前所有的镜像</p></li><li><p>docker run -d -p 12231:80    react-web  将nginx服务器的80端口映射给电脑的12231端口</p></li><li><p>docker ps   查看运行的容器</p></li><li><p>可以在本机上输入localhost:12231进入查看项目了</p></li></ol><p>阿里云操作</p><p><a href="https://www.acwing.com/blog/content/20977/">https://www.acwing.com/blog/content/20977/</a></p><p>1.创建云服务器ECS实例<br>2.点击实例列表中的远程连接，方式选Workbench远程连接然后输入密码<br>3.通过以下四个命令添加yum源 </p><p><img src="/img/articles/image-20221112150553901.png" alt=""></p><p>4.安装docker yum install docker-io -y<br>5.启动docker systemctl start docker<br>6.查看安装结果docker info<br>7.启动阿里云的容器镜像服务 </p><p>先开启阿里云容器镜像服务，然后进入镜像加速器，按照指引把命令复制到终端运行（然后docker加速器就添加成功了）</p><p>8.接下里就是本课第五步，本地构建课程实战项目的docker镜像<br>打开命令行，cd 到项目文件夹<br>使用命令docker build -t react-web . ，然后镜像就创建成功了<br>运行docker images查看一下</p><p>9.课程的第六步：在阿里云镜像服务中创建我们的私人docker镜像仓库<br>打开阿里云容器镜像服务，点击镜像仓库，点击创建镜像仓库（代码源选本地仓库），然后点击仓库进入仓库的操作文档</p><p>首先复制第一条命令登录仓库，然后填写阿里云登陆密码<br>然后复制第3命令去推送镜像，其中命令里的版本号是自定义的（比如1.0.0），ImageId可以在docker images里找到。</p><p>在镜像仓库文档页面左侧点击镜像版本，就可以看到刚上传好的镜像了<br>接下来就要在ECS服务器上部署这个docker镜像了，所以到仓库基本信息页复制第2条命令<br>拉取成功之后就要部署这个镜像了docker run -d -p 12231:80 第2里的命令pull后面<strong>跟着的仓库地址</strong><br>然后docker就运行起来了，运行docker ps查看一下状态</p><p>10.由于ECS服务器的实例安全策略，我们暂时没法从外部访问项目的端口12231，所以我们需要配置一下</p><p>打开ECS实例列表，点击实例名称，在基本信息栏中找到配置安全组规则，然后在普通安全组中找到配置规则，点击手动添加，在端口范围目的中输入12231/12231，授权对象源输入0.0.0.0/0【表示不对外部 ip 做任何显示】</p><p>然后等待几分钟，等安全策略规则响应，然后回到实例列表，复制ECS实例公网地址+端口号:12231到浏览器</p>]]></content>
      
      
      <categories>
          
          <category> 部署与上线 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署与上线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五 webpack</title>
      <link href="/2022/10/15/5/"/>
      <url>/2022/10/15/5/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="1-webpack的构建流程"><a href="#1-webpack的构建流程" class="headerlink" title="1. webpack的构建流程"></a>1. webpack的构建流程</h2><ul><li>初始化流程：从配置文件和 <code>Shell</code> 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</li><li>编译构建流程：从 Entry 发出，针对每个 Module 调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li><li>输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统</li></ul><p><img src="/img/articles/image-20230315103216597.png" alt=""></p><h2 id="2-loader"><a href="#2-loader" class="headerlink" title="2. loader"></a>2. loader</h2><p>loader 让 webpack 能够去<strong>处理那些非 JavaScript 文件</strong>（<strong>webpack 自身只理解 JavaScript</strong>）loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块。loader扮演一个翻译官的角色</p><p>常见的<code>loader</code>如下：</p><ul><li>style-loader: 将css添加到DOM的内联样式标签style里</li><li>css-loader :允许将css文件通过require的方式引入，并返回css代码</li><li>less-loader: 处理less</li><li>sass-loader: 处理sass</li><li>postcss-loader: 用postcss来处理CSS</li><li>autoprefixer-loader: 处理CSS3属性前缀，已被弃用，建议直接使用postcss</li><li>file-loader: 分发文件到output目录并返回相对路径</li><li>url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url</li><li>html-minify-loader: 压缩HTML</li><li>babel-loader :用babel来转换ES6文件到ES5</li></ul><h2 id="3-plugin"><a href="#3-plugin" class="headerlink" title="3. plugin"></a>3. plugin</h2><p>plugin是插件的意思,对webpack现有功能的各种扩展.</p><p>例如打包优化、资源管理、环境变量注入等，它们会运行在 <code>webpack</code> 的不同阶段，贯穿了<code>webpack</code>整个编译周期,目的在于解决<code>loader</code> 无法实现的其他事.</p><h2 id="4-loader和plugin的区别："><a href="#4-loader和plugin的区别：" class="headerlink" title="4. loader和plugin的区别："></a>4. loader和plugin的区别：</h2><p>作用：</p><ul><li>loader主要用于转换某些类型的模块为wepack能够识别的js模块，是一个加载器；</li><li>plugin是插件，对webpack本身进行扩展，是一个扩展器；</li></ul><p>作用时机：plugin运行在 <code>webpack</code> 的不同阶段，贯穿了<code>webpack</code>整个编译周期，loader在模块转换阶段</p><h2 id="5-热更新"><a href="#5-热更新" class="headerlink" title="5. 热更新"></a>5. 热更新</h2><p>它可以使得代码修改之后，不用刷新浏览器就可以更新，在应用过程中替换添加删出模块，无需重新加载整个页面，是高级版的自动刷新浏览器。</p><h2 id="6-webpack-proxy"><a href="#6-webpack-proxy" class="headerlink" title="6. webpack proxy"></a>6. webpack proxy</h2><p>即<code>webpack</code>提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在<strong>开发模式下</strong>解决跨域问题，想要实现代理首先需要一个中间服务器，<code>webpack</code>中提供服务器的工具为<code>webpack-dev-server</code></p><p><strong>服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制</strong></p><h2 id="7-如何借助webpack来优化前端性能"><a href="#7-如何借助webpack来优化前端性能" class="headerlink" title="7. 如何借助webpack来优化前端性能"></a>7. 如何借助webpack来优化前端性能</h2><ul><li>JS代码压缩    压缩：删除多余的代码、注释、简化代码的写法等等⽅式</li><li>CSS代码压缩</li><li>Html文件代码压缩</li><li>文件大小压缩</li><li>图片压缩</li><li>Tree Shaking 将未用到的代码进行删除</li><li>代码分离</li><li>内联 chunk</li><li>利用CDN加速</li><li>使用mode:production 自动开启代码压缩 还会自动使用Tree Shaking</li></ul><h2 id="8-如何优化构建速度"><a href="#8-如何优化构建速度" class="headerlink" title="8. 如何优化构建速度"></a>8. 如何优化构建速度</h2><p>npm install 过程中的优化 使用 yarn去安装npm包</p><p>具体仓库地址的选择，选择使用淘宝提供的npm仓库镜像</p><p><img src="/img/articles/image-20230315105441362.png" alt=""></p><p>1、优化lodaer配置</p><p>在使用<code>loader</code>时，可以通过配置<code>include</code>、<code>exclude</code>、<code>test</code>属性来匹配文件。</p><ul><li><code>include</code>：包含，只处理<code>xxx</code>文件</li><li><code>exclude</code>：排除，除了<code>xxx</code>文件以外其他文件都处理</li></ul><p>需要注意的是<code>include</code>和<code>exclude</code>只能二选一</p><p>2、优化 resolve.alias</p><p><code>alias</code>给一些常用的路径起一个别名，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是<code>./../../</code>的形式、</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">resolve</span>:&#123;</span><br><span class="line">        <span class="attr">alias</span>:&#123;</span><br><span class="line">            <span class="string">&quot;@&quot;</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;./src&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用cache-loader</p><p>在一些性能开销较大的 <code>loader</code>之前添加 <code>cache-loader</code>，以将结果缓存到磁盘里，显著提升二次构建速度。</p><p>保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 <code>loader</code> 使用此<code>loader</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.ext$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [<span class="string">&#x27;cache-loader&#x27;</span>, ...loaders],</span><br><span class="line">                <span class="attr">include</span>: path.<span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4、happyPack 多进程打包</p><p>JS（Node.js/Webpack）是<strong>单线程</strong>的，因此如果开启<strong>多进程</strong>打包，可以提高构建速度（特别是多核 CPU）。</p><p>项目较大，打包较慢，开启多进程能提高速度</p><p>项目较小，打包很快，开启多进程会降低速度（进程开销）</p><p>5、开启多进程压缩（生产）</p><p>Webpack 内置了 Uglify 工具压缩 JS，但它是单进程的。开启多进程压缩会更快，和 happyPack 同理。</p><p>首先需要安装 ParallelUglifyPlugin：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-parallel-uglify-plugin --save-dev</span><br></pre></td></tr></table></figure><p>6、开启热更新(开发)</p><p>热更新：新代码生效，网页不刷新，状态不丢失</p><p>代码配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="comment">// 开启 HMR 特性</span></span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment">// hotOnly: true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过上述这种配置，如果我们修改并保存css文件，确实能够以不刷新的形式更新到页面中。但是，当我们修改并保存js文件之后，页面依旧自动刷新了，这里并没有触发热模块。所以，HMR并不像 Webpack 的其他特性一样可以开箱即用，需要有一些额外的操作。我们需要去指定哪些模块发生更新时进行HRM，如下代码：</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">module</span>.<span class="property">hot</span>)&#123;</span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(<span class="string">&#x27;./util.js&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;util.js更新了&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、使用tree sharking 将未用到的代码进行删除</p><p>8、使用 DLLPlugin 插件(开发)</p><p><code>DLL</code>全称是 动态链接库，是为软件在winodw种实现共享函数库的一种实现方式，而Webpack也内置了DLL的功能，为的就是可以共享，不经常改变的代码，抽成一个共享的库。这个库在之后的编译过程中，会被引入到其他项目的代码中</p><p>使用步骤分成两部分：</p><ul><li>打包一个 DLL 库</li><li>引入 DLL 库</li></ul><p>9、noParse</p><p>这是module中的一个属性，作用：不去解析属性值代表的库的依赖</p><h2 id="9、前端为何要进行打包和构建？"><a href="#9、前端为何要进行打包和构建？" class="headerlink" title="9、前端为何要进行打包和构建？"></a>9、前端为何要进行打包和构建？</h2><p>1、代码层面</p><ul><li>代码体积更小（Tree-Shaking、压缩、合并），加载更快</li><li>编译高级语言或语法（TS，ES6+，模块化，scss）</li><li>兼容性和错误检查（Polyfill，postcss，eslint）</li></ul><p>2、前端工程化</p><ul><li>统一、高效的开发环境</li><li>统一的构建流程和产出标准</li><li>集成公司构建规范（提测、上线等）</li></ul><h2 id="10、module-chunk-bundle-的区别"><a href="#10、module-chunk-bundle-的区别" class="headerlink" title="10、module chunk bundle 的区别"></a>10、module chunk bundle 的区别</h2><ul><li>module-各个源码文件，webpack 中一切皆模块</li><li>chunk-多模块合并成的，如 entry import（）splitChunk </li><li>bundle-最终的输出文件</li></ul><p><img src="/img/articles/image-20230528160202149.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四 计算机网络</title>
      <link href="/2022/09/01/4/"/>
      <url>/2022/09/01/4/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1-http2-与-http1-之间的区别？"><a href="#1-http2-与-http1-之间的区别？" class="headerlink" title="1. http2 与 http1 之间的区别？"></a>1. http2 与 http1 之间的区别？</h2><p>1.<strong>新的二进制格式</strong>：HTTP2 采用二进制格式而 HTTP1 使用文本格式。</p><p>2.<strong>多路复用</strong>：HTTP2 是完全多路复用的，而非有序并阻塞的，只需一个连接即可实现并行。HTTP1 一个连接只能发送一个请求。</p><p>3.<strong>首部压缩</strong>：HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。</p><p>4.<strong>服务器推送</strong>：HTTP2 在客端请求资源的时候，会把相关的资源一起发送给客户端，而不需要客户端再次发起请求获取资源。</p><p>原文链接：<a href="https://blog.csdn.net/weixin_40300870/article/details/127305593">https://blog.csdn.net/weixin_40300870/article/details/127305593</a></p><h2 id="2-websocket"><a href="#2-websocket" class="headerlink" title="2. websocket"></a>2. websocket</h2><p>WebSocket 是 HTML5 下一种基于 tcp 的能够全双工通信的持久化协议。</p><p>同：都是基于 tcp 协议的，都是可靠的传输协议。都是应用层的。</p><p>http 协议是单向的、无状态、无连接的通信协议，通信只能客户端请求，服务器回答，一次 tcp 连接只能发起一次请求。而 Websocket 允许客户端和服务器全双工通讯，只需一次连接，长久通信。</p><h2 id="3-强制缓存与协商缓存"><a href="#3-强制缓存与协商缓存" class="headerlink" title="3. 强制缓存与协商缓存"></a>3. 强制缓存与协商缓存</h2><p><a href="https://www.jianshu.com/p/fb59c770160c/">https://www.jianshu.com/p/fb59c770160c/</a></p><p>缓存的原理：在首次请求后保存一份请求资源的响应副本，当用户再次发起相同请求后，如果判断缓存命中则拦截请求，将之前存储的响应副本返回给用户，从而避免重新向服务器发起资源请求。</p><p>强制缓存： 通过 cache-control 和 expires 判断资源是否过期，没过期直接使用缓存资源，返回 200，过期重新发起请求，与强制缓存相关的两个字段：<strong>expires、cache-control</strong><br>协商缓存：通过 get 去<strong>请求服务器验证</strong>资源是否更新，如果没更新返回 304 继续使用本地缓存，过期就返回 200。主要通过<strong>last-modified</strong>和<strong>etag</strong>值判断</p><h2 id="4-在浏览器输入-url-后会发生的过程："><a href="#4-在浏览器输入-url-后会发生的过程：" class="headerlink" title="4. 在浏览器输入 url 后会发生的过程："></a>4. 在浏览器输入 url 后会发生的过程：</h2><p>1.DNS 对域名进行解析； 2.建立 TCP 连接（<a href="https://so.csdn.net/so/search?q=三次握手&amp;spm=1001.2101.3001.7020">三次握手</a>）； 3.发送 HTTP 请求； 4.服务器处理请求； 5.返回响应结果； 6.关闭 TCP 连接（四次挥手）； 7.浏览器解析 HTML； 8.浏览器布局渲染；</p><h2 id="5-http-和-https-区别"><a href="#5-http-和-https-区别" class="headerlink" title="5. http 和 https 区别"></a>5. http 和 https 区别</h2><p>1、HTTP 协议以明文方式发送内容，不提供任何方式的数据加密。HTTP 协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。https 则是具有安全性的 ssl 加密传输协议。2、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。3、并且 https 协议需要到 ca 申请证书。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。</p><ol><li>网络攻击 XSS 和 CSRF</li></ol><p>xss，即 Cross Site Script，中文翻译是跨站脚本攻击。XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。</p><p>应对：1、<strong>HttpOnly 防止劫取 Cookie</strong>， 2、<strong>输入检查</strong>，一般是检查用户输入的数据中是否包含 &lt;，&gt; 等特殊字符，如果存在，则对特殊字符进行过滤或编码，3、<strong>输出检查</strong></p><p>CSRF，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p><p>应对：1 添加 token 认证，2 验证码，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。</p><h2 id="6-从输入-url-到页面完成加载发生了什么"><a href="#6-从输入-url-到页面完成加载发生了什么" class="headerlink" title="6. 从输入 url 到页面完成加载发生了什么"></a>6. 从输入 url 到页面完成加载发生了什么</h2><p><a href="https://blog.csdn.net/china_coding/article/details/127188830">https://blog.csdn.net/china_coding/article/details/127188830</a></p><ul><li><p>DNS 解析：将域名解析成 IP 地址</p></li><li><p>TCP 连接：TCP 三次握手</p></li><li><p>发送 HTTP 请求</p></li><li><p>服务器处理请求并返回 HTTP 报文</p></li><li><p>浏览器解析渲染页面</p></li></ul><h2 id="7-CDN"><a href="#7-CDN" class="headerlink" title="7. CDN"></a>7. CDN</h2><p>Content Delivery Network，内容分发⽹络，CDN 是指⼀种通过互联⽹互相连接的⽹络系统，利⽤最靠近⽤户的服务器，更快、更可靠地将资源发送给⽤户。</p><p>CDN 的作⽤ ：</p><p>CDN ⼀般会⽤来托管 Web 资源（包括⽂本、图⽚和脚本等），可供下载的资源（媒体⽂件、软件、⽂档 等），应⽤程序（⻔户⽹站等）。使⽤ CDN 来加速这些资源的访问。</p><p>（1）在性能⽅⾯，引⼊ CDN 的作⽤在于： ⽤户收到的内容来⾃最近的数据中⼼，延迟更低，内容加载更快，部分资源请求分配给了 CDN，减少了服务器的负载。</p><p>（2）在安全⽅⾯，CDN 有助于防御 DDoS、MITM 等⽹络攻击： 针对 DDoS：通过监控分析异常流量，限制其请求频率 针对 MITM：从源服务器到 CDN 节点到 ISP（Internet Service Provider），全链路 HTTPS 通信 除此之外，CDN 作为⼀种基础的云服务，同样具有资源托管、按需扩展（能够应对流量⾼峰）等⽅⾯的 优势。</p><h2 id="8-浏览器状态码"><a href="#8-浏览器状态码" class="headerlink" title="8. 浏览器状态码"></a>8. 浏览器状态码</h2><p><img src="/img/articles/image-20230401170135854.png" alt=""></p><p><strong>1xx</strong></p><p>100：（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</p><p>101：（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</p><p>102：由 WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</p><p><strong>2XX</strong></p><p>200：（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</p><p>201：（已创建） 请求成功并且服务器创建了新的资源。</p><p>202：（已接受） 服务器已接受请求，但尚未处理。</p><p>203：（非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</p><p>204：（无内容） 服务器成功处理了请求，但没有返回任何内容。</p><p>205：（重置内容） 服务器成功处理了请求，但没有返回任何内容。</p><p>206：（部分内容） 服务器成功处理了部分 GET 请求。</p><p>208：（已经报告）一个 DAV 的绑定成员被前一个请求枚举，并且没有被再一次包括。</p><p>226：（IM Used）服务器已经满足了请求所要的资源，并且响应是一个或者多个实例操作应用于当前实例的结果。</p><p><strong>3XX</strong></p><p>300：（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</p><p>301：（<strong>永久移动</strong>） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</p><p>302：（<strong>临时移动</strong>） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>303：（<strong>查看其他位置</strong>） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</p><p>304：（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</p><p>305：（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</p><p>307：（<strong>临时重定向</strong>） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>308：（永久转移）这个请求和以后的请求都应该被另一个 URI 地址重新发送。307、308 和 302、301 有相同的表现，但是不允许 HTTP 方法改变。例如，请求表单到一个永久转移的资源将会继续顺利地执行。</p><p><strong>4XX</strong></p><p>400:（错误请求) 服务器不理解请求的语法。</p><p>401：(未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p><p>402：该状态码是为了将来可能的需求而预留的。</p><p>403：（禁止) 服务器拒绝请求。</p><p>404：（未找到) 服务器找不到请求的网页。</p><p><strong>5XX</strong></p><p>500：（服务器内部错误） 服务器遇到错误，无法完成请求。</p><p>501：（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</p><p>502：（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</p><p>503：（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</p><p>504：（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p><p>505：（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p><p>200 表示服务器<strong>响应成功</strong></p><p>301 代表的是<strong>永久性的重定向</strong></p><p>302 代表<strong>临时跳转</strong>，URL 地址 A 可以向 URL 地址 B 上跳转</p><p>304 可以告诉客户端<strong>请求资源成功</strong></p><p>403 代表请求的服务器资源<strong>权限不够</strong></p><p>404 代表服务器上<strong>没有该资源</strong></p><p>500 代表<strong>程序错误</strong></p><h2 id="9-get-和-post-的区别"><a href="#9-get-和-post-的区别" class="headerlink" title="9. get 和 post 的区别"></a>9. get 和 post 的区别</h2><p><strong>本质区别：</strong>GET 是从服务器上<strong>获得数据</strong>；POST 是向服务器<strong>传递数据</strong></p><p><strong>数据传输上：</strong></p><p>get，通过拼接 url 进行传递参数；</p><p>post，通过 body 体传输参数</p><p><strong>缓存性：</strong></p><p>get 请求是可以缓存的</p><p>post 请求不可以缓存</p><p><strong>后退页面的反应：</strong></p><p>get 请求页面后退时，不产生影响</p><p>post 请求页面后退时，会重新提交请求</p><p><strong>大小限制</strong></p><p>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有</p><h2 id="10-浏览器渲染流程"><a href="#10-浏览器渲染流程" class="headerlink" title="10. 浏览器渲染流程"></a>10. 浏览器渲染流程</h2><p><img src="/img/articles/image-20230401204636208.png" alt=""></p><p>1、解析 html 文件，生成 dom 树，并行下载 css/js/img 文件</p><p>2、css 下载完成后，生成 cssom 树</p><p>3、根据 dom 树和 css 树，生成 render 树</p><p>4、重排：计算各元素的位置和大小</p><p>5、重绘：将计算的结果渲染到页面上</p><p><img src="/img/articles/image-20230401203143141.png" alt=""></p><p>（js 执行会阻塞 DOM 树的解析和渲染），所以可以加上 defer 和 async</p><p>正常情况下，当浏览器在解析 HTML 源文件时如果遇到外部的 script，那么解析过程会暂停，并发送请求来下载 script 文件，只有 script 完全下载并执行后才会继续执行 DOM 解析。</p><p>defer(延期、推迟)</p><p>让 js 脚本在文档解析完成后才执行，DOMContentLoaded 之前执行</p><p><img src="/img/articles/image-20230401204044605.png" alt=""></p><p>ansyc(异步)</p><p>js 脚本和浏览器的渲染是异步执行的</p><ul><li>css 加载不会阻塞 DOM 树的解析</li><li>css 加载会阻塞 DOM 树的渲染</li><li>css 加载会阻塞后面 js 语句的执行 原因（由于 js 可能会操作之前的 Dom 节点和 css 样式，因此浏览器会维持 html 中 css 和 js 的顺序，因此，样式表会在后面的 js 执行前先加载执行完毕。所以 css 会阻塞后面 js 的执行。）</li></ul><p>css 加载会不会阻塞 js 的加载？（不会）</p><p>css 加载会不会阻塞 js 的执行？（会）</p><p>css 加载会不会阻塞 DOM 的解析？（不会）</p><p>css 加载会不会阻塞 DOM 的渲染？（会）</p><p>js 加载会不会阻塞 DOM 的解析？（会）</p><p>js 加载会不会阻塞 DOM 的渲染？（会）</p><p><strong>DOMContentLoaded 与 onload 区别</strong></p><p>1、 <code>onload</code> 页面的所有资源都加载完成才会触发，这些资源包括 css、js、图片视频等。</p><p>2、当 <code>DOMContentLoaded</code> 事件触发时，仅当 DOM 加载完成，不包括样式表，图片，flash。</p>]]></content>
      
      
      <categories>
          
          <category> computer internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三 Git</title>
      <link href="/2022/08/10/3/"/>
      <url>/2022/08/10/3/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><strong>上传到github</strong>先git init, git add . ,git commit -m ‘ ‘, 再关联远程库</p><p>Git 中的三个<strong>区域</strong>：工作区、暂存区、Git 仓库。</p><p>工作区：处理工作的区域</p><p>暂存区：已完成的工作的临时存放区域，等待被提交</p><p>Git 仓库：最终的存放区域</p><p>Git 中的三种<strong>状态</strong>：已修改 modified 已暂存 staged 已提交 committed</p><p><strong>已修改</strong>：表示修改了文件，但还没将修改的结果放到暂存区。</p><p><strong>已暂存</strong>：表示对已修改文件的当前 版本做了标记，使之包含 在下次提交的列表中。</p><p><strong>已提交</strong>：表示文件已经安全地保存 在本地的 Git 仓库中。</p><p>注意：</p><p>⚫ 工作区的文件被修改了，但还没有放到暂存区，就是已修改状态。</p><p>⚫ 如果文件已修改并放入暂存区，就属于已暂存状态。</p><p>⚫ 如果 Git 仓库中保存着特定版本的文件，就属于已提交状态。</p><h2 id="Git的基本操作"><a href="#Git的基本操作" class="headerlink" title="Git的基本操作"></a>Git的基本操作</h2><ol><li><p>git init 命令会创建一个名为 .git 的隐藏目录，这个 .git 目录就是当前项目的 Git 仓库，里面包含了初始的必要文件，这些文件是 Git 仓库的必要组成部分。</p></li><li><p>git add 开始跟踪一个文件，git add . 一次性将所有的新增和修改过的文件加入暂存区</p></li><li><p>git status 命令查看文件处于什么状态</p></li><li><p>git commit 命令进行提交, 其中 -m 选项后面是本次的提交消息，用来对提交的内容做进一步的描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;什么信息&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>跳过使用暂存区域</p></li></ol><p>Git 标准的工作流程是<strong>工作区 → 暂存区 → Git 仓库</strong>。Git 工作的流程简化为了<strong>工作区 → Git 仓库</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">&#x27;描述信息&#x27;</span></span><br></pre></td></tr></table></figure><ol><li><p>移除文件</p><p>从 Git 仓库中移除文件的方式有两种： </p><p>① 从 Git 仓库和工作区中同时移除对应的文件 </p><p>② 只从 Git 仓库中移除指定的文件，但保留工作区中对应的文件</p></li></ol><p><img src="/img/articles/image-20221025163441508.png" alt=""></p><h2 id="Git分支的概念"><a href="#Git分支的概念" class="headerlink" title="Git分支的概念"></a>Git分支的概念</h2><p>master 主分支</p><p>功能分支</p><ol><li><p>创建新分支       <strong>git branch 分支名称</strong>  </p><p>基于当前分支，创建一个新的分支，创建好分支后，当前位置还是在master分支上</p></li><li><p>切换分支     <strong>git checkout 分支名称</strong>     </p><p>可以切换到指定的分支上进行开发</p></li><li><p>分支的快速创建和切换  <strong>git checkout -b 分支名称</strong></p></li><li><p>合并分支   先切换到 master分支上，再运行 <strong>git merge 分支名称</strong> 命令，来合并功能分支</p><p>功能分支的代码开发测试完毕之后，可以使用命令，将完成后的代码合并到 master 主分支上</p></li><li><p>删除分支 <strong>git branch -d 分支名称</strong></p><p>当把功能分支的代码合并到 master 主分支上以后，就可以使用命令，删除对应的功能分支</p></li></ol><p>​    6、git remote prune origin 清理本地仓库中与远程仓库中origin关联的已经不存在的分支引用</p><h2 id="远程分支操作"><a href="#远程分支操作" class="headerlink" title="远程分支操作"></a>远程分支操作</h2><ol><li>将本地分支推送到远程仓库</li></ol><p>​        如果是第一次将本地分支推送到远程仓库，需要运行如下的命令：<br><img src="/img/articles/image-20221025164401144.png" alt=""></p><p>gitlab的操作，git pull origin 分支名</p><ol><li><p>查看远程仓库中所有的分支列表</p><p>通过如下的命令，可以查看远程仓库中，所有的分支列表的信息：<br><img src="/img/articles/image-20221025164457908.png" alt=""></p></li></ol><ol><li>跟踪分支</li></ol><p>​        跟踪分支指的是：从远程仓库中，把远程分支下载到本地仓库中。需要运行的命令如下：<br><img src="/img/articles/image-20221025164539512.png" alt=""></p><ol><li><p>拉取远程分支的最新的代码</p><p>首先切换到本地分支</p><p>git pull origin 远程分支名</p><p>可以使用如下的命令，把远程分支最新的代码下载到本地对应的分支中：<br><img src="/img/articles/image-20221025164618940.png" alt=""></p></li></ol><ol><li><p>删除远程分支</p><p>可以使用如下的命令，删除远程仓库中指定的分支：<br><img src="/img/articles/image-20221025164652215.png" alt=""></p></li><li><p>合并分支冲突</p></li></ol><p>如果在两个不同的分支中，对同一个文件进行了不同的修改，Git 就没法干净的合并它们。 此时，我们需要打开 这些包含冲突的文件然后手动解决冲突。、</p><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>git init</p><p>然后git clone +url</p><p>如果连接不上就</p><p><a href="https://blog.csdn.net/greatcoder/article/details/126138230">https://blog.csdn.net/greatcoder/article/details/126138230</a></p><p>git clone <a href="https://ghproxy.com/+github网站地址">https://ghproxy.com/+github网站地址</a></p><p>就比如 git clone <a href="https://ghproxy.com/https://github.com/HaogegeShy/jingdong.git">https://ghproxy.com/https://github.com/HaogegeShy/jingdong.git</a></p><h2 id="git问题error-remote-origin-already-exists"><a href="#git问题error-remote-origin-already-exists" class="headerlink" title="git问题error: remote origin already exists"></a>git问题error: remote origin already exists</h2><p><a href="https://blog.csdn.net/qq_39208536/article/details/125231265">https://blog.csdn.net/qq_39208536/article/details/125231265</a></p><p>如果你clone下来一个别人的仓库，在此基础上完成你的代码，推送到自己的仓库可能遇到如下问题：<br>error: remote origin already exists.表示远程仓库已存在。<br>因此你要进行以下操作：<br>1、先输入git remote rm origin 删除关联的origin的远程库<br>2、关联自己的仓库 git remote add origin <a href="https://gitee.com/xxxxxx.git">https://gitee.com/xxxxxx.git</a><br>3、最后git push origin master，这样就推送到自己的仓库了。</p><h2 id="git代码提交到远程仓库时"><a href="#git代码提交到远程仓库时" class="headerlink" title="git代码提交到远程仓库时"></a>git代码提交到远程仓库时</h2><p>选用ssh的方式</p><h2 id="git-rebase和git-merge的区别"><a href="#git-rebase和git-merge的区别" class="headerlink" title="git rebase和git merge的区别"></a>git rebase和git merge的区别</h2><p>1、rebase变基，把当前的commit放到公共分支的最后面，merge把当前的commit和公共分支合并在一起，会产生一个合并的commit；</p><p>2、用merge命令解决完冲突后会产生一个commit，而用rebase命令解决完冲突后不会产生额外的commit。</p><p>merge中fast-forward 不会产生commit提交，—no-ff 会产生commit提交</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二 VUE底层原理</title>
      <link href="/2022/08/05/2/"/>
      <url>/2022/08/05/2/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-原理"><a href="#vue-原理" class="headerlink" title="vue 原理"></a>vue 原理</h1><h2 id="1、mvvm"><a href="#1、mvvm" class="headerlink" title="1、mvvm"></a>1、mvvm</h2><ul><li>M：模型 Model —-&gt;也就是 data 中的数据</li><li>V：视图 View —-&gt;也就是 dom</li><li>VM：视图模型 ViewModel —-&gt;也就是 Vue 实例（vm）</li></ul><p><img src="/img/articles/image-20230521163900590.png" alt=""></p><h2 id="2、vue-响应式原理"><a href="#2、vue-响应式原理" class="headerlink" title="2、vue 响应式原理"></a>2、vue 响应式原理</h2><h3 id="核心-api-object-defineProperty"><a href="#核心-api-object-defineProperty" class="headerlink" title="核心 api object.defineProperty"></a>核心 api object.defineProperty</h3><p><img src="/img/articles/image-20230521164959631.png" alt=""></p><p>vue 响应式也叫作数据双向绑定，大致原理阐述：</p><p>首先我们需要通过 Object.defineProperty()方法把数据(data)设置为 getter 和 setter 的访问形式，这样我们就可以在数据被修改时在 setter 方法设置监视修改页面信息，也就是说每当数据被修改，就会触发对应的 set 方法，然后我们可以在 set 方法中去调用操作 dom 的方法。</p><p>此外，如果页面有 input 用 v-model 绑定数据，我们需要在这种绑定了 data 的 input 元素上添加监听，添加 input 事件监听，每当 input 事件被触发时，就修改对应的 data</p><p>原文链接：<a href="https://blog.csdn.net/weixin_48181168/article/details/120158346">https://blog.csdn.net/weixin_48181168/article/details/120158346</a></p><p><img src="/img/articles/image-20230521192401756.png" alt=""></p><h3 id="vue3-启用-proxy"><a href="#vue3-启用-proxy" class="headerlink" title="vue3 启用 proxy"></a><strong>vue3 启用 proxy</strong></h3><p><a href="https://blog.csdn.net/pagnzong/article/details/120389514">https://blog.csdn.net/pagnzong/article/details/120389514</a></p><p>代码</p><p><img src="/img/articles/image-20230522155235201.png" alt=""></p><h3 id="proxy-和-object-defineProperty-响应式的对比"><a href="#proxy-和-object-defineProperty-响应式的对比" class="headerlink" title="proxy 和 object.defineProperty 响应式的对比"></a>proxy 和 object.defineProperty 响应式的对比</h3><p>vue2 响应式的缺点：</p><ul><li>检测不到对象属性的添加和删除 （需要使用 vue.set, vue.delete）</li><li>数组<code>API</code>方法无法监听到 (需要特殊处理)</li><li>深度监听需要递归到底，造成性能问题</li></ul><p>proxy 解决的问题</p><ul><li>克服了 vue2 响应式的问题</li><li>缺点：没有兼容 ie 等其他浏览器，无法实现 polyfill</li></ul><h2 id="3、虚拟-dom-和-diff-算法和-react-diff-的区别"><a href="#3、虚拟-dom-和-diff-算法和-react-diff-的区别" class="headerlink" title="3、虚拟 dom 和 diff 算法和 react diff 的区别"></a>3、虚拟 dom 和 diff 算法和 react diff 的区别</h2><p>用 JS 模拟 DOM 结构（vnode）<br>增量更新： 新旧 vnode 对比，得出最小的更新范围，最后更新 DOM</p><p>数据驱动视图的模式下，有效控制 DOM 操作</p><p><img src="/img/articles/image-20230521193406678.png" alt=""></p><p>diff 算法</p><ul><li><p>当数据发生改变时，订阅者<code>watcher</code>就会调用<code>patch</code>给真实的<code>DOM</code>打补丁</p></li><li><p>通过<code>isSameVnode</code>进行判断，相同则调用<code>patchVnode</code>方法</p></li><li><p>```<br>patchVnode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  做了以下操作：</span><br><span class="line"></span><br><span class="line">  - 找到对应的真实`dom`，称为`el`</span><br><span class="line">  - 如果都有都有文本节点且不相等，将`el`文本节点设置为`Vnode`的文本节点</span><br><span class="line">  - 如果`oldVnode`有子节点而`VNode`没有，则删除`el`子节点</span><br><span class="line">  - 如果`oldVnode`没有子节点而`VNode`有，则将`VNode`的子节点真实化后添加到`el`</span><br><span class="line">  - 如果两者都有子节点，则执行`updateChildren`函数比较子节点</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  updateChildren</span><br></pre></td></tr></table></figure><p>主要做了以下操作：</p><ul><li>设置新旧<code>VNode</code>的头尾指针</li><li>新旧头尾指针进行比较，循环向中间靠拢，根据情况调用<code>patchVnode</code>进行<code>patch</code>重复流程、调用<code>createElem</code>创建一个新节点，从哈希表寻找 <code>key</code>一致的<code>VNode</code> 节点再分情况操作</li></ul></li></ul><p><strong>相同点：</strong><br>Vue 和 react 的 diff 算法，都是不进行跨层级比较，只做同级比较</p><p><strong>不同点：</strong></p><ol><li>vue 会在 patch 函数中给被操作的节点打补丁（patchflag），在 diff 的时候更清晰</li><li>vue 对比节点，当节点元素类型相同，但是 className 不同时，认为是不同类型的元素，删除重新创建；而 react 则认为是同类型节点，进行修改操作</li><li>diff 策略，vue 的性能优于 react</li></ol><h2 id="4、模板编译-template"><a href="#4、模板编译-template" class="headerlink" title="4、模板编译 template"></a>4、模板编译 template</h2><p>template-&gt;render-&gt;h-&gt;vdom-&gt;true dom</p><h2 id="5、vue-组件的渲染和更新流程"><a href="#5、vue-组件的渲染和更新流程" class="headerlink" title="5、vue 组件的渲染和更新流程"></a>5、vue 组件的渲染和更新流程</h2><p>初次渲染<br><img src="/img/articles/image-20230521212323764.png" alt=""></p><p>更新<br><img src="/img/articles/image-20230521212411230.png" alt=""></p><p>完整流程图<br><img src="/img/articles/image-20230521212545143.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一 React底层原理</title>
      <link href="/2022/07/30/1/"/>
      <url>/2022/07/30/1/</url>
      
        <content type="html"><![CDATA[<h1 id="React-底层原理"><a href="#React-底层原理" class="headerlink" title="React 底层原理"></a>React 底层原理</h1><p>至此我们介绍了 react 的理念，如何解决 cpu 和 io 的瓶颈，关键是实现异步可中断的更新</p><p>我们介绍了 react 源码架构（ui=fn(state)），从 scheduler 开始调度（根据过期事件判断优先级，时间分片），经过 render 阶段的深度优先遍历形成 effectList（中间会执行 reconcile|diff），交给 commit 处理真实节点（中间穿插生命周期和部分 hooks），而这些调度的过程都离不开 Fiber 的支撑，<strong>Fiber 是工作单元，也是节点优先级、更新 UpdateQueue、节点信息的载体</strong>，Fiber 双缓存则提供了对比前后节点更新的基础。我们还介绍了 jsx 是 React.createElement 的语法糖。Lane 模型则提供了更细粒度的优先级对比和计算，这一切都为 concurrent mode 提供了基础，在这之上变可以实现 Suspense 和 batchedUpdate（16、17 版本实现的逻辑不一样），context 的 valueStack 和 valueCursor 在整个架构中运行机制，最后介绍了新版事件系统，包括事件生产、监听和触发</p><h2 id="1-react-的架构"><a href="#1-react-的架构" class="headerlink" title="1. react 的架构"></a>1. react 的架构</h2><p><a href="https://juejin.cn/post/7211072055780573221#heading-0">https://juejin.cn/post/7211072055780573221#heading-0</a></p><p><a href="https://juejin.cn/post/6926432527980691470">https://juejin.cn/post/6926432527980691470</a></p><p>作为架构来说，之前<code>React15</code>的<code>Reconciler</code>采用递归的方式执行，数据保存在递归调用栈中，所以被称为<code>stack Reconciler</code>。<code>React16</code>的<code>Reconciler</code>基于<code>Fiber节点</code>实现，被称为<code>Fiber Reconciler</code>。</p><p>新版 React 架构分为三大部分：</p><ul><li>Scheduler 调度器： 排序优先级，让优先级高的任务先进行 reconcile</li><li>Reconciler 协调器：接受更新，创建虚拟 dom 树，找出哪些节点发生了改变，并打上不同的 effectTag</li><li>Renderer 渲染器：将 Reconciler 中打好标签的节点渲染到视图上</li></ul><p>Fiber 这种数据结构后，能完成哪些事情呢，</p><ul><li><strong>工作单元 任务分解</strong> ：Fiber 最重要的功能就是作为工作单元，保存原生节点或者组件节点对应信息（包括优先级），这些节点通过指针的形似形成 Fiber 树</li><li><strong>增量渲染</strong>：通过 jsx 对象和 current Fiber 的对比，生成最小的差异补丁，应用到真实节点上</li><li><strong>根据优先级暂停、继续、排列优先级</strong>：Fiber 节点上保存了优先级，能通过不同节点优先级的对比，达到任务的暂停、继续、排列优先级等能力，也为上层实现批量更新、Suspense 提供了基础</li><li><strong>保存状态：</strong>因为 Fiber 能保存状态和更新的信息，所以就能实现函数组件的状态更新，也就是 hooks</li><li><a href="https://songhaoyong.blogspot.com/2023/07/react.html">https://songhaoyong.blogspot.com/2023/07/react.html</a></li></ul><h2 id="2-render-阶段"><a href="#2-render-阶段" class="headerlink" title="2. render 阶段"></a>2. render 阶段</h2><p>render：Reconciler 工作的阶段被称为 render 阶段。因为在该阶段会调用组件的 render 方法</p><p>render 阶段的主要工作是构建 Fiber 树和生成 effectList</p><p>开始工作前会先找到 div#root 对应的<code>rootFiber，称为</code>hostRootFiber<code>，然后开始生成</code>wip Fiber 树<code>。 这个过程分为两个部分：beginWork</code>和 completeWork。 这是一个深度优先遍历的过程。<br><p class='p left green'>beginwork</p><br>主要的工作是创建或复用子 fiber 节点（同时涉及到 diff 算法，为结点打上 effectTags）</p><p>从根节点 rootFiber 开始，遍历到叶子节点，每次遍历到的节点都会执行 beginWork，并且传入当前 Fiber 节点，然后创建或复用它的子 Fiber 节点，并赋值给 workInProgress.child。</p><p class='p left red'>completework</p><p>主要工作是处理 fiber 的 props、创建 dom、创建 effectList</p><p>1、(处理 props 将变化的部分賦值给 workInProgerss.updateQueue)</p><p>2、mount 时 调用 createInstance 创建 dom，将后代 dom 节点插入刚创建的 dom 中</p><p>3、将 effectTag 的节点，加入到 effectList 中</p><p>当遍历到子节点后，会执行 completeWork 方法，执行完成之后会判断此节点的兄弟节点存不存在，如果存在就会为兄弟节点执行 completeWork，当全部兄弟节点执行完之后，会向上回到父节点执行 completeWork，直到 rootFiber。</p><p>shouldYiled 方法就是判断待处理的任务队列有没有优先级更高的任务，有的话就先处理那边的 fiber，这边的先暂停一下。</p><h2 id="3-commit-阶段"><a href="#3-commit-阶段" class="headerlink" title="3. commit 阶段"></a>3. commit 阶段</h2><p>commit：Renderer 工作的阶段被称为 commit 阶段。commit 阶段会把 render 阶段提交的信息渲染在页面上</p><p>遍历 render 阶段生成的 effectList，effectList 上的 Fiber 节点保存着对应的 props 变化。之后会遍历 effectList 进行对应的 dom 操作和生命周期、hooks 回调或销毁函数。</p><p><strong>commit 阶段</strong>的主要工作（即 Renderer 的工作流程）分为三部分：</p><ul><li>before mutation 阶段（执行 DOM 操作前）</li></ul><p>​ 这个阶段 DOM 节点还没有被渲染到界面上去，过程中会触发 <code>getSnapshotBeforeUpdate</code>，也会处理 <code>useEffect</code> 钩子相关的调度逻辑。</p><ul><li>mutation 阶段（执行 DOM 操作）</li></ul><p>​ 这个阶段负责 DOM 节点的渲染。在渲染过程中，会遍历 effectList，根据 effectTag 的不同，执行不同的 DOM 操作。</p><ul><li><p>layout 阶段（执行 DOM 操作后）</p><p>这个阶段处理 DOM 渲染完毕之后的收尾逻辑。比如调用 <code>componentDidMount/componentDidUpdate</code>，调用 <code>useLayoutEffect</code> 钩子函数的回调等。除了这些之外，它还会把 fiberRoot 的 current 指针指向 workInProgress Fiber 树。</p></li></ul><h2 id="4-render-函数"><a href="#4-render-函数" class="headerlink" title="4. render 函数"></a>4. render 函数</h2><p><strong>legacy 模式</strong></p><p>render 调用 legacyRenderSubtreeIntoContainer，作用是</p><p>1、创建 FiberRootNode 和 rootFiber 节点, （调用 createRootImpl，其会调用到 createFiberRoot 创建 fiberRootNode,然后调用 createHostRootFiber 创建 rootFiber）</p><p>2、调用 updateContainer 创建创建 Update 对象挂载到 updateQueue 的环形链表上，（然后执行 scheduleUpdateOnFiber 调用 performSyncWorkOnRoot 进入 render 阶段和 commit 阶段）</p><p><strong>concurrent 模式：</strong></p><p>调用 ReactDOMRoot.prototype.render 执行 updateContainer，调用 updateContainer 创建创建 Update 对象挂载到 updateQueue 的环形链表上，（然后 scheduleUpdateOnFiber 异步调度 performConcurrentWorkOnRoot 进入 render 阶段和 commit 阶段）</p><h2 id="5-fiber"><a href="#5-fiber" class="headerlink" title="5. fiber"></a>5. fiber</h2><p>Fiber 是一个 js 对象，能承载节点信息、优先级、updateQueue，同时它还是一个工作单元。</p><ul><li><strong>工作单元 任务分解</strong> ：Fiber 最重要的功能就是作为工作单元，保存原生节点或者组件节点对应信息（包括优先级），这些节点通过指针的形似形成 Fiber 树</li><li><strong>增量渲染</strong>：通过 jsx 对象和 current Fiber 的对比，生成最小的差异补丁，应用到真实节点上。（<code>fiber</code>将<code>react</code>中的渲染任务拆分到每一帧）</li><li><strong>根据优先级暂停、继续、排列优先级</strong>：Fiber 节点上保存了优先级，能通过不同节点优先级的对比，达到任务的暂停、继续、排列优先级等能力，也为上层实现批量更新、Suspense 提供了基础</li><li><strong>保存状态：</strong>因为 Fiber 能保存状态和更新的信息，所以就能实现函数组件的状态更新，也就是 hooks</li></ul><h2 id="6-hooks-的实现原理"><a href="#6-hooks-的实现原理" class="headerlink" title="6. hooks 的实现原理"></a>6. hooks 的实现原理</h2><p><strong>在函数式组件中，hooks 的实现就是基于 fiber 的，多个 hook 会形成 hook 链表，保存在 Fiber 的 memoizedState 的上</strong>。hook 不能写在条件判断中正因为 hook 会按顺序存储在链表中，如果 hook 写在条件判断中，就没法保持链表的顺序，会造成乱序。</p><p>hook 调用入口</p><p>在 hook 源码中 hook 存在于 Dispatcher 中，Dispatcher 就是一个对象，不同 hook 调用的函数不一样，全局变量 ReactCurrentDispatcher.current 会根据是 mount 还是 update 赋值为 HooksDispatcherOnMount 或 HooksDispatcherOnUpdate。</p><p>usestate 的工作原理</p><p>useState 分为 onMount 和 upDate 两种情况，通过全局变量 ReactCurrentDispatcher.current 来判断。</p><p>onMount 时，hook.memoizedState 记录初始的值</p><p>update 更新时：</p><p>其中 hooks 的<code>memoizedState</code>是用来记录这个<code>useState</code>应该返回的结果的，而<code>next</code>指向的是下一次<code>useState</code>对应的`Hook 对象。</p><p>memoizedState 装着 state，而 dispatchAction 就是 setState</p><p>dispatchAction 创建新的 update 对象，将这些更新对象放到 hook.queue.pending 的环形链表中，最后重新渲染 app</p><p>hooks 的数据结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">hook</span>: <span class="title class_">Hook</span> = &#123;</span><br><span class="line">  <span class="attr">memoizedState</span>: <span class="literal">null</span>,<span class="comment">//对于不同hook，有不同的值</span></span><br><span class="line">  <span class="attr">baseState</span>: <span class="literal">null</span>,<span class="comment">//初始state</span></span><br><span class="line">  <span class="attr">baseQueue</span>: <span class="literal">null</span>,<span class="comment">//初始queue队列</span></span><br><span class="line">  <span class="attr">queue</span>: <span class="literal">null</span> <span class="comment">// &#123; pending:这是一个链表储存着update&#125;,//需要更新的update</span></span><br><span class="line">  <span class="attr">next</span>: <span class="literal">null</span>,<span class="comment">//下一个hook</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7、react-的状态更新流程"><a href="#7、react-的状态更新流程" class="headerlink" title="7、react 的状态更新流程"></a>7、react 的状态更新流程</h2><p><img src="/img/articles/image-20230511104437245.png" alt=""><br><!-- <img src="/source/img/articles/image-20230511104437245.png" alt="image-20230511104437245" style="zoom:150%;" /> --></p><p>触发更新后，会在函数 createUpdate 中创建 update 更新，并将其加入到 updateQueue 中，会从触发更新的节点开始向上遍历到 rootFiber，遍历的过程会处理节点的优先级。然后根据优先级调度 render 阶段的入口函数。最后进行 render 阶段和 commit 阶段。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
