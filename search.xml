<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>十六 算法-几种排序</title>
      <link href="/2023/04/30/16/"/>
      <url>/2023/04/30/16/</url>
      
        <content type="html"><![CDATA[<h2 id="几种排序"><a href="#几种排序" class="headerlink" title="几种排序"></a>几种排序</h2><!-- ![image-20230215103226860](img/image-20230215103226860.png) --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230215103226860.png" style="width:80%;"/></div></div><p><strong>稳定性</strong>：保证排序前两个相等的数据其在序列中的先后位置顺序与排序后它们两个先后位置顺序相同</p><!-- ![image-20230217153452930](img/image-20230217153452930.png) --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230217153452930.png" style="width:80%;"/></div></div><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><p>冒泡排序算法的原理如下：</p><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</p><p>针对所有的元素重复以上的步骤，除了最后一个。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">      <span class="comment">//每轮循环都从最后一个元素开始 比较并交换 一次循环会把最小的数顶到最上面</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;nums.<span class="property">length</span>-<span class="number">1</span>-i;j++)&#123;<span class="comment">// 控制比较的次数</span></span><br><span class="line">          <span class="comment">// 交换</span></span><br><span class="line">          <span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">let</span> temp=nums[j+<span class="number">1</span>]</span><br><span class="line">            nums[j+<span class="number">1</span>]=nums[j]</span><br><span class="line">            nums[j]=temp</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//test</span></span><br><span class="line">    nums = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>];</span><br><span class="line">    <span class="title function_">bubbleSort</span>(nums);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(nums);</span><br></pre></td></tr></table></figure><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h3><p>第一次从待排序的数据元素中选出最小的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。</p><p>算法思路：</p><p>1）假设未排序序列的第一个是最小值，记下该元素的位置，从后往前比较<br>2）找出最小的一个元素<br>3）然后将最小元素与记录元素交换位置<br>4）重复第二，三个步骤，直到找完未排序的部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectSort</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="comment">//和冒泡排序类似，但是并不在每次比较后交换 而是记录最小值(初识最小值为nums[i]) 最后再交换一次 </span></span><br><span class="line">  <span class="comment">//每次循环也是从最后开始 把最小元素放到最顶部</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123; <span class="comment">//n -1循环</span></span><br><span class="line">    <span class="keyword">let</span> index=i</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=arr.<span class="property">length</span>-<span class="number">1</span>;j&gt;i;j--)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j]&lt;arr[index])&#123;</span><br><span class="line">        index=j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">    <span class="keyword">let</span> temp=arr[i]</span><br><span class="line">    arr[i]=arr[index]</span><br><span class="line">    arr[index]=temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr=[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line"><span class="title function_">selectSort</span>(arr)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br></pre></td></tr></table></figure><h3 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3. 直接插入排序"></a>3. 直接插入排序</h3><p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><strong>算法描述：</strong></p><p>一般来说，插入排序都采用 in-place 在数组上实现：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素a，在已经排序的元素序列中从后向前扫描；</li><li>如果a比之前的元素小，就交换位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertionSort</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="comment">//插入排序 从第二个元素开始 把元素插入到合适的位置 每次比较（除了最后一次）都要交换</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j]&lt;arr[j-<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[j-<span class="number">1</span>]</span><br><span class="line">        arr[j-<span class="number">1</span>]=arr[j]</span><br><span class="line">        arr[j]=temp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//test</span></span><br><span class="line">nums = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>];</span><br><span class="line"><span class="title function_">insertionSort</span>(nums);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nums);</span><br></pre></td></tr></table></figure><h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4. 快速排序"></a>4. 快速排序</h3><p>选择数组中的一个值作为基准(arr[0])，将数组中小于该值的数置于该数之前，大于该值的数置于该数之后，接着对该数前后的两个数组进行重复操作直至排序完成。</p><p>算法步骤：</p><p>1.定义一个函数，传入参数，判断这个参数的长度，如果长度是1，直接ruturn出去，如果是进入下一步。<br>2.将这个数组头部的值作为中位数，定义两个新的数组left，right，然后让原数组中剩余的数与这个中位数比较，比中位数小的放到left数组，比中位数大的放到right,然后再对这两个数组进行递归。<br>3.最后将arrleft, 中位数，arrright拼接，return出去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quckSort</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr.<span class="property">length</span>&lt;=<span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">let</span> mid=arr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> left=[], right=[]</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i]&lt;mid) left.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    <span class="keyword">else</span> right.<span class="title function_">push</span>(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="title function_">quckSort</span>(left),mid,...<span class="title function_">quckSort</span>(right)]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr=[<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">quckSort</span>(arr))</span><br></pre></td></tr></table></figure><h3 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5. 堆排序"></a>5. 堆排序</h3><p>一、什么是堆<br>堆首先是一个完全二叉树，堆分为大顶堆和小顶堆</p><p>大顶堆：每个节点的值大于或等于其左右孩子节点的值，称为大顶堆。<br>小顶堆：每个节点的值小于或等于其左右孩子节点的值。</p><p>注意：每个节点的左右孩子节点的大小关系并没有限定。</p><!-- <img src="img/image-20230216201523994.png" alt="image-20230216201523994" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230216201523994.png" style="width:80%;"/></div></div><p><strong>堆排序基本思想</strong></p><p>以大顶堆为例，算法步骤如下：</p><p>1、首先将待排序序列构建成一个大顶堆(<strong>存入数组中</strong>)，那么这时，整个序列的最大值就是堆顶的根节点；</p><p>2、将堆顶元素与最后一个元素交换，那么末尾元素就存入了最大值；</p><p>3、将剩余的 n - 1个元素重新构建成一个大顶堆，重复上面的操作；</p><p>反复执行，就能得到一个有序序列了。</p><!-- 原文链接：https://blog.csdn.net/qq_48315043/article/details/121405814 --><div class="tag link"><a class="link-card" title="堆排序" href="https://blog.csdn.net/qq_48315043/article/details/121405814"><div class="left"><img src="/img/icon/wwwicon.png"/></div><div class="right"><p class="text">堆排序</p><p class="url">https://blog.csdn.net/qq_48315043/article/details/121405814</p></div></a></div><h3 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h3><p>归并排序使用<strong>分而治之</strong>的概念对给定的元素列表进行排序。它将问题分解为较小的子问题，直到它们变得足够简单以至可以直接解决为止。</p><p>归并排序，顾名思义，就是把两个已经排好序的数组进行归并，成为一个新排序好的序列。</p><!-- https://blog.csdn.net/weixin_46726346/article/details/115025135 --><div class="tag link"><a class="link-card" title="归并排序" href="https://blog.csdn.net/weixin_46726346/article/details/115025135"><div class="left"><img src="/img/icon/wwwicon.png"/></div><div class="right"><p class="text">归并排序</p><p class="url">https://blog.csdn.net/weixin_46726346/article/details/115025135</p></div></a></div><p>以下是归并排序的步骤：</p><p>1、将给定的列表分为两半（如果列表中的元素数为奇数，则使其大致相等）。</p><p>2、以相同的方式继续划分子数组，直到只剩下单个元素数组。</p><p>3、从单个元素数组开始，<strong>合并</strong>子数组，以便对每个合并的子数组进行排序。</p><p>4、重复第 3 步单元，直到最后得到一个排好序的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr.<span class="property">length</span>===<span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">      <span class="comment">// 将一个数组拆分为两个</span></span><br><span class="line">      <span class="keyword">let</span> mid=<span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span>/<span class="number">2</span>)</span><br><span class="line">      <span class="keyword">let</span> leftArr=arr.<span class="title function_">slice</span>(<span class="number">0</span>,mid)</span><br><span class="line">      <span class="keyword">let</span> rightArr=arr.<span class="title function_">slice</span>(mid)</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">mergeSort</span>(leftArr),<span class="title function_">mergeSort</span>(rightArr))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行归并 将两个有序的数组，归并为一个有序的数组</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">left,right</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> res=[]</span><br><span class="line">      <span class="keyword">while</span>(left.<span class="property">length</span>&gt;<span class="number">0</span>&amp;&amp;right.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>( left[<span class="number">0</span>]&lt;right[<span class="number">0</span>])&#123;</span><br><span class="line">          res.<span class="title function_">push</span>(left.<span class="title function_">shift</span>())</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          res.<span class="title function_">push</span>(right.<span class="title function_">shift</span>())</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res.<span class="title function_">concat</span>(left,right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//test</span></span><br><span class="line">    nums = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> res = <span class="title function_">mergeSort</span>(nums);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><h3 id="7-希尔排序"><a href="#7-希尔排序" class="headerlink" title="7. 希尔排序"></a>7. 希尔排序</h3><p>思想是指定一个间隔（增量）将待排序的元素进行分组，然后再对每一组进行排序，直到间隔（增量）减至1时，整个序列恰好被分成一组，（再进行直接插入排序）最后排成有序序列。</p><p>其中增量序列的选择是非常关键的，但通常我们取步长为 n/2（数组长度的一般）然后一直取半直到 1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shellSort</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> gap = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span>/<span class="number">2</span>);gap &gt; <span class="number">0</span>;gap = <span class="title class_">Math</span>.<span class="title function_">floor</span>(gap/<span class="number">2</span>))&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> i = gap;i &lt; arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">              <span class="keyword">let</span> j = i;</span><br><span class="line">              <span class="keyword">let</span> tmp = arr[j];</span><br><span class="line">              <span class="keyword">if</span>(arr[j] &lt; arr[j-gap])&#123;</span><br><span class="line">                  <span class="comment">// 如果同一组中 前数大于后数，则交换他们</span></span><br><span class="line">                  <span class="keyword">while</span>(j - gap &gt;= <span class="number">0</span> &amp;&amp; arr[j-gap] &gt; tmp)&#123;</span><br><span class="line">                      arr[j] = arr[j-gap];</span><br><span class="line">                      j = j-gap;</span><br><span class="line">                  &#125;</span><br><span class="line">                  arr[j] = tmp;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">let</span> arr = [<span class="number">9</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>];</span><br><span class="line">  <span class="title function_">shellSort</span>(arr)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure><!-- https://blog.csdn.net/weixin_51445423/article/details/124572331 --><div class="tag link"><a class="link-card" title="希尔排序" href="https://blog.csdn.net/weixin_51445423/article/details/124572331"><div class="left"><img src="/img/icon/wwwicon.png"/></div><div class="right"><p class="text">希尔排序</p><p class="url">https://blog.csdn.net/weixin_51445423/article/details/124572331</p></div></a></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十五 算法-回溯算法</title>
      <link href="/2023/04/20/15/"/>
      <url>/2023/04/20/15/</url>
      
        <content type="html"><![CDATA[<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h3 id="1-组合"><a href="#1-组合" class="headerlink" title="1. 组合"></a>1. 组合</h3><p>77</p><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围</strong>。</p><p><strong>图中可以发现n相当于树的宽度，k相当于树的深度</strong>。</p><p>剪枝优化：</p><p>接下来看一下优化过程如下：</p><p>已经选择的元素个数：path.size();</p><p>还需要的元素个数为: k - path.size();</p><p>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</p><p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = startIndex; i &lt;= n; i++) </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> combine = <span class="keyword">function</span>(<span class="params">n, k</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = []</span><br><span class="line"><span class="keyword">let</span> path=[]</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">combineHelper</span> = (<span class="params">n, k, startIndex</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (path.<span class="property">length</span> === k) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>([...path]) <span class="comment">//这里拷贝一下</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex; i &lt;= n; ++i) &#123; <span class="comment">//这里进行剪枝操作 i &lt;= n - (k - path.length) + 1</span></span><br><span class="line">    path.<span class="title function_">push</span>(i)</span><br><span class="line">    <span class="title function_">combineHelper</span>(n, k, i + <span class="number">1</span>)</span><br><span class="line">    path.<span class="title function_">pop</span>() <span class="comment">// 回溯</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">combineHelper</span>(n, k, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-组合总和"><a href="#2-组合总和" class="headerlink" title="2. 组合总和|||"></a>2. 组合总和|||</h3><p>216</p><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong> </li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p>本题就是在[1,2,3,4,5,6,7,8,9]这个集合中找到和为n的k个数的组合。</p><p>相对于77. 组合，无非就是多了一个限制，本题是要找到和为n的k个数的组合，而整个集合已经是固定的了[1,…,9]。</p><p>想到这一点了，做过77. 组合之后，本题是简单一些了。</p><p>本题k相当于树的深度，9（因为整个集合就是9个数）就是树的宽度。</p><p>例如 k = 2，n = 4的话，就是在集合[1,2,3,4,5,6,7,8,9]中求 k（个数） = 2, n（和） = 4的组合。</p><p><img src="img/image-20230307202923321.png" alt="image-20230307202923321" style="zoom:80%;" /></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum3 = <span class="keyword">function</span>(<span class="params">k, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> targetSum=n</span><br><span class="line">    <span class="keyword">let</span> path=[]</span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backTraval</span>=(<span class="params">sum,startIndex</span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;targetSum) <span class="keyword">return</span> <span class="comment">// 剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="property">length</span>==k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(targetSum==sum)&#123;</span><br><span class="line">                res.<span class="title function_">push</span>([...path])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=startIndex;i&lt;=<span class="number">9</span>-(k-path.<span class="property">length</span>)+<span class="number">1</span>;i++)&#123; <span class="comment">// 剪枝</span></span><br><span class="line">            sum+=i</span><br><span class="line">            path.<span class="title function_">push</span>(i)</span><br><span class="line">            <span class="title function_">backTraval</span>(sum,i+<span class="number">1</span>)</span><br><span class="line">            sum-=i</span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTraval</span>(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十四 算法-二叉树</title>
      <link href="/2023/04/15/14/"/>
      <url>/2023/04/15/14/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TreeNode</span>(<span class="params">val, left, right</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = (val===<span class="literal">undefined</span> ? <span class="number">0</span> : val)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = (left===<span class="literal">undefined</span> ? <span class="literal">null</span> : left)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = (right===<span class="literal">undefined</span> ? <span class="literal">null</span> : right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-二叉树的前-中-后序遍历"><a href="#1-二叉树的前-中-后序遍历" class="headerlink" title="1. 二叉树的前/中/后序遍历"></a>1. 二叉树的前/中/后序遍历</h3><p><strong>递归法</strong></p><p>这里帮助大家确定下来递归算法的三个要素。每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p></li><li><p><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p></li><li><p><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p></li></ol><p>144 前序遍历</p><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法 一</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result=[]</span><br><span class="line">    <span class="title function_">dfs</span>(root,result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dfs</span>=(<span class="params">root,result</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="title function_">push</span>(root.<span class="property">val</span>) <span class="comment">// 只需要调整它的位置 就能确定是前中后序遍历</span></span><br><span class="line">    <span class="title function_">dfs</span>(root.<span class="property">left</span>,result)</span><br><span class="line">    <span class="title function_">dfs</span>(root.<span class="property">right</span>,result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法 二</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getMinimumDifference = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="title class_">Infinity</span></span><br><span class="line">    <span class="keyword">let</span> pre=<span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">traversal</span>=(<span class="params">cur</span>)=&gt;&#123;</span><br><span class="line">        <span class="comment">// 确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(!cur) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 确定单层递归逻辑</span></span><br><span class="line">        <span class="title function_">traversal</span>(cur.<span class="property">left</span>)</span><br><span class="line">        <span class="keyword">if</span>(pre)&#123;</span><br><span class="line">            res=<span class="title class_">Math</span>.<span class="title function_">min</span>(res,cur.<span class="property">val</span>-pre.<span class="property">val</span>) <span class="comment">// 中序遍历时 进行逻辑处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre=cur</span><br><span class="line">        <span class="title function_">traversal</span>(cur.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">traversal</span>(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>94 中序遍历 </p><p>145 后序遍历</p><p><strong>迭代法</strong></p><p>为什么可以用迭代法（非递归的方式）来实现二叉树的前后中序遍历呢？</p><p>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><p>此时大家应该知道我们用栈也可以是实现二叉树的前后中序遍历了。</p><p>我们先看一下<strong>前序遍历</strong>。</p><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><p>再来看<strong>后序遍历</strong>，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序。</p><p><strong>中序遍历</strong></p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。</p><p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序迭代</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代法</span></span><br><span class="line">    <span class="keyword">let</span> stack=[]</span><br><span class="line">    <span class="keyword">let</span> result=[]</span><br><span class="line">    stack.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp=stack.<span class="title function_">pop</span>()</span><br><span class="line">        result.<span class="title function_">push</span>(temp.<span class="property">val</span>)</span><br><span class="line">        temp.<span class="property">right</span> &amp;&amp; stack.<span class="title function_">push</span>(temp.<span class="property">right</span>)</span><br><span class="line">        temp.<span class="property">left</span> &amp;&amp; stack.<span class="title function_">push</span>(temp.<span class="property">left</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序迭代</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> nums = [], stack = []</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> nums</span><br><span class="line">    stack.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> cur = stack.<span class="title function_">pop</span>()</span><br><span class="line">        <span class="comment">// 向前添加元素，构造反向顺序</span></span><br><span class="line">        nums.<span class="title function_">unshift</span>(cur.<span class="property">val</span>)</span><br><span class="line">        <span class="comment">// 与先序的左右顺序相反</span></span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="property">left</span>) stack.<span class="title function_">push</span>(cur.<span class="property">left</span>)</span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="property">right</span>) stack.<span class="title function_">push</span>(cur.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序迭代 比较难理解</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> stk = [];</span><br><span class="line">    <span class="keyword">while</span> (root || stk.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            stk.<span class="title function_">push</span>(root);</span><br><span class="line">            root = root.<span class="property">left</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stk.<span class="title function_">pop</span>();</span><br><span class="line">        res.<span class="title function_">push</span>(root.<span class="property">val</span>);</span><br><span class="line">        root = root.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-二叉树的层序遍历"><a href="#2-二叉树的层序遍历" class="headerlink" title="2. 二叉树的层序遍历"></a>2. 二叉树的层序遍历</h3><p>102</p><p>bfs广度优先遍历</p><p><strong>队列先进先出，符合一层一层遍历的逻辑</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/ 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</span><br><span class="line"><span class="comment">// 输入：root = [3,9,20,null,null,15,7]</span></span><br><span class="line"><span class="comment">// 输出：[[3],[9,20],[15,7]]</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">//二叉树的层序遍历</span></span><br><span class="line">    <span class="keyword">let</span> queue=[]</span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    queue.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> length=queue.<span class="property">length</span> <span class="comment">// 记录当前层级节点数</span></span><br><span class="line">        <span class="keyword">let</span> curNode=[]</span><br><span class="line">        <span class="keyword">while</span>(length--)&#123;</span><br><span class="line">            <span class="keyword">let</span> node=queue.<span class="title function_">shift</span>()</span><br><span class="line">            curNode.<span class="title function_">push</span>(node.<span class="property">val</span>) <span class="comment">//存放每一层的节点 </span></span><br><span class="line">            node.<span class="property">left</span> &amp;&amp; queue.<span class="title function_">push</span>(node.<span class="property">left</span>)  <span class="comment">// 存放当前层下一层的节点</span></span><br><span class="line">            node.<span class="property">right</span> &amp;&amp; queue.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="title function_">push</span>(curNode) <span class="comment">//把每一层的结果放到结果数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-翻转二叉树"><a href="#3-翻转二叉树" class="headerlink" title="3. 翻转二叉树"></a>3. 翻转二叉树</h3><p>226 简单难理解</p><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>解析</strong>:这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点 root\textit{root}root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 root\textit{root}root 为根节点的整棵子树的翻转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> right=<span class="title function_">invertTree</span>(root.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">const</span> left=<span class="title function_">invertTree</span>(root.<span class="property">left</span>)</span><br><span class="line">    root.<span class="property">left</span>=right</span><br><span class="line">    root.<span class="property">right</span>=left</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-对称二叉树"><a href="#4-对称二叉树" class="headerlink" title="4. 对称二叉树"></a>4. 对称二叉树</h3><p>101</p><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p>本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。</p><p>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</p><p>但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。</p><p>其实后序也可以理解为是一种回溯，当然这是题外话，讲回溯的时候会重点讲的。</p><p>递归三部曲</p><ol><li>确定递归函数的参数和返回值</li></ol><p>​    因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是</p><p>​    个树，参数自然也是左子树节点和右子树节点。</p><p>​    返回值自然是bool类型。</p><ol><li>确定终止条件</li></ol><p>要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。</p><p>节点为空的情况有：（注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点）</p><p>左节点为空，右节点不为空，不对称，return false<br>左不为空，右为空，不对称 return false<br>左右都为空，对称，返回true<br>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p><p>左右都不为空，比较节点数值，不相同就return false</p><ol><li><p>确定单层递归的逻辑</p><p>此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。</p><p>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。<br>比较内测是否对称，传入左节点的右孩子，右节点的左孩子。<br>如果左右都对称就返回true ，有一侧不对称就返回false 。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">//使用递归遍历左右子树 递归三部曲</span></span><br><span class="line">    <span class="keyword">if</span>(root===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">compareNode</span>(root.<span class="property">left</span>,root.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1. 确定递归的参数 root.left root.right和返回值true false </span></span><br><span class="line">    <span class="keyword">const</span> compareNode=<span class="keyword">function</span>(<span class="params">left,right</span>)&#123;</span><br><span class="line">        <span class="comment">//2. 确定终止条件 空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(left!==<span class="literal">null</span>&amp;&amp;right===<span class="literal">null</span>||left===<span class="literal">null</span>&amp;&amp;right!==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left===<span class="literal">null</span>&amp;&amp;right===<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left.<span class="property">val</span>!==right.<span class="property">val</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 确定单层递归逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">compareNode</span>(left.<span class="property">left</span>,right.<span class="property">right</span>)&amp;&amp;<span class="title function_">compareNode</span>(left.<span class="property">right</span>,right.<span class="property">left</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-二叉树的最大深度"><a href="#5-二叉树的最大深度" class="headerlink" title="5. 二叉树的最大深度"></a>5. 二叉树的最大深度</h3><p>104</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。</p><p>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）<br>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数后者节点数（取决于高度从0开始还是从1开始）<br>而根节点的高度就是二叉树的最大深度，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="comment">// 终止递归条件</span></span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定单层递归逻辑</span></span><br><span class="line">    <span class="keyword">let</span> leftHeight=<span class="title function_">maxDepth</span>(root.<span class="property">left</span>)</span><br><span class="line">    <span class="keyword">let</span> rightHeight=<span class="title function_">maxDepth</span>(root.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">let</span> height=<span class="number">1</span>+<span class="title class_">Math</span>.<span class="title function_">max</span>(leftHeight,rightHeight)</span><br><span class="line">    <span class="keyword">return</span> height</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-二叉树的最小深度"><a href="#6-二叉树的最小深度" class="headerlink" title="6. 二叉树的最小深度"></a>6. 二叉树的最小深度</h3><p>111</p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><p><strong>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</strong>，注意是<strong>叶子节点</strong>。</p><p>注意一个重点，不然容易陷入误区：</p><p>如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。</p><p>反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。 </p><p>最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 确定递归函数的参数和返回值</span></span><br><span class="line"><span class="keyword">var</span> minDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 2. 确定终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 确定单层递归逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">left</span>===<span class="literal">null</span>&amp;&amp;root.<span class="property">right</span>!==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="title function_">minDepth</span>(root.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">left</span>!==<span class="literal">null</span>&amp;&amp;root.<span class="property">right</span>===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="title function_">minDepth</span>(root.<span class="property">left</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+<span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="title function_">minDepth</span>(root.<span class="property">left</span>),<span class="title function_">minDepth</span>(root.<span class="property">right</span>))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-完全二叉树的节点个数"><a href="#7-完全二叉树的节点个数" class="headerlink" title="7. 完全二叉树的节点个数"></a>7. 完全二叉树的节点个数</h3><p>222</p><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><a href="https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2h</code> 个节点。</p><p>普通二叉树的解法 , 时间复杂度为O(n)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countNodes = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">countNodes</span>(root.<span class="property">left</span>)+<span class="title function_">countNodes</span>(root.<span class="property">right</span>)+<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完全二叉树</p><p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p><p>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。</p><p>对于情况二，分别递归左<strong><em>，和右</em></strong>，递归到某一深度一定会有左或者右为满二叉树，然后依然可以按照情况1来计算。</p><!-- <img src="C:\Users\Administrator\Desktop\前端\同步typora笔记\img\image-20230105150755150.png" alt="image-20230105150755150" style="zoom: 50%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230105150755150.png" style="width:80%;"/></div></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countNodes = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 确定终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否为满二叉树，如果是就采用2^深度-1,计算节点数</span></span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> node=root</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        left++</span><br><span class="line">        node=node.<span class="property">left</span></span><br><span class="line">    &#125;</span><br><span class="line">    node=root</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        right++</span><br><span class="line">        node=node.<span class="property">right</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> ** left)-<span class="number">1</span> <span class="comment">// ** 可以看做是Math.pow（x , y）的语法糖，其作用与Math.pow()一致</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定单层递归逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+<span class="title function_">countNodes</span>(root.<span class="property">left</span>)+<span class="title function_">countNodes</span>(root.<span class="property">right</span>)</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="8-平衡二叉树"><a href="#8-平衡二叉树" class="headerlink" title="8. 平衡二叉树"></a>8. 平衡二叉树</h3><p>110 易</p><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><p>解析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isBalanced = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getBalanced</span>=(<span class="params">root</span>)=&gt;&#123;</span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        <span class="comment">// 2. 确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 确定单层递归逻辑</span></span><br><span class="line">        <span class="keyword">let</span> rootLeft=<span class="title function_">getBalanced</span>(root.<span class="property">left</span>)</span><br><span class="line">        <span class="keyword">if</span>(rootLeft==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> rootRight=<span class="title function_">getBalanced</span>(root.<span class="property">right</span>)</span><br><span class="line">        <span class="keyword">if</span>(rootRight==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment">// 判断是否平衡，若不平衡返回-1，若平衡则返回最大高度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(rootLeft-rootRight)&gt;<span class="number">1</span> ? -<span class="number">1</span> :<span class="number">1</span>+ <span class="title class_">Math</span>.<span class="title function_">max</span>(rootLeft,rootRight)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  !(<span class="title function_">getBalanced</span>(root) === -<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="9-二叉树的所有路径"><a href="#9-二叉树的所有路径" class="headerlink" title="9. 二叉树的所有路径"></a>9. 二叉树的所有路径</h3><p>257 简单</p><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p>采用了回溯的算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> binaryTreePaths = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用的回溯算法</span></span><br><span class="line">    <span class="keyword">let</span> path=[] <span class="comment">// 保存每一条路径</span></span><br><span class="line">    <span class="keyword">let</span> res=[]  <span class="comment">// 保存所有路径</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span>=(<span class="params">root,path,res</span>)=&gt;&#123;</span><br><span class="line">        <span class="comment">// 先放入经过的节点</span></span><br><span class="line">        path.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">        <span class="comment">// 遇到叶子节点，就将路径推入结果</span></span><br><span class="line">        <span class="keyword">if</span>(!root.<span class="property">left</span>&amp;&amp;!root.<span class="property">right</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> temp=path</span><br><span class="line">            res.<span class="title function_">push</span>(temp.<span class="title function_">join</span>(<span class="string">&#x27;-&gt;&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 节点存在就遍历</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">left</span>)&#123;</span><br><span class="line">            <span class="title function_">dfs</span>(root.<span class="property">left</span>,path,res)</span><br><span class="line">            <span class="comment">// 遍历完后就实行回溯，吐出来遍历过的节点</span></span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">right</span>)&#123;</span><br><span class="line">            <span class="title function_">dfs</span>(root.<span class="property">right</span>,path,res)</span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>(root,path,res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 字符串作为参数传递,不符合引用数据类型的规则。即对传进来的值做修改后，不会影响原来的值。(正常情况下，引用数据类型在传递参数时，传的是地址，即形参实参指向同一地址，形参变化会导致实参也变化，但是string例外。)</span></span><br></pre></td></tr></table></figure><h3 id="10-左叶子之和"><a href="#10-左叶子之和" class="headerlink" title="10. 左叶子之和"></a>10. 左叶子之和</h3><p>404</p><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sumOfLeftLeaves = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span>=(<span class="params">root</span>)=&gt;&#123;</span><br><span class="line">        <span class="comment">// 确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单层递归逻辑</span></span><br><span class="line">        <span class="comment">// 在父节点处判断</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">left</span>&amp;&amp;!root.<span class="property">left</span>.<span class="property">left</span>&amp;&amp;!root.<span class="property">left</span>.<span class="property">right</span>)&#123;</span><br><span class="line">            sum+=root.<span class="property">left</span>.<span class="property">val</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">dfs</span>(root.<span class="property">left</span>,sum)</span><br><span class="line">        <span class="title function_">dfs</span>(root.<span class="property">right</span>,sum)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>(root)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="11-找树左下角的值"><a href="#11-找树左下角的值" class="headerlink" title="11. 找树左下角的值"></a>11. 找树左下角的值</h3><p>513</p><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广度优先搜索 层序遍历</span></span><br><span class="line"><span class="comment">//使用广度优先搜索遍历每一层的节点。在遍历一个节点时，需要先把它的非空右子节点放入队列，然后再把它的非空左子节点放入队列，这样才能保证从右到左遍历每一层的节点。广度优先搜索所遍历的最后一个节点的值就是最底层最左边节点的值。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ret=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> queue=[]</span><br><span class="line">    queue.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> curNode=queue.<span class="title function_">shift</span>()</span><br><span class="line">        curNode.<span class="property">right</span> &amp;&amp; queue.<span class="title function_">push</span>(curNode.<span class="property">right</span>)</span><br><span class="line">        curNode.<span class="property">left</span> &amp;&amp; queue.<span class="title function_">push</span>(curNode.<span class="property">left</span>)</span><br><span class="line">        ret=curNode.<span class="property">val</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 深度优先搜索 递归</span></span><br><span class="line"><span class="comment">// 递归版本：</span></span><br><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">//首先考虑递归遍历 前序遍历 找到最大深度的叶子节点即可</span></span><br><span class="line">    <span class="keyword">let</span> maxPath = <span class="number">0</span>,resNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 1. 确定递归函数的函数参数</span></span><br><span class="line">    <span class="keyword">const</span> dfsTree = <span class="keyword">function</span>(<span class="params">node,curPath</span>)&#123;</span><br><span class="line">    <span class="comment">// 2. 确定递归函数终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">left</span>===<span class="literal">null</span>&amp;&amp;node.<span class="property">right</span>===<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curPath&gt;maxPath)&#123;</span><br><span class="line">            maxPath = curPath;</span><br><span class="line">            resNode = node.<span class="property">val</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// return ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        node.<span class="property">left</span>&amp;&amp;<span class="title function_">dfsTree</span>(node.<span class="property">left</span>,curPath+<span class="number">1</span>);<span class="comment">// 这里其实有一个回溯的过程</span></span><br><span class="line">        node.<span class="property">right</span>&amp;&amp;<span class="title function_">dfsTree</span>(node.<span class="property">right</span>,curPath+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfsTree</span>(root,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> resNode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="12-路径总和"><a href="#12-路径总和" class="headerlink" title="12. 路径总和"></a>12. 路径总和</h3><p>112 </p><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">targetSum</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasPathSum = <span class="keyword">function</span>(<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">traversal</span>=(<span class="params">root,targetSum</span>)=&gt;&#123;</span><br><span class="line">        <span class="comment">// 遇到叶子节点，并且计数为0</span></span><br><span class="line">        <span class="keyword">if</span>(!root.<span class="property">left</span>&amp;&amp;!root.<span class="property">right</span>&amp;&amp;targetSum===<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  左（空节点不遍历）.若遇到叶子节点返回true，则直接返回true</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">left</span>&amp;&amp;<span class="title function_">traversal</span>(root.<span class="property">left</span>,targetSum-root.<span class="property">left</span>.<span class="property">val</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  右（空节点不遍历）.若遇到叶子节点返回true，则直接返回true</span></span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">right</span>&amp;&amp;<span class="title function_">traversal</span>(root.<span class="property">right</span>,targetSum-root.<span class="property">right</span>.<span class="property">val</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">traversal</span>(root,targetSum-root.<span class="property">val</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="13-从中序与后序遍历序列构造二叉树"><a href="#13-从中序与后序遍历序列构造二叉树" class="headerlink" title="13. 从中序与后序遍历序列构造二叉树"></a>13. 从中序与后序遍历序列构造二叉树</h3><p>106</p><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p>前序和中序可以唯一确定一棵二叉树。</p><p>后序和中序可以唯一确定一棵二叉树。</p><p>那么前序和后序可不可以唯一确定一棵二叉树呢？</p><p><strong>前序和后序不能唯一确定一棵二叉树！</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">inorder</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">postorder</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="keyword">function</span>(<span class="params">inorder, postorder</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!inorder.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> rootVal = postorder.<span class="title function_">pop</span>(); <span class="comment">// 从后序遍历的数组中获取中间节点的值， 即数组最后一个值</span></span><br><span class="line">    <span class="keyword">let</span> rootIndex = inorder.<span class="title function_">indexOf</span>(rootVal); <span class="comment">// 获取中间节点在中序遍历中的下标</span></span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal); <span class="comment">// 创建中间节点</span></span><br><span class="line"></span><br><span class="line">    root.<span class="property">left</span> = <span class="title function_">buildTree</span>(inorder.<span class="title function_">slice</span>(<span class="number">0</span>, rootIndex), postorder.<span class="title function_">slice</span>(<span class="number">0</span>, rootIndex)); <span class="comment">// 创建左节点</span></span><br><span class="line">    root.<span class="property">right</span> = <span class="title function_">buildTree</span>(inorder.<span class="title function_">slice</span>(rootIndex + <span class="number">1</span>), postorder.<span class="title function_">slice</span>(rootIndex)); <span class="comment">// 创建右节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="14-最大二叉树"><a href="#14-最大二叉树" class="headerlink" title="14. 最大二叉树"></a>14. 最大二叉树</h3><p>654</p><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p><ol><li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li></ol><p>返回 <em><code>nums</code> 构建的</em> <strong><em>最大二叉树\</em></strong> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> constructMaximumBinaryTree = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 确定终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(!nums.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单层递归逻辑</span></span><br><span class="line">    <span class="keyword">let</span> maxval=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(item&gt;maxval)&#123;</span><br><span class="line">            maxval=item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> index=nums.<span class="title function_">indexOf</span>(maxval)</span><br><span class="line">    <span class="keyword">let</span> node=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxval) <span class="comment">// 中</span></span><br><span class="line">    <span class="keyword">let</span> leftArr=nums.<span class="title function_">slice</span>(<span class="number">0</span>,index) <span class="comment">// 左</span></span><br><span class="line">    <span class="keyword">let</span> rightArr=nums.<span class="title function_">slice</span>(index+<span class="number">1</span>) <span class="comment">// 右</span></span><br><span class="line">    </span><br><span class="line">    node.<span class="property">left</span>=<span class="title function_">constructMaximumBinaryTree</span>(leftArr)</span><br><span class="line">    node.<span class="property">right</span>=<span class="title function_">constructMaximumBinaryTree</span>(rightArr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="15-合并二叉树"><a href="#15-合并二叉树" class="headerlink" title="15. 合并二叉树"></a>15. 合并二叉树</h3><p>617</p><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p>解题思路：</p><p>两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。</p><p>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</p><p>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</p><p>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。</p><p>对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//  对树1进行改造 返回新的树1</span></span><br><span class="line"><span class="keyword">var</span> mergeTrees = <span class="keyword">function</span>(<span class="params">root1, root2</span>) &#123;</span><br><span class="line">    <span class="comment">// 未重叠部分</span></span><br><span class="line">    <span class="keyword">if</span>(!root1) <span class="keyword">return</span> root2</span><br><span class="line">    <span class="keyword">if</span>(!root2) <span class="keyword">return</span> root1</span><br><span class="line">    <span class="comment">// 重叠部分</span></span><br><span class="line">    root1.<span class="property">val</span>+=root2.<span class="property">val</span></span><br><span class="line">    root1.<span class="property">left</span>=<span class="title function_">mergeTrees</span>(root1.<span class="property">left</span>,root2.<span class="property">left</span>)</span><br><span class="line">    root1.<span class="property">right</span>=<span class="title function_">mergeTrees</span>(root1.<span class="property">right</span>,root2.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">return</span> root1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="16-二叉搜索树中的搜索"><a href="#16-二叉搜索树中的搜索" class="headerlink" title="16. 二叉搜索树中的搜索"></a>16. 二叉搜索树中的搜索</h3><p>700</p><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> searchBST = <span class="keyword">function</span> (<span class="params">root, val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || root.<span class="property">val</span> === val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">val</span> &gt; val)</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">searchBST</span>(root.<span class="property">left</span>, val);</span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">val</span> &lt; val)</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">searchBST</span>(root.<span class="property">right</span>, val);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="17-验证二叉搜索树"><a href="#17-验证二叉搜索树" class="headerlink" title="17. 验证二叉搜索树"></a>17. 验证二叉搜索树</h3><p>98</p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValidBST = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span>=(<span class="params">root</span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span></span><br><span class="line">        <span class="title function_">dfs</span>(root.<span class="property">left</span>)</span><br><span class="line">        res.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">        <span class="title function_">dfs</span>(root.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>(root)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;res.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(res[i]&lt;=res[i-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="18-二叉搜索树中的众树"><a href="#18-二叉搜索树中的众树" class="headerlink" title="18. 二叉搜索树中的众树"></a>18. 二叉搜索树中的众树</h3><p>501</p><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <a href="https://baike.baidu.com/item/众数/44796">众数</a>（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMode = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count=<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> maxCount=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> pre=<span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    <span class="comment">// 使用双指针的方法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">traversal</span>=(<span class="params">cur</span>)=&gt;&#123;</span><br><span class="line">        <span class="comment">// 确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(!cur) <span class="keyword">return</span> </span><br><span class="line">        <span class="comment">// 确定单层递归逻辑</span></span><br><span class="line">        <span class="title function_">traversal</span>(cur.<span class="property">left</span>)</span><br><span class="line">        <span class="keyword">if</span>(pre &amp;&amp; pre.<span class="property">val</span>==cur.<span class="property">val</span>)&#123;</span><br><span class="line">            count++ <span class="comment">// 前后指针一样计数加一</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            count=<span class="number">1</span> <span class="comment">// 新值置1</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre=cur</span><br><span class="line">        <span class="comment">// 如果计数等于最大计数，加入结果数组，但是这里的最大计数不知道是不是真的最大计数</span></span><br><span class="line">        <span class="keyword">if</span>(maxCount==count)&#123;    </span><br><span class="line">            res.<span class="title function_">push</span>(cur.<span class="property">val</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxCount&lt;count)&#123;</span><br><span class="line">            maxCount=count</span><br><span class="line">            res=[]  <span class="comment">// 若不是最大计数，res清空 重新记录</span></span><br><span class="line">            res.<span class="title function_">push</span>(cur.<span class="property">val</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">traversal</span>(cur.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">traversal</span>(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还一种简单的是 建立Map哈希表，键为数字，值为出现的次数</p><h3 id="19-二叉树的最近公共祖先"><a href="#19-二叉树的最近公共祖先" class="headerlink" title="19. 二叉树的最近公共祖先"></a>19. 二叉树的最近公共祖先</h3><p>236</p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>后序遍历从下往上搜索，类似于回溯</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">q</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="keyword">function</span>(<span class="params">root, p, q</span>) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用递归的方法</span></span><br><span class="line">    <span class="comment">// 需要从下到上，所以使用后序遍历</span></span><br><span class="line">    <span class="comment">// 1. 确定递归的函数</span></span><br><span class="line">    <span class="keyword">const</span> travelTree = <span class="keyword">function</span>(<span class="params">root,p,q</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. 确定递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root === <span class="literal">null</span> || root === p||root === q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 确定递归单层逻辑</span></span><br><span class="line">        <span class="keyword">let</span> left = <span class="title function_">travelTree</span>(root.<span class="property">left</span>,p,q);</span><br><span class="line">        <span class="keyword">let</span> right = <span class="title function_">travelTree</span>(root.<span class="property">right</span>,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left !== <span class="literal">null</span>&amp;&amp;right !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left ===<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span>  <span class="title function_">travelTree</span>(root,p,q);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="20-二叉搜索树的公共祖先"><a href="#20-二叉搜索树的公共祖先" class="headerlink" title="20. 二叉搜索树的公共祖先"></a>20. 二叉搜索树的公共祖先</h3><p>235</p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>只要一个结点在p和q的中间，就是最近公共祖先</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">q</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="keyword">function</span>(<span class="params">root, p, q</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ancestor=root</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ancestor.<span class="property">val</span>&gt;p.<span class="property">val</span> &amp;&amp; ancestor.<span class="property">val</span>&gt;q.<span class="property">val</span>)&#123;</span><br><span class="line">            ancestor=ancestor.<span class="property">left</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ancestor.<span class="property">val</span>&lt;p.<span class="property">val</span> &amp;&amp; ancestor.<span class="property">val</span>&lt;q.<span class="property">val</span>)&#123;</span><br><span class="line">            ancestor=ancestor.<span class="property">right</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ancestor</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="21-二叉搜索树中插入节点"><a href="#21-二叉搜索树中插入节点" class="headerlink" title="21.二叉搜索树中插入节点"></a>21.二叉搜索树中插入节点</h3><p>701</p><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p>思路:只要遍历二叉树，和节点值比较，若小往左子树，若大往右子树，节点不存在时就是插入的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @param &#123;number&#125; val</span><br><span class="line"> * @return &#123;TreeNode&#125;</span><br><span class="line"> */</span><br><span class="line">var insertIntoBST = function(root, val) &#123;</span><br><span class="line">    if(!root)&#123;</span><br><span class="line">        return new TreeNode(val)</span><br><span class="line">    &#125;</span><br><span class="line">    if(val&lt;root.val)&#123;</span><br><span class="line">       root.left= insertIntoBST(root.left,val)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">       root.right=insertIntoBST(root.right,val)</span><br><span class="line">    &#125;</span><br><span class="line">    return root</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="22-删除二叉搜索树中的节点"><a href="#22-删除二叉搜索树中的节点" class="headerlink" title="22. 删除二叉搜索树中的节点"></a>22. 删除二叉搜索树中的节点</h3><p>450</p><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p><strong>思路：</strong></p><p>节点可能不存在，返回null<br>可能为叶子节点，左孩子为空，右也为空 返回null<br>节点左孩子存在，右孩子为空  返回左孩子<br>节点右孩子为空，左孩子存在 返回右孩子<br>几点左右孩子都存在，就将节点左子树移到右子树最左下节点的左孩子位置 返回右孩子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="keyword">function</span>(<span class="params">root, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span>===key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root.<span class="property">left</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.<span class="property">right</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!root.<span class="property">right</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.<span class="property">left</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> cur=root.<span class="property">right</span></span><br><span class="line">            <span class="keyword">while</span>(cur.<span class="property">left</span>)&#123;</span><br><span class="line">                cur=cur.<span class="property">left</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur.<span class="property">left</span>=root.<span class="property">left</span></span><br><span class="line">            root=root.<span class="property">right</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span>&gt;key)&#123;</span><br><span class="line">        root.<span class="property">left</span>= <span class="title function_">deleteNode</span>(root.<span class="property">left</span>,key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span>&lt;key)&#123;</span><br><span class="line">        root.<span class="property">right</span>=<span class="title function_">deleteNode</span>(root.<span class="property">right</span>,key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="23-修剪二叉搜索树"><a href="#23-修剪二叉搜索树" class="headerlink" title="23. 修剪二叉搜索树"></a>23. 修剪二叉搜索树</h3><p>669</p><p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">low</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">high</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> trimBST = <span class="keyword">function</span>(<span class="params">root, low, high</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span>&lt;low)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">trimBST</span>(root.<span class="property">right</span>,low,high) <span class="comment">// 如果root（当前节点）的元素小于low的数值，那么应该递归右子树，并返回右子树符合条件的头结点。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span>&gt;high)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">trimBST</span>(root.<span class="property">left</span>,low,high) <span class="comment">// 同理</span></span><br><span class="line">    &#125;</span><br><span class="line">    root.<span class="property">left</span>=<span class="title function_">trimBST</span>(root.<span class="property">left</span>,low,high)</span><br><span class="line">    root.<span class="property">right</span>=<span class="title function_">trimBST</span>(root.<span class="property">right</span>,low,high)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="24-将有序数组转换为二叉搜索树"><a href="#24-将有序数组转换为二叉搜索树" class="headerlink" title="24. 将有序数组转换为二叉搜索树"></a>24. 将有序数组转换为二叉搜索树</h3><p>108</p><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><strong>本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedArrayToBST = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 确定递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="property">length</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span> </span><br><span class="line">    <span class="comment">// 确定单层递归逻辑</span></span><br><span class="line">    <span class="keyword">let</span> mid=<span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span>/<span class="number">2</span>) <span class="comment">// 找到中间值</span></span><br><span class="line">    <span class="keyword">let</span> node=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid])</span><br><span class="line">    node.<span class="property">left</span>=<span class="title function_">sortedArrayToBST</span>(nums.<span class="title function_">slice</span>(<span class="number">0</span>,mid))</span><br><span class="line">    node.<span class="property">right</span>=<span class="title function_">sortedArrayToBST</span>(nums.<span class="title function_">slice</span>(mid+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="25-把二叉搜索树转变为累加树"><a href="#25-把二叉搜索树转变为累加树" class="headerlink" title="25. 把二叉搜索树转变为累加树"></a>25. 把二叉搜索树转变为累加树</h3><p>538</p><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>解题思路：采用右中左遍历，然后用前后指针法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> convertBST = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre=<span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">bfs</span>=(<span class="params">root</span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span></span><br><span class="line">        <span class="title function_">bfs</span>(root.<span class="property">right</span>)</span><br><span class="line">        <span class="keyword">if</span>(pre)&#123;</span><br><span class="line">            root.<span class="property">val</span>+=pre.<span class="property">val</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pre=root</span><br><span class="line">        <span class="title function_">bfs</span>(root.<span class="property">left</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">bfs</span>(root)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十三 算法-stack和queue</title>
      <link href="/2023/04/03/13/"/>
      <url>/2023/04/03/13/</url>
      
        <content type="html"><![CDATA[<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="1-用栈实现队列"><a href="#1-用栈实现队列" class="headerlink" title="1. 用栈实现队列"></a>1. 用栈实现队列</h3><p>232</p><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p>使用栈来模式队列的行为，如果仅仅用一个栈，是一定不行的，所以需要两个栈<strong>一个输入栈，一个输出栈</strong>，这里要注意输入栈和输出栈的关系。</p><p>在push数据的时候，只要数据放进输入栈就好，但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyQueue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackIn</span>=[]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackOut</span>=[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> size=<span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span>(size)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">pop</span>()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="property">length</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="title function_">pop</span>())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">pop</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">peek</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x=<span class="variable language_">this</span>.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">push</span>(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="property">length</span> &amp;&amp; !<span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="property">length</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyQueue()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="2-用队列实现栈"><a href="#2-用队列实现栈" class="headerlink" title="2. 用队列实现栈"></a>2. 用队列实现栈</h3><p>225</p><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p>在此用一个队列来实现的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyStack</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">queue</span>=[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> size=<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span></span><br><span class="line">    <span class="keyword">while</span>(size--&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x=<span class="variable language_">this</span>.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyStack()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="3-有效的括号"><a href="#3-有效的括号" class="headerlink" title="3. 有效的括号"></a>3. 有效的括号</h3><p>20</p><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p>1.创建一个HashMap，把括号配对放进去。<br>2.创建一个stack（array），for循环遍历字符串，对于每一个字符，如果map里有这个key，那说明它是个左括号，从map里取得相对应的右括号（为什么？）把它push进stack里。否则的话，它就是右括号，需要pop出stack里的最上层字符然后看它是否等于当前的字符。如果不相符，则返回false。<br>3.循环结束后如果stack不为空，说明还剩一些左括号没有被闭合，返回false。否则返回true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> isValidMap=<span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    isValidMap.<span class="title function_">set</span>(<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">    isValidMap.<span class="title function_">set</span>(<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">    isValidMap.<span class="title function_">set</span>(<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> stack=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isValidMap.<span class="title function_">has</span>(item))&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(isValidMap.<span class="title function_">get</span>(item))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.<span class="title function_">pop</span>()!==item)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stack.<span class="property">length</span>!==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-删除字符串中的所有相邻重复项"><a href="#4-删除字符串中的所有相邻重复项" class="headerlink" title="4. 删除字符串中的所有相邻重复项"></a>4. 删除字符串中的所有相邻重复项</h3><p>1047</p><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>而消除一对相邻重复项可能会导致新的相邻重复项出现，如从字符串 abba\text{abba}abba 中删除 bb\text{bb}bb 会导致出现新的相邻重复项 aa\text{aa}aa 出现。因此我们需要保存当前还未被删除的字符。一种显而易见的数据结构呼之欲出：栈。我们只需要遍历该字符串，如果当前字符和栈顶字符相同，我们就贪心地将其消去，否则就将其入栈即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">let</span> c=<span class="literal">null</span></span><br><span class="line">        <span class="keyword">if</span>(stack.<span class="property">length</span> &amp;&amp; item===(c=stack.<span class="title function_">pop</span>()))&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        c&amp;&amp;stack.<span class="title function_">push</span>(c)</span><br><span class="line">        stack.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-逆波兰表达式求值"><a href="#5-逆波兰表达式求值" class="headerlink" title="5. 逆波兰表达式求值"></a>5. 逆波兰表达式求值</h3><p>150</p><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/逆波兰式/128437">逆波兰表示法</a> 表示的算术表达式。</p><p>请你计算该表达式。返回一个表示表达式值的整数。</p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul><li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li><li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + *</code>也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string[]</span>&#125; <span class="variable">tokens</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> evalRPN = <span class="keyword">function</span>(<span class="params">tokens</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> tokens)&#123;</span><br><span class="line">        <span class="keyword">if</span>(item===<span class="string">&#x27;+&#x27;</span>||item===<span class="string">&#x27;-&#x27;</span>||item===<span class="string">&#x27;*&#x27;</span>||item===<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> num2=stack.<span class="title function_">pop</span>()</span><br><span class="line">            <span class="keyword">let</span> num1=stack.<span class="title function_">pop</span>()</span><br><span class="line">            <span class="keyword">switch</span>(item)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stack.<span class="title function_">push</span>(num1 + num2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stack.<span class="title function_">push</span>(num1 - num2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    stack.<span class="title function_">push</span>(num1 * num2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    stack.<span class="title function_">push</span>(num1 / num2 &gt; <span class="number">0</span> ? <span class="title class_">Math</span>.<span class="title function_">floor</span>(num1 / num2) : <span class="title class_">Math</span>.<span class="title function_">ceil</span>(num1 / num2)); <span class="comment">//注意除法时正数向下取整，负数向上取整</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(<span class="built_in">parseInt</span>(item))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="title function_">pop</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-滑动窗口最大值"><a href="#6-滑动窗口最大值" class="headerlink" title="6. 滑动窗口最大值"></a>6. 滑动窗口最大值</h3><p>239 难</p><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设计单调队列的时候，pop，和push操作要保持如下规则：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</span></span><br><span class="line"><span class="comment">// push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-前k个高频元素"><a href="#7-前k个高频元素" class="headerlink" title="7. 前k个高频元素"></a>7. 前k个高频元素</h3><p>347</p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>这道题目主要涉及到如下三块内容：</p><ol><li>要统计元素出现频率</li><li><p>对频率排序</p></li><li><p>找出前K个高频元素</p></li></ol><p>首先统计元素出现的频率，这一类的问题可以使用map来进行统计。</p><p>然后是对频率进行排序，这里我们可以使用一种 容器适配器就是<strong>优先级队列</strong>。</p><p><strong>因为js中没有堆这种数据结构，如果有梦想的人，可以自己通过类去实现一个堆的结构，然后再去做本题目</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> topKFrequent = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> map=<span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        map.<span class="title function_">set</span>(item,(map.<span class="title function_">get</span>(item)||<span class="number">0</span>)+<span class="number">1</span>) <span class="comment">// 通过哈希表统计各个数字出现的次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [...map].<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>b[<span class="number">1</span>]-a[<span class="number">1</span>]).<span class="title function_">map</span>(<span class="function"><span class="params">item</span>=&gt;</span>item[<span class="number">0</span>]).<span class="title function_">slice</span>(<span class="number">0</span>,k) <span class="comment">// 找出前k个高频的元素</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十一 算法-List</title>
      <link href="/2023/03/15/11/"/>
      <url>/2023/03/15/11/</url>
      
        <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="1-移除链表元素"><a href="#1-移除链表元素" class="headerlink" title="1. 移除链表元素"></a>1. 移除链表元素</h3><p>203</p><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> </p><p>通过创建虚拟头结点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElements = <span class="keyword">function</span>(<span class="params">head, val</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dummy=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">    dummy.<span class="property">next</span>=head</span><br><span class="line">    <span class="keyword">let</span> cur=dummy</span><br><span class="line">    <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cur.<span class="property">next</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.<span class="property">next</span>.<span class="property">val</span>==val)&#123;</span><br><span class="line">            cur.<span class="property">next</span>=cur.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur=cur.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-设计链表"><a href="#2-设计链表" class="headerlink" title="2. 设计链表"></a>2. 设计链表</h3><p>707 难</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ListNode</span>(<span class="params">val, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = (val===<span class="literal">undefined</span> ? <span class="number">0</span> : val)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = (next===<span class="literal">undefined</span> ? <span class="literal">null</span> : next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-反转链表"><a href="#3-反转链表" class="headerlink" title="3. 反转链表"></a>3. 反转链表</h3><p>206</p><p>双指针：</p><p>首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。</p><p>然后就要开始反转了，首先要把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。</p><p>为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向了，将cur-&gt;next 指向pre ，此时已经反转了第一个节点了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pre=<span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> cur=head</span><br><span class="line">    <span class="keyword">let</span> temp</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        temp=cur.<span class="property">next</span></span><br><span class="line">        cur.<span class="property">next</span>=pre</span><br><span class="line">        pre=cur</span><br><span class="line">        cur=temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当cur为空的时候循环结束，不断将cur指向pre的过程。关键是初始化的地方，可能有的同学会不理解， 可以看到双指针法中初始化 cur = head，pre = NULL，在递归法中可以从如下代码看出初始化的逻辑也是一样的，只不过写法变了。具体可以看代码（已经详细注释），双指针法写出来之后，理解如下递归写法就不难了，代码逻辑都是一样的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reverse</span>(head,<span class="literal">null</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reverse</span>=(<span class="params">cur,pre</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(!cur)&#123;</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> temp=cur.<span class="property">next</span></span><br><span class="line">    cur.<span class="property">next</span>=pre</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reverse</span>(temp,cur)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-两两交换链表中的节点"><a href="#4-两两交换链表中的节点" class="headerlink" title="4. 两两交换链表中的节点"></a>4. 两两交换链表中的节点</h3><p>24</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>()</span><br><span class="line">  dummy.<span class="property">next</span> = head</span><br><span class="line">  <span class="keyword">let</span> current = dummy</span><br><span class="line">  <span class="keyword">while</span> (current.<span class="property">next</span> !== <span class="literal">null</span> &amp;&amp; current.<span class="property">next</span>.<span class="property">next</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n1 = current.<span class="property">next</span></span><br><span class="line">    <span class="keyword">let</span> n2 = current.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    n1.<span class="property">next</span> = n2.<span class="property">next</span></span><br><span class="line">    current.<span class="property">next</span> = n2</span><br><span class="line">    n2.<span class="property">next</span> = n1</span><br><span class="line">    current = n1</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dummy.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-删除链表中倒数第n个节点"><a href="#5-删除链表中倒数第n个节点" class="headerlink" title="5. 删除链表中倒数第n个节点"></a>5. 删除链表中倒数第n个节点</h3><p>19 </p><p>由于我们需要找到倒数第 nnn 个节点，因此我们可以使用两个指针 first和 second同时对链表进行遍历，并且 first比 second超前 nnn 个节点。当 first\textit{first}first 遍历到链表的末尾时，second就恰好处于倒数第 n 个节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span>(<span class="params">head, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dummy=<span class="keyword">new</span> <span class="title class_">ListNode</span>()</span><br><span class="line">    dummy.<span class="property">next</span>=head</span><br><span class="line">    <span class="keyword">let</span> p1=dummy</span><br><span class="line">    <span class="keyword">let</span> p2=dummy</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        p2=p2.<span class="property">next</span></span><br><span class="line">        n--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2.<span class="property">next</span>)&#123;</span><br><span class="line">        p1=p1.<span class="property">next</span></span><br><span class="line">        p2=p2.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    p1.<span class="property">next</span>=p1.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-环形链表II"><a href="#6-环形链表II" class="headerlink" title="6. 环形链表II"></a>6. 环形链表II</h3><p>142</p><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 <code>null</code>。</p><p>1.用哈希表</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> hash=<span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="keyword">while</span>(head!==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(head))&#123;</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line">        hash.<span class="title function_">add</span>(head)</span><br><span class="line">        head=head.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十二 算法-String</title>
      <link href="/2023/03/15/12/"/>
      <url>/2023/03/15/12/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="1-反转字符串"><a href="#1-反转字符串" class="headerlink" title="1. 反转字符串"></a>1. 反转字符串</h3><p>344</p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong><a href="https://baike.baidu.com/item/原地算法">原地</a>修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">character[]</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseString = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n=s.<span class="property">length</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> T=s[i]</span><br><span class="line">        s[i]=s[n-<span class="number">1</span>-i]</span><br><span class="line">        s[n-<span class="number">1</span>-i]=T</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-反转字符串II"><a href="#2-反转字符串II" class="headerlink" title="2. 反转字符串II"></a>2. 反转字符串II</h3><p>541</p><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseStr = <span class="keyword">function</span>(<span class="params">s, k</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> n = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">        <span class="title function_">reverse</span>(arr, i, <span class="title class_">Math</span>.<span class="title function_">min</span>(i + k, n) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reverse</span> = (<span class="params">arr, left, right</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-反转字符串中的单词"><a href="#3-反转字符串中的单词" class="headerlink" title="3. 反转字符串中的单词"></a>3. 反转字符串中的单词</h3><p>151</p><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="regexp">/\s+/</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 很多语言对字符串提供了 split（拆分），reverse（翻转）和 join（连接）等方法，因此我们可以简单的调用内置的 API 完成操作：</span></span><br></pre></td></tr></table></figure><p>另一种方法</p><p>所以解题思路如下：</p><ul><li>移除多余空格</li><li>将整个字符串反转</li><li>将每个单词反转</li></ul><p>难点在于去空格，我们采用双指针的方法，快指针遍历所有的字符串数组，如果遍历到单词，赋值给慢指针。同时注意去重空格</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">var</span> reverseWords = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">   <span class="comment">// 字符串转数组</span></span><br><span class="line">   <span class="keyword">const</span> strArr = <span class="title class_">Array</span>.<span class="title function_">from</span>(s);</span><br><span class="line">   <span class="comment">// 移除多余空格</span></span><br><span class="line">   <span class="title function_">removeExtraSpaces</span>(strArr);</span><br><span class="line">   <span class="comment">// 翻转</span></span><br><span class="line">   <span class="title function_">reverse</span>(strArr, <span class="number">0</span>, strArr.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= strArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (strArr[i] === <span class="string">&#x27; &#x27;</span> || i === strArr.<span class="property">length</span>) &#123;</span><br><span class="line">       <span class="comment">// 翻转单词</span></span><br><span class="line">       <span class="title function_">reverse</span>(strArr, start, i - <span class="number">1</span>);</span><br><span class="line">       start = i + <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> strArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除多余空格</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeExtraSpaces</span>(<span class="params">strArr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> fastIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(fastIndex &lt; strArr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="comment">// 移除开始位置和重复的空格</span></span><br><span class="line">    <span class="keyword">if</span> (strArr[fastIndex] === <span class="string">&#x27; &#x27;</span> &amp;&amp; (fastIndex === <span class="number">0</span> || strArr[fastIndex - <span class="number">1</span>] === <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">      fastIndex++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      strArr[slowIndex++] = strArr[fastIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除末尾空格</span></span><br><span class="line">  strArr.<span class="property">length</span> = strArr[slowIndex - <span class="number">1</span>] === <span class="string">&#x27; &#x27;</span> ? slowIndex - <span class="number">1</span> : slowIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转从 start 到 end 的字符</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">strArr, start, end</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = start;</span><br><span class="line">  <span class="keyword">let</span> right = end;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">    [strArr[left], strArr[right]] = [strArr[right], strArr[left]];</span><br><span class="line">    left++;</span><br><span class="line">    right--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十 算法-Array</title>
      <link href="/2023/03/02/10/"/>
      <url>/2023/03/02/10/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-二分法"><a href="#1-二分法" class="headerlink" title="1. 二分法"></a>1. 二分法</h3><p>704</p><p>这道题目的前提是数组为有序数组，同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n=nums.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>, right=n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid=<span class="title class_">Math</span>.<span class="title function_">floor</span>(left+ (right-left)/<span class="number">2</span>) <span class="comment">// let mid = (l + r) &gt;&gt; 1; 等价于二进制数往右移一位</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid-<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-移除元素"><a href="#2-移除元素" class="headerlink" title="2. 移除元素"></a>2. 移除元素</h3><p>27</p><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 原地 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并原地修改输入数组。</p><p>有的同学可能说了，<strong>多余的元素</strong>，删掉不就得了。</p><p><strong>要知道数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> k=<span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=val)&#123;</span><br><span class="line">            nums[k]=nums[i]</span><br><span class="line">            k++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k <span class="comment">// 快指针是i，慢指针是k</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</span></span><br><span class="line"><span class="comment">// 定义快慢指针</span></span><br><span class="line"><span class="comment">// 快指针：寻找新数组的元素(寻找过程遍历所有元素)，而新数组就是不含有目标元素的数组</span></span><br><span class="line"><span class="comment">// 慢指针：指向更新新数组下标的位置</span></span><br></pre></td></tr></table></figure><h3 id="3-有序数组的平方"><a href="#3-有序数组的平方" class="headerlink" title="3. 有序数组的平方"></a>3. 有序数组的平方</h3><p>977</p><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p>办法 （1）每个数平方之后，排个序，美滋滋，(2) 使用双指针：数组其实是有序的， 只不过负数平方之后可能成为最大数了。那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入：nums = [-4,-1,0,3,10]</span></span><br><span class="line"><span class="comment">// 输出：[0,1,9,16,100]</span></span><br><span class="line"><span class="comment">// 解释：平方后，数组变为 [16,1,0,9,100]</span></span><br><span class="line"><span class="comment">// 排序后，数组变为 [0,1,9,16,100]</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedSquares = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n=nums.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> result=<span class="keyword">new</span> <span class="title class_">Array</span>(n)</span><br><span class="line">    <span class="keyword">let</span> k=n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,j=n-<span class="number">1</span>;i&lt;=j;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(nums[i],<span class="number">2</span>)&gt;<span class="title class_">Math</span>.<span class="title function_">pow</span>(nums[j],<span class="number">2</span>))&#123;</span><br><span class="line">            result[k--]=<span class="title class_">Math</span>.<span class="title function_">pow</span>(nums[i++],<span class="number">2</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result[k--]=<span class="title class_">Math</span>.<span class="title function_">pow</span>(nums[j--],<span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-长度最小的子数组-滑动窗口"><a href="#4-长度最小的子数组-滑动窗口" class="headerlink" title="4. 长度最小的子数组|滑动窗口"></a>4. 长度最小的子数组|滑动窗口</h3><p>209</p><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p>解法一：暴力解法，这道题目暴力解法当然是 两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是O(n^2)。</p><p>解法二：滑动窗口，所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。可以发现滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="keyword">function</span>(<span class="params">target, nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result=<span class="title class_">Infinity</span> <span class="comment">// 最终结果的长度</span></span><br><span class="line">    <span class="keyword">let</span> subLength=<span class="number">0</span> <span class="comment">// 子序列的长度</span></span><br><span class="line">    <span class="keyword">let</span> sum=<span class="number">0</span> <span class="comment">// 子序列之和</span></span><br><span class="line">    <span class="keyword">let</span> s=<span class="number">0</span> <span class="comment">// 开始的指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> e=<span class="number">0</span>;e&lt;nums.<span class="property">length</span>;e++)&#123;<span class="comment">// e结束的指针</span></span><br><span class="line">        sum+=nums[e]</span><br><span class="line">        <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">            subLength=e-s+<span class="number">1</span></span><br><span class="line">            result=<span class="title class_">Math</span>.<span class="title function_">min</span>(result,subLength)</span><br><span class="line">            sum-=nums[s++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result==<span class="title class_">Infinity</span>?<span class="number">0</span>:result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-螺旋矩阵II"><a href="#5-螺旋矩阵II" class="headerlink" title="5. 螺旋矩阵II"></a>5. 螺旋矩阵II</h3><p>59  54</p><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p>二维数组创建方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(n), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n))</span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(n))</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generateMatrix = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [[<span class="number">1</span>]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>, right=n-<span class="number">1</span>, top=<span class="number">0</span>, bottom=n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> direction=<span class="string">&#x27;right&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(n), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n))</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right&amp;&amp;top&lt;=bottom)&#123;</span><br><span class="line">        <span class="keyword">if</span>(direction==<span class="string">&#x27;right&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j=left;j&lt;=right;j++)&#123;</span><br><span class="line">                result[top][j]=i</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">            top++</span><br><span class="line">            direction=<span class="string">&#x27;down&#x27;</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(direction==<span class="string">&#x27;down&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j=top;j&lt;=bottom;j++)&#123;</span><br><span class="line">                result[j][right]=i</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">            right--</span><br><span class="line">            direction=<span class="string">&#x27;left&#x27;</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(direction==<span class="string">&#x27;left&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">let</span> j=right;j&gt;=left;j--)&#123;</span><br><span class="line">                result[bottom][j]=i</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--</span><br><span class="line">            direction=<span class="string">&#x27;top&#x27;</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(direction==<span class="string">&#x27;top&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j=bottom;j&gt;=top;j--)&#123;</span><br><span class="line">                result[j][left]=i</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">            direction=<span class="string">&#x27;right&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九 React interview-questions</title>
      <link href="/2023/02/14/9/"/>
      <url>/2023/02/14/9/</url>
      
        <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="1-对react的理解？有哪些特性？优势？-和vue的区别"><a href="#1-对react的理解？有哪些特性？优势？-和vue的区别" class="headerlink" title="1. 对react的理解？有哪些特性？优势？ 和vue的区别"></a>1. 对react的理解？有哪些特性？优势？ 和vue的区别</h2><p>React是一个简单的javascript UI库，用于构建高效、快速的用户界面。它是一个轻量级库，因此很受欢迎。它遵循组件设计模式、<strong><em>声明式编程范式</em></strong>和<strong><em>函数式编程</em></strong>概念，以使前端应用程序更高效。它使用虚拟DOM来有效地操作DOM。它遵循从父组件到子组件的单向数据流。</p><p>特点：</p><ul><li>JSX 语法</li><li>单向数据绑定</li><li>虚拟 DOM</li><li>声明式编程</li><li>组件</li></ul><p>优势：</p><p>通过上面的初步了解，可以感受到 <code>React</code> 存在的优势：</p><ul><li>高效灵活</li><li>声明式的设计，简单使用</li><li>组件式开发，提高代码复用率</li><li>单向响应的数据流会比双向绑定的更安全，速度更快</li></ul><p>react采用单向数据绑定，推崇结合immutable来实现数据不可变;vue思想是 响应式的，双向数据绑定</p><p>vue 采用了template， react采用了jsx</p><p>很多人认为 React 是 MVC 中的 V（视图），vue采用的是mvvm架构模式</p><h2 id="2-说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？"><a href="#2-说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？" class="headerlink" title="2. 说说 Real DOM 和 Virtual DOM 的区别？优缺点？"></a>2. 说说 Real DOM 和 Virtual DOM 的区别？优缺点？</h2><p>是什么？</p><p>Real DOM，真实 <code>DOM</code>，意思为文档对象模型，是一个结构化文本的抽象，在页面渲染出的每一个结点都是一个真实 <code>DOM</code> 结构。</p><p><code>Virtual Dom</code>，本质上是以 <code>JavaScript</code> 对象形式存在的对 <code>DOM</code> 的描述。</p><p>创建虚拟 <code>DOM</code> 目的就是为了更好将虚拟的节点渲染到页面视图中，虚拟 <code>DOM</code> 对象的节点与真实 <code>DOM</code> 的属性一一照应。</p><p>两者的区别如下：</p><ul><li>虚拟 DOM 不会进行排版与重绘操作，而真实 DOM 会频繁重排与重绘</li><li>虚拟 DOM 的总损耗是“虚拟 DOM 增删改+真实 DOM 差异增删改+排版与重绘”，真实 DOM 的总损耗是“真实 DOM 完全增删改+排版与重绘”</li></ul><p><strong>优缺点：</strong></p><p>真实 <code>DOM</code> 的优势：</p><ul><li>易用</li></ul><p>缺点：</p><ul><li>效率低，解析速度慢，内存占用量过高</li><li>性能差：频繁操作真实 DOM，易于导致重绘与回流</li></ul><p>使用虚拟 <code>DOM</code> 的优势如下：</p><ul><li>简单方便：如果使用手动操作真实 <code>DOM</code> 来完成页面，繁琐又容易出错。</li><li>性能方面：使用 Virtual DOM，能够有效避免真实 DOM 数频繁更新，减少多次引起重绘与回流，提高性能</li><li>跨平台：React 借助虚拟 DOM，带来了跨平台的能力，一套代码多端运行（将真实DOM映射为JavaScript对象，可以使代码不仅仅局限于对浏览器DOM的操作，只要支持JavaScript即可使用。）</li><li>防范xss攻击</li></ul><p>缺点：</p><ul><li>在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化</li><li>首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，速度比正常稍慢</li></ul><h2 id="3-react中的diff算法"><a href="#3-react中的diff算法" class="headerlink" title="3. react中的diff算法"></a>3. react中的diff算法</h2><p>React 的 diff 策略，将 将传统的复杂度为O(n3) 的问题转换成复杂度为 O(n) 的问题</p><p>diff策略分为三个层级</p><p><strong>tree diff</strong></p><p>只会对树相同层级的节点进行比较。只有删除、创建的操作</p><p><strong>component diff</strong></p><p>如果是同一类型的组件，则会继续往下diff运算。</p><p>不同类型的组件，则将该组件判断为 dirty component，删除组件和其所有子节点。</p><p><strong>element diff</strong></p><p>当节点处于同一层级时，每个节点在对应的层级用唯一的<code>key</code>作为标识。react diff提供了三种结点操作，分别为：<strong>INSERT_MARKUP</strong>（插入）、<strong>MOVE_EXISTING</strong>（移动）和 <strong>REMOVE_NODE</strong>（删除）。</p><p>面对全新的节点时，执行<strong>插入操作</strong>, 面对多余的节点时，执行<strong>删除操作</strong>, 面对换位的节点时，执行<strong>移动操作</strong></p><p>移动的<strong>细节：</strong></p><p>新旧节点会遍历后对比下标，新的下标称为lastIndex，旧的称为index，如果lastIndex大于index，需要将节点旧的节点移动到新的位置，相反则位置不变，index的值赋给lastIndex(lastIndex=index)。<br>如果没有找到对应位置节点，则执行新增； 如果旧的节点在新的节点组用不到，则执行删除；一般是在最后做删除操作。</p><p><strong>经典面试题:</strong><br>      1). react/vue中的key有什么作用？（key的内部原理是什么？）<br>      2). 为什么遍历列表时，key最好不要用index?</p><pre><code>  1. 虚拟DOM中key的作用：      1). 简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。      2). 详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】,                     随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：      ​        a. 旧虚拟DOM中找到了与新虚拟DOM相同的key：      ​              (1).若虚拟DOM中内容没变, 直接使用之前的真实DOM      ​              (2).若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM      ​        b. 旧虚拟DOM中未找到与新虚拟DOM相同的key      ​              根据数据创建新的真实DOM，随后渲染到到页面      ​                2. 用index作为key可能会引发的问题：                  1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:                     会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。                        2. 如果结构中还包含输入类的DOM：                    会产生错误DOM更新 ==&gt; 界面有问题。                        3. 注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，                              仅用于渲染列表用于展示，使用index作为key是没有问题的。        3. 开发中如何选择key?:                  1. 最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。                  2. 如果确定只是简单的展示数据，用index也是可以的。</code></pre><h2 id="4-生命周期"><a href="#4-生命周期" class="headerlink" title="4. 生命周期"></a>4. 生命周期</h2><p>可以分成三个阶段：</p><ul><li>创建阶段</li><li>更新阶段</li><li>卸载阶段</li></ul><p><strong>创建阶段</strong></p><p>创建阶段主要分成了以下几个生命周期方法：</p><ul><li>constructor</li><li>getDerivedStateFromProps</li><li>render</li><li>componentDidMount</li></ul><p><strong>更新阶段</strong></p><p>该阶段的函数主要为如下方法：</p><ul><li>getDerivedStateFromProps  当state需要从props初始化时，使用</li><li>shouldComponentUpdate </li><li>render</li><li>getSnapshotBeforeUpdate  查看更新前 state 对象的值</li><li>componentDidUpdate</li></ul><p><strong>卸载阶段</strong></p><p>componentWillUnmount</p><p>此方法用于组件卸载前，清理一些定时器，或者取消订阅的网络请求等</p><p>一旦一个组件实例被卸载，其不会被再次挂载，而只可能是被重新创建</p><!-- <img src="img/react生命周期(新).png" alt="react生命周期(新)" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/react生命周期(新).png" alt="react生命周期(新)" style="width:80%;"/></div><span class="image-caption">react生命周期(新)</span></div><h2 id="5-state-和-props-有什么区别？"><a href="#5-state-和-props-有什么区别？" class="headerlink" title="5. state 和 props 有什么区别？"></a>5. state 和 props 有什么区别？</h2><p>一个组件的显示形态可以由数据状态和外部参数所决定，而数据状态就是 <code>state</code>，外部参数就是props</p><p>区别</p><p><strong>相同点</strong>：</p><ul><li>两者都是 JavaScript 对象</li><li>两者都是用于保存信息</li><li>props 和 state 都能触发渲染更新</li></ul><p><strong>不同点</strong>：</p><ul><li>props 是外部传递给组件的，而 state 是在组件内被组件自己管理的，一般在 constructor 中初始化</li><li>props 在组件内部是不可修改的，但 state 在组件内部可以进行修改</li><li>state 是多变的、可以修改</li></ul><h2 id="6-调用setState-useState发生异步吗？"><a href="#6-调用setState-useState发生异步吗？" class="headerlink" title="6. 调用setState/useState发生异步吗？"></a>6. 调用setState/useState发生异步吗？</h2><p>会</p><p>为了提高性能React将setState设置为批次更新，即是异步操作函数，将 setState() 视为请求而不是立即更新组件的命令。为了更好的感知性能，React 会延迟调用它，然后通过一次传递更新多个组件。React 并不会保证 state 的变更会立即生效。setState() 并不总是立即更新组件。它会批量推迟更新。这使得在调用 setState() 后立即读取 this.state 成为了隐患</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line"></span><br><span class="line">       <span class="attr">count</span>:<span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line"></span><br><span class="line">       <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>);<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加载完成&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>useState</p><p>useState 返回的更新对象的方法是异步的，要在下次重绘才能获取新值，不要试图在更改状态之后立即获取状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一 不确定是否有效</span></span><br><span class="line"><span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_">setData</span>(<span class="function">(<span class="params">prev</span>) =&gt;</span> prev + <span class="number">1</span>); <span class="comment">// prev 是data 改变之前的值，return 返回的值会作为新状态覆盖data</span></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="comment">//先使用 useRef 进行存储数据，再使用 useEffect 监听数据变化，并进行更新。</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Index</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> [info, setInfo] = <span class="title function_">useState</span>()</span><br><span class="line"><span class="keyword">const</span> infoRef = <span class="title function_">useRef</span>()</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">infoRef.<span class="property">current</span> = info</span><br><span class="line">&#125;, [info])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在之后需要使用 info 数据的地方只需要获取 infoRef.current 即可获取最新的 info 数据内容。</span></span><br></pre></td></tr></table></figure><h2 id="7-react事件机制"><a href="#7-react事件机制" class="headerlink" title="7. react事件机制"></a>7. react事件机制</h2><p>react自身实现了一套事件机制叫合成事件。合成事件是 <code>React</code>模拟原生 <code>DOM</code>事件所有能力的一个事件对象。</p><p>总结：</p><p>React 16上注册的事件最终会绑定在<strong>document</strong>这个 DOM 上，而不是 React 组件对应的 DOM</p><p>React17注册的事件绑定<strong>容器结点</strong>，比如root</p><p>如果想要获得原生<code>DOM</code>事件，可以通过<code>e.nativeEvent</code>属性获取</p><p>React 自身实现了一套事件冒泡机制，阻止合成事件向上的冒泡，用e.stopPropagation()。阻止合成事件本级间的冒泡以及向上冒泡，用e.nativeEvent.stopImmediatePropagation()</p><p>react16事件执行顺序。先执行原生事件，再执行react事件。原生捕获-&gt;原生冒泡-&gt;react捕获-&gt;react冒泡</p><p>react17事件执行顺序。react捕获-&gt;原生捕获-&gt;原生冒泡-&gt;react冒泡</p><h2 id="8-react构建组件的方式"><a href="#8-react构建组件的方式" class="headerlink" title="8. react构建组件的方式"></a>8. react构建组件的方式</h2><ul><li>函数式创建</li><li>通过 React.createClass 方法创建</li><li>继承 React.Component 创建</li></ul><p>在<code>React Hooks</code>出来之前，函数式组件可以视为无状态组件，只负责根据传入的<code>props</code>来展示视图，不涉及对<code>state</code>状态的操作。</p><p><code>React.createClass</code>是react刚开始推荐的创建组件的方式，目前这种创建方式已经不怎么用了</p><p>同样在<code>react hooks</code>出来之前，有状态的组件只能通过继承<code>React.Component</code>这种形式进行创建</p><p>有状态的组件也就是组件内部存在维护的数据，在类创建的方式中通过<code>this.state</code>进行访问</p><p>当调用<code>this.setState</code>修改组件的状态时，组价会再次会调用<code>render()</code>方法进行重新渲染</p><h2 id="9-React-refs的理解？"><a href="#9-React-refs的理解？" class="headerlink" title="9. React refs的理解？"></a>9. React refs的理解？</h2><p>ref 一种访问<code>DOM</code>节点的方式。</p><ol><li>字符串形式的ref</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p ref=<span class="string">&#x27;wenben&#x27;</span>&gt;文本&lt;/p&gt;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">wenben</span>)</span><br><span class="line"><span class="comment">// 已经过时了</span></span><br></pre></td></tr></table></figure><ol><li><code>React.createRef()</code>创建</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">myRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> node = <span class="variable language_">this</span>.<span class="property">myRef</span>.<span class="property">current</span>;</span><br></pre></td></tr></table></figure><ol><li>useRef中的hooks</li></ol><p><em>保存一个值,在整个生命周期中维持不变</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> myref = <span class="title function_">useRef</span>()</span><br><span class="line">  <span class="keyword">const</span> node = myref.<span class="property">current</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;myref&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-类组件和函数式组件的区别？"><a href="#10-类组件和函数式组件的区别？" class="headerlink" title="10. 类组件和函数式组件的区别？"></a>10. 类组件和函数式组件的区别？</h2><p>类组件，顾名思义，也就是通过使用<code>ES6</code>类的编写形式去编写组件，该类必须继承<code>React.Component</code></p><p>如果想要访问父组件传递过来的参数，可通过<code>this.props</code>的方式去访问</p><p>在组件中必须实现<code>render</code>方法，在<code>return</code>中返回<code>React</code>对象</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;hello 2005&#x27;</span>,</span><br><span class="line">        <span class="attr">count</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数式组件：就是通过函数编写的形式去实现一个<code>React</code>组件，是<code>React</code>中定义组件最简单的方式</p><p>函数第一个参数为<code>props</code>用于接收父组件传递过来的参数</p><p>区别：</p><p>函数组件语法更短、更简单，这使得它更容易开发、理解和测试</p><p>而类组件也会因大量使用 <code>this</code>而让人感到困惑</p><h2 id="11-受控组件与非受控组件"><a href="#11-受控组件与非受控组件" class="headerlink" title="11. 受控组件与非受控组件"></a>11. 受控组件与非受控组件</h2><p>受控组件的状态全程响应外部数据的变化，给input提供onchange事件，一旦检测到文本框内容有变化，马上执行onchange事件获取表单的内容。</p><p>非受控组件将真实数据存在 DOM 节点中,通过ref来获取。,ref属性接受一个回调函数，返回一个element节点 ， 通过节点获取到数据 ref={(element)=&gt;this.addressElement = element }</p><h2 id="12-高阶组件"><a href="#12-高阶组件" class="headerlink" title="12. 高阶组件"></a>12. 高阶组件</h2><p>高阶组件是一个函数：即接受一个或多个组件作为参数并且返回一个组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (<span class="title class_">WrappedComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">EnhancedComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对传入的原始组件 <code>WrappedComponent</code> 做一些你想要的操作（比如操作 props，提取 state，给原始组件包裹其他元素等），从而加工出想要的组件 <code>EnhancedComponent</code></p><p>好处：高阶组件能够提高代码的复用性</p><h2 id="13-引入css的方式有哪几种？"><a href="#13-引入css的方式有哪几种？" class="headerlink" title="13. 引入css的方式有哪几种？"></a>13. 引入css的方式有哪几种？</h2><ul><li>在组件内直接使用</li><li>组件中引入 .css 文件</li><li>组件中引入 .module.css 文件</li><li>CSS in JS</li></ul><p>区别</p><ul><li>在组件内直接使用<code>css</code>该方式编写方便，容易能够根据状态修改样式属性，但是大量的演示编写容易导致代码混乱</li><li>组件中引入 .css 文件符合我们日常的编写习惯，但是作用域是全局的，样式之间会层叠（<strong>样式污染</strong>）</li><li>引入.module.css 文件能够解决局部作用域问题。</li><li>通过css in js 这种方法，可以满足大部分场景的应用，可以类似于预处理器一样样式嵌套、定义、修改状态等</li></ul><p>至于使用<code>react</code>用哪种方案引入<code>css</code>，并没有一个绝对的答案，可以根据各自情况选择合适的方案</p><h2 id="14-react组件间过度动画如何实现？"><a href="#14-react组件间过度动画如何实现？" class="headerlink" title="14. react组件间过度动画如何实现？"></a>14. react组件间过度动画如何实现？</h2><p>在日常开发中，页面切换时的转场动画是比较基础的一个场景，当一个组件在显示与消失过程中存在过渡动画，可以很好的增加用户的体验。在<code>react</code>中实现过渡动画效果会有很多种选择，如<code>react-transition-group</code>，<code>react-motion</code>，<code>Animated</code>，以及原生的<code>CSS</code>都能完成切换动画</p><p>在<code>react</code>中，<code>react-transition-group</code>是一种很好的解决方案，其可以导出3个组件：</p><ul><li><p>CSSTransition：在前端开发中，结合 CSS 来完成过渡动画效果</p></li><li><p>SwitchTransition：两个组件显示和隐藏切换时，使用该组件</p></li><li>TransitionGroup：将多个动画组件包裹在其中，一般用于列表中元素的动画</li></ul><h2 id="15-redux的工作原理"><a href="#15-redux的工作原理" class="headerlink" title="15. redux的工作原理"></a>15. redux的工作原理</h2><p>redux可以对react组件做全局的状态管理。</p><p>三大原则</p><ul><li>单一数据源</li><li>state 是只读的</li><li>使用纯函数来执行修改</li></ul><p>三大核心 store，action，reducer </p><p>store:数据state都放在 <code>store</code>中统一管理 （将state、action、reducer<strong>联系在一起的对象</strong>）</p><p>reducer: 是个纯函数，根据传入的action，去返回新的state更新store中的数据</p><p>action：UI每一次状态的改变都会产生一个action</p><p>简易执行流程：组件的状态存放在store中，UI状态改变生成一个action，reducer接受到action然后进行处理产生新的state, 放到了store中，UI又从store中取得新状态。</p><p>API</p><ul><li>createStore可以帮助创建 store</li><li>store.dispatch 帮助派发 action , action 会传递给 store</li><li>store.getState 这个方法可以帮助获取 store 里边所有的数据内容</li><li>store.subscrible 方法订阅 store 的改变，只要 store 发生改变， store.subscrible 这个函数接收的这个回调函数就会被执行</li></ul><!-- <img src="img/image-20230309144100753.png" alt="image-20230309144100753" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/image-20230309144100753.png" style="width:80%;"/></div></div><h2 id="16-redux中间件"><a href="#16-redux中间件" class="headerlink" title="16. redux中间件"></a>16. redux中间件</h2><p>那么如果需要支持异步操作，或者支持错误处理、日志监控，这个过程需要用上中间件</p><p>其本质上一个函数，对<code>store.dispatch</code>方法进行了改造，在发出 <code>Action</code>和执行 <code>Reducer</code>这两步之间，添加了其他功能。</p><ul><li>redux-thunk：用于异步操作</li><li>redux-logger：用于日志记录</li></ul><p>上述的中间件都需要通过<code>applyMiddlewares</code>进行注册，作用是将所有的中间件组成一个数组，依次执行</p><p>然后作为第二个参数传入到<code>createStore</code>中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(</span><br><span class="line">  reducer,</span><br><span class="line">  <span class="title function_">applyMiddleware</span>(thunk, logger)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 异步逻辑</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getHomeMultidataAction</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch，getState</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;http://xxx.xx.xx.xx/test&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = res.<span class="property">data</span>.<span class="property">data</span>;</span><br><span class="line">      <span class="title function_">dispatch</span>(<span class="title function_">changeBannersAction</span>(data.<span class="property">banner</span>.<span class="property">list</span>));</span><br><span class="line">      <span class="title function_">dispatch</span>(<span class="title function_">changeRecommendsAction</span>(data.<span class="property">recommend</span>.<span class="property">list</span>));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-说说你对React-Router的理解？"><a href="#17-说说你对React-Router的理解？" class="headerlink" title="17. 说说你对React Router的理解？"></a>17. 说说你对React Router的理解？</h2><p>可以实现无刷新的条件下切换显示不同的页面。路由的本质就是页面的<code>URL</code>发生改变时，页面的显示结果可以根据<code>URL</code>的变化而变化，但是页面不会刷新。因此，可以通过前端路由可以实现单页(SPA)应用</p><p>组件：</p><p><BrowserRouter> <HashRouter></p><p><Routes/> 与 <Route/></p><p><Link> <NavLink></p><Navigate><Outlet><p>Hooks</p><p>useRoutes() 使用路由表</p><p>useNavigate() 作用：返回一个函数用来实现编程式导航。</p><p>useParams() 返回当前匹配路由的<code>params</code>参数，类似于5.x中的<code>match.params</code>。</p><p>useSearchParams() 用于读取和修改当前位置的 URL 中的查询字符串。返回一个包含两个值的数组，内容分别为：当前的seaech参数、更新search的函数。</p><p>useLocation() 获取当前 location 信息</p><h2 id="18-React-Router的模式是什么"><a href="#18-React-Router的模式是什么" class="headerlink" title="18. React Router的模式是什么"></a>18. React Router的模式是什么</h2><p>hash 模式  对应HashRouter组件</p><p>history 模式 对应BrowserRouter组件</p><h2 id="19-immutable-的理解？如何应用在react项目中？"><a href="#19-immutable-的理解？如何应用在react项目中？" class="headerlink" title="19. immutable 的理解？如何应用在react项目中？"></a>19. immutable 的理解？如何应用在react项目中？</h2><p>不可改变的，在计算机中，即指一旦创建，就不能再被更改的数据。</p><p><code>Immutable</code> 实现的原理是 <code>Persistent Data Structure</code>（持久化数据结构）:</p><p>也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免深拷贝把所有的节点都复制一遍带来的性能损耗，immutable使用了结构共享，<strong>即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其他节点则进行共享</strong></p><!-- <img src="img/2b4c801a7b40eefcd4ee6767fb984fdf_720w.gif" alt="img" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/2b4c801a7b40eefcd4ee6767fb984fdf_720w.gif" style="width:80%;"/></div></div><p>使用<code>Immutable</code>对象最主要的库是<code>immutable.js</code></p><p><strong>react中的应用</strong></p><p>使用 <code>Immutable</code>可以给 <code>React</code> 应用带来性能的优化，主要体现在减少渲染的次数。</p><p>在做<code>react</code>性能优化的时候，为了避免重复渲染，我们会在<code>shouldComponentUpdate()</code>中做对比，当返回<code>true</code>执行<code>render</code>方法</p><p><code>Immutable</code>通过<code>is</code>方法则可以完成对比，而无需像一样通过深度比较的方式比较</p><p>在使用<code>redux</code>过程中也可以结合<code>Immutable</code>，不使用<code>Immutable</code>前修改一个数据需要做一个深拷贝</p><p><strong>主要优势：</strong><br>1、节省CPU<br>避免深拷贝，复杂对象比较<br>2、节省内存<br>结构共享，复用已有结构</p><h2 id="20-说说React-render方法的原理？在什么时候触发更新"><a href="#20-说说React-render方法的原理？在什么时候触发更新" class="headerlink" title="20. 说说React render方法的原理？在什么时候触发更新"></a>20. 说说React render方法的原理？在什么时候触发更新</h2><ul><li>render函数里面可以编写JSX，经过bable转化成createElement这种形式，用于生成虚拟DOM，最终转化成真实DOM</li><li>在React 中，类组件只要执行了 setState 方法，就一定会触发 render 函数执行，函数组件使用useState更改状态不一定导致重新render比如 当数组的地址值不发生改变，就不会触发<code>render</code>。解决方法重新创建数组</li><li>组件的props 改变了，不一定触发 render 函数的执行，但是如果 props 的值来自于父组件或者祖先组件的 state。</li></ul><p><strong>父组件发生了render子组件就一定会render</strong></p><h2 id="21-如何提高组件的渲染效率的？在React中如何避免不必要的render？"><a href="#21-如何提高组件的渲染效率的？在React中如何避免不必要的render？" class="headerlink" title="21.如何提高组件的渲染效率的？在React中如何避免不必要的render？"></a>21.如何提高组件的渲染效率的？在React中如何避免不必要的render？</h2><p>我们了解到<code>render</code>的触发时机，简单来讲就是类组件通过调用<code>setState</code>方法， 就会导致<code>render</code>，父组件一旦发生<code>render</code>渲染，子组件一定也会执行<code>render</code>渲染</p><p>父组件渲染导致子组件渲染，<strong>子组件并没有发生任何改变</strong>，这时候就可以从避免无谓的渲染，具体实现的方式有如下：</p><ul><li>shouldComponentUpdate</li><li>PureComponent</li><li>React.memo</li></ul><p>通过<code>shouldComponentUpdate</code>生命周期函数来比对 <code>state</code>和 <code>props</code>，确定是否要重新渲染</p><p>默认情况下返回<code>true</code>表示重新渲染，如果不希望组件重新渲染，返回 <code>false</code> 即可</p><p>PureComponent和shouldComponentUpdate差不多。</p><p><code>React.memo</code>用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 <code>PureComponent</code> 十分类似。但不同的是， <code>React.memo</code> 只能用于<strong>函数组件</strong></p><h2 id="23-React-Jsx转换成真实DOM过程？"><a href="#23-React-Jsx转换成真实DOM过程？" class="headerlink" title="23.React Jsx转换成真实DOM过程？"></a>23.React Jsx转换成真实DOM过程？</h2><p>书写JSX代码 =&gt; Babel编译JSX =&gt;生成React.createElement的js形式 =&gt; 生成虚拟Dom =&gt; render渲染生成真实Dom</p><h2 id="24-React性能优化的手段？"><a href="#24-React性能优化的手段？" class="headerlink" title="24. React性能优化的手段？"></a>24. React性能优化的手段？</h2><p><code>React</code>凭借<code>virtual DOM</code>和<code>diff</code>算法拥有高效的性能，但是某些情况下，性能明显可以进一步提高。</p><ul><li>避免不必要的<code>render</code>    通过<code>shouldComponentUpdate</code>、<code>PureComponent</code>、<code>React.memo</code> useCallback、useMemo等</li><li>避免使用内联函数          使用内联函数，则每次调用<code>render</code>函数时都会创建一个新的函数实例</li><li>使用 React.Fragments 避免额外标记     使用空标签<></></li><li>使用 Immutable            shouldComponentUpdate时复杂对象比较  redux的reducer避免深拷贝浪费性能</li><li>懒加载组件                     路由懒加载就是加载首页时不加载其他组件  使用到了<code>Suspense</code>和 <code>lazy</code>组件</li><li>利用debounce、throttle 避免重复回调  在搜索组件中，当 input 中内容修改时就触发搜索回调。            </li><li>服务端渲染                    1 利于SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面 2 加速首屏加载，解决首屏白屏问题</li></ul><h2 id="25-usememo和useCallback的区别与应用场景"><a href="#25-usememo和useCallback的区别与应用场景" class="headerlink" title="25. usememo和useCallback的区别与应用场景"></a>25. usememo和useCallback的区别与应用场景</h2><p>react性能的优化点在于：</p><ol><li>调用setState，就会触发组件的重新渲染，无论前后的state是否不同</li><li>父组件更新，子组件也会自动的更新</li></ol><p>useCallback和useMemo的参数跟useEffect一致，他们之间最大的区别有是useEffect会用于处理副作用，而前两个hooks不能。</p><p>use Memo 和 <code>useCallback</code> 接收的参数都是一样,第一个参数为回调 第二个参数为要依赖的数据</p><p>共同作用：<br>1.仅仅 <code>依赖数据</code> 发生变化, 才会重新计算结果，也就是起到缓存的作用。</p><p>两者区别：<br>1.<code>useMemo</code> 计算结果是 <code>return</code> 回来的值, 主要用于 缓存计算结果的值 ，应用场景如： 如果你的页面上展示的数据是通过某个（某些）state计算得来的一个数据，那么你每次这个组件里面无关的state变化引起的重新渲染，都会去计算一下这个数据，这时候就需要用useMemo(()=&gt;{}, [])去包裹你的计算的方法体，这样那些无关的state改变引起的渲染不会重新计算这个方法体，而是返回之前计算的结果，达到一种缓存的效果。<br>2.<code>useCallback</code> 计算结果是 <code>函数</code>, 主要用于 缓存函数，应用场景如: 父组件中需要传递函数到子组件，父组件每次更新都会重新声明内部的函数，导致传递给子组件的函数变化，子组件也会进行没有必要的更新，这种情况就可以利用 useCallback 处理传递给子组件的函数，避免每次父组件更新导致子组件更新的情况，因为只要useCallback 的依赖项没有发生变化，传递给子组件的函数始终都是缓存的同一个函数。</p><h2 id="26、react-redux模型图"><a href="#26、react-redux模型图" class="headerlink" title="26、react-redux模型图"></a>26、react-redux模型图</h2><p>（1）所有的UI组件都应该包裹一个容器组件，他们是父子关系；</p><p>（2）容器组件是真正和redux打交道的，里面可以随意使用redux的api；负责处理业务逻辑，向UI组件传递参数。</p><p>（3）UI组件中不能使用任何redux的api；只负责渲染页面，没有逻辑功能。</p><p>（4）容器组件会传给UI组件：1.redux中保存的状态。 2.用于操作状态的方法；</p><p>（5）备注：容器给UI传递：状态、操作状态的方法，均通过props传递；</p><!-- <img src="img/v2-1b63aef607539525cd02eccebf385127_r-16860565706992.jpg" alt="img" style="zoom:80%;" /> --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/v2-1b63aef607539525cd02eccebf385127_r-16860565706992.jpg" style="width:80%;"/></div></div>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八 VUE interview-questions</title>
      <link href="/2023/01/04/8/"/>
      <url>/2023/01/04/8/</url>
      
        <content type="html"><![CDATA[<h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="1、v-if和v-show的区别"><a href="#1、v-if和v-show的区别" class="headerlink" title="1、v-if和v-show的区别"></a>1、v-if和v-show的区别</h2><p>v-if 是删除dom结点，而v-show是通过设置display:none,实现的，dom结点还存在</p><ul><li><code>v-show</code> 由<code>false</code>变为<code>true</code>的时候不会触发组件的生命周期</li><li><code>v-if</code>由<code>false</code>变为<code>true</code>的时候，触发组件的<code>beforeCreate</code>、<code>create</code>、<code>beforeMount</code>、<code>mounted</code>钩子，由<code>true</code>变为<code>false</code>的时候触发组件的<code>beforeDestory</code>、<code>destoryed</code>方法</li></ul><p>性能消耗：<code>v-if</code>有更高的切换消耗</p><p>如果需要非常频繁地切换，则使用 v-show 较好</p><p>如果在运行时条件很少改变，则使用 v-if 较好</p><h2 id="2、v-if和v-for不建议一起用"><a href="#2、v-if和v-for不建议一起用" class="headerlink" title="2、v-if和v-for不建议一起用"></a>2、v-if和v-for不建议一起用</h2><p><code>v-for</code>优先级是比<code>v-if</code>高</p><p>一起用的话，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）</p><p>可以在v-for那个标签的外部进行v-if判断.</p><p>如果要把v-if放到v-for标签之内，可以先通过计算属性<code>computed</code>提前过滤掉那些不需要显示的项</p><h2 id="3、组件通讯"><a href="#3、组件通讯" class="headerlink" title="3、组件通讯"></a>3、组件通讯</h2><ul><li>父子关系的组件数据传递选择 <code>props</code> 与 <code>$emit</code>进行传递，也可选择<code>ref</code></li><li>兄弟关系的组件数据传递可选择<code>$bus</code>，</li><li>祖先与后代组件数据传递可选择<code>attrs</code>与<code>listeners</code>或者 <code>Provide</code>与 <code>Inject</code></li><li>复杂关系的组件数据传递可以通过<code>vuex</code>存放共享的变量</li></ul><p>props 父向子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Children</span> name=<span class="string">&quot;jack&quot;</span> age=<span class="number">18</span> /&gt;</span><br><span class="line">    </span><br><span class="line"><span class="attr">props</span>:&#123;  </span><br><span class="line">    <span class="comment">// 字符串形式  </span></span><br><span class="line"> <span class="attr">name</span>:<span class="title class_">String</span> <span class="comment">// 接收的类型参数  </span></span><br><span class="line">    <span class="comment">// 对象形式  </span></span><br><span class="line">    <span class="attr">age</span>:&#123;    </span><br><span class="line">        <span class="attr">type</span>:<span class="title class_">Number</span>, <span class="comment">// 接收的类型为数值  </span></span><br><span class="line">        <span class="attr">defaule</span>:<span class="number">18</span>,  <span class="comment">// 默认值为18  </span></span><br><span class="line">       <span class="attr">require</span>:<span class="literal">true</span> <span class="comment">// age属性必须传递  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$emit 子向父 </p><p>触发自定义事件</p><ul><li>适用场景：子组件传递数据给父组件</li><li>子组件通过<code>$emit触发</code>自定义事件，<code>$emit</code>第二个参数为传递的数值</li><li>父组件绑定监听器获取到子组件传递过来的参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  子</span></span><br><span class="line"><span class="title function_">deleteItem</span>(<span class="params">id</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.$emit(<span class="string">&#x27;delete&#x27;</span>, id)</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="comment">//  父</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">List</span> <span class="attr">:list</span>=<span class="string">&quot;list&quot;</span> @<span class="attr">delete</span>=<span class="string">&quot;deleteHandler&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="title function_">deleteHandler</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> !== id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// input封装成组件</span></span><br><span class="line">&lt;<span class="title class_">CustomInput</span> v-model=<span class="string">&quot;searchText&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="title class_">CustomInput</span>.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">defineProps</span>([<span class="string">&#x27;modelValue&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">defineEmits</span>([<span class="string">&#x27;update:modelValue&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:value</span>=<span class="string">&quot;modelValue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    @<span class="attr">input</span>=<span class="string">&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// vue3的写法</span></span><br><span class="line"><span class="comment">// 默认情况下，v-model 在组件上都是使用 modelValue 作为 prop，并以 update:modelValue 作为对应的事件。我们可以通过给 v-model 指定一个参数来更改这些名字</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-model:title</span>=<span class="string">&quot;bookTitle&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个例子中，子组件应声明一个 title prop，并通过触发 update:title 事件更新父组件值：</span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="title class_">MyComponent</span>.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">defineProps</span>([<span class="string">&#x27;title&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">defineEmits</span>([<span class="string">&#x27;update:title&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:value</span>=<span class="string">&quot;title&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    @<span class="attr">input</span>=<span class="string">&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>$bus 兄弟传值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$root</span>.<span class="property">bus</span>.$emit(<span class="string">&#x27;dong&#x27;</span>, <span class="variable language_">this</span>.<span class="property">number</span>)  <span class="comment">// 触发 dong 事件，并传递 number</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// created 生命周期函数：实例创建完成， 但是还没有挂载到 DOM</span></span><br><span class="line">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="variable language_">this</span>    <span class="comment">// 这里为什么要把 this 保存起来？</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$root</span>.<span class="property">bus</span>.$on(<span class="string">&#x27;dong&#x27;</span>, <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">      that.<span class="property">number</span> = value  <span class="comment">// 因为如果在函数里面的函数直接用this，this的值可能会改变</span></span><br><span class="line">    &#125;)                     <span class="comment">// 上面把 this 赋值给 that，那么 that 就是 Vue实例</span></span><br><span class="line">  &#125;,                       <span class="comment">// 你也可以使用 ES6 中的 箭头函数，这样 this 的值就不会变了</span></span><br><span class="line"><span class="title function_">beforeDestory</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$root</span>.<span class="property">bus</span>.<span class="title function_">off</span>(<span class="string">&#x27;dong&#x27;</span>,xxx) <span class="comment">// 及时销毁，避免内存泄漏</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4、生命周期"><a href="#4、生命周期" class="headerlink" title="4、生命周期"></a>4、生命周期</h2><!-- ![](/img/articles/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjU0MDY1,size_16,color_FFFFFF,t_70.png) --><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/articles/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjU0MDY1,size_16,color_FFFFFF,t_70.png" style="width:60%;"/></div></div><h3 id="1、created-和-mouted的区别"><a href="#1、created-和-mouted的区别" class="headerlink" title="1、created 和 mouted的区别"></a>1、created 和 mouted的区别</h3><p>created 就是初始化vue的实例，而mounted是页面已经渲染完成</p><h3 id="2、父子组件生命周期执行顺序"><a href="#2、父子组件生命周期执行顺序" class="headerlink" title="2、父子组件生命周期执行顺序"></a>2、父子组件生命周期执行顺序</h3><p>加载渲染过程</p><p>父beforecreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted</p><p>更新过程</p><p>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p><p>销毁过程</p><p>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p><h2 id="5、自定义v-model"><a href="#5、自定义v-model" class="headerlink" title="5、自定义v-model"></a>5、自定义v-model</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;value&quot;</span> /&gt;</span><br><span class="line">    <span class="comment">// 上面是下面的语法糖</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;value&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;value = $event.target.value&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>父组件展示部分</p><!-- <img src="img/image-20230521110158760.png" alt="image-20230521110158760" style="zoom:80%;" /> --><p><img src="/img/articles/image-20230521110158760.png" alt=""><br>子组件CustomVmodel</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">------------父组件</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CustomInput</span> <span class="keyword">from</span> <span class="string">&#x27;./CustomInput.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">CustomInput</span> &#125;,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">CustomInput</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> /&gt;</span> &#123;&#123; message &#125;&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">-------------子组件</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;modelValue&#x27;</span>],</span><br><span class="line">  <span class="attr">emits</span>: [<span class="string">&#x27;update:modelValue&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:value</span>=<span class="string">&quot;modelValue&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    @<span class="attr">input</span>=<span class="string">&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>展示结果</p><!-- <img src="img/image-20230704144132654.png" alt="image-20230704144132654" style="zoom:80%;" /> --><p><img src="/img/articles/image-20230704144132654.png" alt=""></p><h2 id="6、-nextTick"><a href="#6、-nextTick" class="headerlink" title="6、$nextTick"></a>6、$nextTick</h2><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</p><p><code>Vue</code> 在更新 <code>DOM</code> 时是异步执行的。当数据发生变化，<code>Vue</code>将开启一个异步更新队列，等队列中所有数据变化完成之后，再统一进行更新</p><p>第一个参数为：回调函数（可以获取最近的<code>DOM</code>结构）</p><p>第二个参数为：执行函数上下文</p><p>通过this.$nextTick（）调用</p><h2 id="7、动态组件和异步加载"><a href="#7、动态组件和异步加载" class="headerlink" title="7、动态组件和异步加载"></a>7、动态组件和异步加载</h2><div class="tag link"><a class="link-card" title="vue动态组件" href="https://blog.csdn.net/qq_57587705/article/details/124520495"><div class="left"><img src="/img/icon/wwwicon.png"/></div><div class="right"><p class="text">vue动态组件</p><p class="url">https://blog.csdn.net/qq_57587705/article/details/124520495</p></div></a></div><!-- https://blog.csdn.net/qq_57587705/article/details/124520495 --><p>vue 提供了一个内置的 <component> 组件，专门用来实现动态组件的渲染。示例代码如下：</p><!-- <img src="img/image-20230521152054664.png" alt="image-20230521152054664" style="zoom:67%;" /> --><p><img src="/img/articles/image-20230521152054664.png" alt=""></p><p>默认情况下，切换动态组件时无法保持组件的状态。此时可以使用vue 内置的 <keep-alive> 组件保持动态组 件的状态。示例代码如下：</p><!-- <img src="img/image-20230521152112412.png" alt="image-20230521152112412" style="zoom:67%;" /> --><p><img src="/img/articles/image-20230521152112412.png" alt=""></p><p>异步加载组件</p><!-- <img src="img/image-20230521152533259.png" alt="image-20230521152533259" style="zoom:80%;" /> --><p><img src="/img/articles/image-20230521152533259.png" alt=""></p><h2 id="8、mixin-混入"><a href="#8、mixin-混入" class="headerlink" title="8、mixin 混入"></a>8、mixin 混入</h2><p>抽离公共逻辑，利于代码复用</p><p>定义一个<code>mixin</code>对象，有组件<code>options</code>的<code>data</code>、<code>methods</code>属性</p><p>优先级</p><p>组件 data，methods优先级高于mixin data优先级<br>生命周期函数，先执行 mixin 里面的，再执行组件里面的</p><p>自定义的属性，组件中的属性优先级高于mixin属性的优先级</p><p><strong>局部使用</strong></p><!-- <img src="img/image-20230521154109305.png" alt="image-20230521154109305" style="zoom:80%;" /> --><p><img src="/img/articles/image-20230521154109305.png" alt=""></p><p><strong>全局使用</strong></p><!-- <img src="img/image-20230521154224270.png" alt="image-20230521154224270" style="zoom:67%;" /> --><p><img src="/img/articles/image-20230521154224270.png" alt=""></p><p><strong>问题</strong></p><p>变量来源不明确，不利于阅读</p><p>多mixin 可能会造成命名冲突</p><p>mixin和组件可能出现多对多的关系，复杂度较高</p><h2 id="9、v-for中为什么要用key"><a href="#9、v-for中为什么要用key" class="headerlink" title="9、v-for中为什么要用key"></a>9、v-for中为什么要用key</h2><!-- <img src="img/image-20230521223012666.png" alt="image-20230521223012666" style="zoom:50%;" /> --><p><img src="/img/articles/image-20230521223012666.png" alt=""></p><h2 id="10、何时使用beforeDestory"><a href="#10、何时使用beforeDestory" class="headerlink" title="10、何时使用beforeDestory"></a>10、何时使用beforeDestory</h2><!-- <img src="img/image-20230521223854366.png" alt="image-20230521223854366" style="zoom:50%;" /> --><p><img src="/img/articles/image-20230521223854366.png" alt=""></p><h2 id="11、vuex中action和mutaion的区别"><a href="#11、vuex中action和mutaion的区别" class="headerlink" title="11、vuex中action和mutaion的区别"></a>11、vuex中action和mutaion的区别</h2><!-- <img src="img/image-20230521224029245.png" alt="image-20230521224029245" style="zoom:67%;" /> --><p><img src="/img/articles/image-20230521224029245.png" alt=""></p><h2 id="12、vue如何监听数组变化"><a href="#12、vue如何监听数组变化" class="headerlink" title="12、vue如何监听数组变化"></a>12、vue如何监听数组变化</h2><!-- <img src="img/image-20230521224250754.png" alt="image-20230521224250754" style="zoom:80%;" /> --><p><img src="/img/articles/image-20230521224250754.png" alt=""></p><h2 id="13、vue常见的性能优化"><a href="#13、vue常见的性能优化" class="headerlink" title="13、vue常见的性能优化"></a>13、vue常见的性能优化</h2><p>合理使用 v-show 和 v-if</p><p>合理使用 computed </p><p>v-for 时加key，以及避免和v-if同时使用</p><p>自定义事件、DOM事件及时销毁<br>合理使用异步组件<br>合理使用keep-alive</p><p>data层级不能太深</p><h2 id="14、vue3和vue2的区别？"><a href="#14、vue3和vue2的区别？" class="headerlink" title="14、vue3和vue2的区别？"></a>14、vue3和vue2的区别？</h2><p>1、支持ts</p><p>2、代码组织更有逻辑</p><p>3、支持逻辑复用</p><h2 id="15、setup中如何获取vue的实例"><a href="#15、setup中如何获取vue的实例" class="headerlink" title="15、setup中如何获取vue的实例"></a>15、setup中如何获取vue的实例</h2><p>通过getCurrentUnstance（）这个方法</p><p>在setup和其他Composition API中没有this<br>可通过getCurrentInstance获取当前实例<br>若使用Options API可照常使用this</p><!-- <img src="img/image-20230522162008547.png" alt="image-20230522162008547" style="zoom:80%;" /> --><p><img src="/img/articles/image-20230522162008547.png" alt=""></p><h2 id="16、vue3为何比vue2快"><a href="#16、vue3为何比vue2快" class="headerlink" title="16、vue3为何比vue2快"></a>16、vue3为何比vue2快</h2><p>1、Proxy响应式<br>2、PatchFlag</p><p>编译模板时，<strong>动态节点做标记</strong></p><p>标记，分为不同的类型，如TEXT PROPS </p><p><strong>diff算法时，可以区分静态节点，以及不同类型的动态节点</strong></p><p>3、cacheHandler</p><p>缓存事件</p><p>4、SSR 优化<br>5、hoistStatic</p><p>将静态节点的定义，提升到父作用域，缓存起来</p><p>多个相邻的静态节点，会被合并起来</p><p>典型的拿<strong>空间换时间的优化</strong>策略</p><p>6、tree-shaking</p><p>动态引入需要的内容，不需要的不引入进来</p><h2 id="17、vue和react的区别"><a href="#17、vue和react的区别" class="headerlink" title="17、vue和react的区别"></a>17、vue和react的区别</h2><p>1、框架比较</p><p>vue简单、上手容易、框架功能完善。</p><p>react学习成本高、框架功能强大、很灵活、社区资源丰富。</p><p>2、监听数据方式不同</p><p>vue通过响应式的setter、getter监听数据</p><p>react数据不可变，需要setState驱动新的state替换老的state</p><p>3、diff算法不同</p><p><strong>相同点：</strong><br>Vue和react的diff算法，都是不进行跨层级比较，只做同级比较</p><p><strong>不同点：</strong></p><ol><li>vue会在patch函数中给被操作的节点打补丁（patchflag），在diff的时候更清晰</li><li>vue对比节点，当节点元素类型相同，但是className不同时，认为是不同类型的元素，删除重新创建；而react则认为是同类型节点，进行修改操作</li><li>diff策略，vue的性能优于react</li></ol><p>4、jsx和template</p><h2 id="18、vue3-v-for动态绑定ref问题"><a href="#18、vue3-v-for动态绑定ref问题" class="headerlink" title="18、vue3 v-for动态绑定ref问题"></a>18、vue3 v-for动态绑定ref问题</h2><div class="tag link"><a class="link-card" title="v-for动态绑定ref" href="https://segmentfault.com/q/1010000042019257"><div class="left"><img src="/img/icon/wwwicon.png"/></div><div class="right"><p class="text">v-for动态绑定ref</p><p class="url">https://segmentfault.com/q/1010000042019257</p></div></a></div><p>在setup中可以收集到到元素的ref引入，但是当childApp变化时如删除，新增，childAppRefs会push重复的元素。</p><p>不过不一定非得用数组，你也可以用个对象来装，以索引为 Key、然后过滤掉比数据源数组长度还大的那些 Key：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;child v-<span class="keyword">for</span>=<span class="string">&quot;(item, index) in list&quot;</span> :ref=<span class="string">&quot;el =&gt; setChildRef(el, index)&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 你也可以抽成一个 hooks，用起来更方便</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> childRefs = &#123;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> computedChildRefs = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(childRefs)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    .<span class="title function_">filter</span>(<span class="function">(<span class="params">[index, ref]</span>) =&gt;</span> +index &lt; list.<span class="property">length</span> &amp;&amp; !!ref)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    .<span class="title function_">map</span>(<span class="function">(<span class="params">[_, ref]</span>) =&gt;</span> ref)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> <span class="title function_">setChildRef</span> = (<span class="params">el, index</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  childRefs[index] = el</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七  项目角色和流程</title>
      <link href="/2022/12/15/7/"/>
      <url>/2022/12/15/7/</url>
      
        <content type="html"><![CDATA[<h1 id="项目角色和流程"><a href="#项目角色和流程" class="headerlink" title="项目角色和流程"></a>项目角色和流程</h1><!-- <img src="img/image-20230601201948892.png" alt="image-20230601201948892" style="zoom:70%;" /> --><p><img src="/img/articles/image-20230601201948892.png" alt=""></p><!-- <img src="img/image-20230601203822270.png" alt="image-20230601203822270" style="zoom:67%;" /> --><p><img src="/img/articles/image-20230601203822270.png" alt=""></p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul><li>了解背景</li><li>质疑需求是否合理</li><li>需求是否闭环</li><li>开发难度如何</li><li>是否需要其他支持</li><li>不要急于给排期</li></ul><!-- <img src="img/image-20230601204434636.png" alt="image-20230601204434636" style="zoom:67%;" /> --><p><img src="/img/articles/image-20230601204434636.png" alt=""></p><h2 id="技术方案设计"><a href="#技术方案设计" class="headerlink" title="技术方案设计"></a>技术方案设计</h2><ul><li>求简，不过渡设计</li><li>产出文档</li><li>找准设计重点</li><li>组内评审</li><li>和 RD CRD 沟通</li><li>发出会议结论</li></ul><!-- <img src="img/image-20230601204959094.png" alt="image-20230601204959094" style="zoom:67%;" /> --><p><img src="/img/articles/image-20230601204959094.png" alt=""></p><!-- <img src="img/image-20230602102905110.png" alt="image-20230602102905110" style="zoom:60%;" /> --><p><img src="/img/articles/image-20230602102905110.png" alt=""><br><!-- <img src="img/image-20230602103221439.png" alt="image-20230602103221439" style="zoom:67%;" /> --><br><img src="/img/articles/image-20230602103221439.png" alt=""><br><!-- <img src="img/image-20230602103238582.png" alt="image-20230602103238582" style="zoom:67%;" /> --><br><img src="/img/articles/image-20230602103238582.png" alt=""><br><!-- <img src="img/image-20230602103602361.png" alt="image-20230602103602361" style="zoom:67%;" /> --><br><img src="/img/articles/image-20230602103602361.png" alt=""><br><!-- <img src="img/image-20230602103630086.png" alt="image-20230602103630086" style="zoom:67%;" /> --><br><img src="/img/articles/image-20230602103630086.png" alt=""><br><!-- <img src="img/image-20230602103836045.png" alt="image-20230602103836045" style="zoom:67%;" /> --><br><img src="/img/articles/image-20230602103836045.png" alt=""><br><!-- <img src="img/image-20230602104218047.png" alt="image-20230602104218047" style="zoom:67%;" /> --><br><img src="/img/articles/image-20230602104218047.png" alt=""></p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>1、PM 想在项目开发过程中增加需求，该怎么办？</p><p>不能拒绝，走需求变更流程即可。如果公司有规定，则按规定走。否则，发起项目组和 leader 的评审，重新评估排期</p><p>2、项目即将延期了，该怎么办？</p><ul><li>整体调整，改变项目计划。</li><li>并行任务，缩短执行工时</li><li>增加资源，以成本换时间</li><li>协商谈判，先完成最“需要”</li></ul><p>3、你将如何保证项目质量？</p><ul><li>符合开发规范</li><li>及时单元测试</li><li>写出开发文档</li><li>Mock API</li><li>Code Review</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目角色和流程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目角色和流程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六 项目部署与上线</title>
      <link href="/2022/11/01/6/"/>
      <url>/2022/11/01/6/</url>
      
        <content type="html"><![CDATA[<h1 id="项目部署与上线"><a href="#项目部署与上线" class="headerlink" title="项目部署与上线"></a>项目部署与上线</h1><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>镜像，容器，仓库的三者关系</p><p><img src="/img/articles/image-20221110105214725.png" alt=""></p><p>常用命令</p><p><img src="/img/articles/image-20221110100215207.png" alt=""></p><p>docker操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull <span class="attr">centos</span>:</span><br></pre></td></tr></table></figure><h2 id="dockerfile和阿里云"><a href="#dockerfile和阿里云" class="headerlink" title="dockerfile和阿里云"></a>dockerfile和阿里云</h2><p>制作镜像 （<strong>使用时删掉//后的备注</strong>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># 第一个阶段: 拉取node镜像来打包<span class="title class_">React</span>项目</span><br><span class="line"><span class="variable constant_">FROM</span> <span class="attr">node</span>:<span class="number">14</span> <span class="keyword">as</span> build</span><br><span class="line"><span class="variable constant_">WORKDIR</span> /app</span><br><span class="line"><span class="variable constant_">COPY</span> package*.<span class="property">json</span> ./</span><br><span class="line"><span class="variable constant_">RUN</span> npm install</span><br><span class="line"><span class="variable constant_">COPY</span> jsconfig.<span class="property">json</span> ./</span><br><span class="line"><span class="variable constant_">COPY</span> craco.<span class="property">config</span>.<span class="property">js</span> ./</span><br><span class="line"><span class="variable constant_">COPY</span> public public/</span><br><span class="line"><span class="variable constant_">COPY</span> src src/</span><br><span class="line"><span class="variable constant_">RUN</span> npm run build</span><br><span class="line"></span><br><span class="line"># 第二个阶段: 创建并运行<span class="title class_">Ngnix</span>服务器，并且把打包好的文件复制粘贴到服务器文件夹中</span><br><span class="line"><span class="variable constant_">FROM</span> <span class="attr">nginx</span>:alpine</span><br><span class="line"><span class="variable constant_">COPY</span> --<span class="keyword">from</span>=build /app/build/ <span class="regexp">/usr/</span>share/nginx/html</span><br><span class="line"><span class="variable constant_">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="variable constant_">CMD</span> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"># 第一个阶段: 拉取node镜像来打包<span class="title class_">React</span>项目</span><br><span class="line">## 拉取node镜像 版本<span class="number">14</span> 命名为build</span><br><span class="line"><span class="variable constant_">FROM</span> <span class="attr">node</span>:<span class="number">14</span> <span class="keyword">as</span> build</span><br><span class="line">## 设置docker命令运行目录</span><br><span class="line"><span class="variable constant_">WORKDIR</span> /app</span><br><span class="line">## 复制对应文件到app文件夹中 app/</span><br><span class="line"><span class="variable constant_">COPY</span> package*.<span class="property">json</span> ./</span><br><span class="line">## 安装项目依赖</span><br><span class="line"><span class="variable constant_">RUN</span> npm install</span><br><span class="line">## 复制对应文件到app文件夹中 app/</span><br><span class="line"><span class="variable constant_">COPY</span> tsconfig.<span class="property">json</span> ./</span><br><span class="line">## 复制public文件夹并创建public文件夹</span><br><span class="line"><span class="variable constant_">COPY</span> public public/</span><br><span class="line">## 复制src文件夹并创建src文件夹</span><br><span class="line"><span class="variable constant_">COPY</span> src src/</span><br><span class="line">## 构建react项目</span><br><span class="line"><span class="variable constant_">RUN</span> npm run build</span><br><span class="line"></span><br><span class="line"># 第二个阶段: 创建并运行<span class="title class_">Ngnix</span>服务器，并且把打包好的文件复制粘贴到服务器文件夹中</span><br><span class="line">## 拉取nginx服务器镜像 :执行版本</span><br><span class="line"><span class="variable constant_">FROM</span> <span class="attr">nginx</span>:alpine</span><br><span class="line">## 将第一阶段通过npm run build构建好的react项目复制到nginx服务器镜像中</span><br><span class="line"><span class="variable constant_">COPY</span> --<span class="keyword">from</span>=build /app/build/ <span class="regexp">/usr/</span>share/nginx/html</span><br><span class="line">## 暴露nginx服务器端口</span><br><span class="line"><span class="variable constant_">EXPOSE</span> <span class="number">80</span></span><br><span class="line">## 使用<span class="variable constant_">CMD</span>命令来启动nginx命令</span><br><span class="line"><span class="variable constant_">CMD</span> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为<span class="variable constant_">CSDN</span>博主「陈坚泓」的原创文章，遵循<span class="variable constant_">CC</span> <span class="number">4.0</span> <span class="variable constant_">BY</span>-<span class="variable constant_">SA</span>版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：<span class="attr">https</span>:<span class="comment">//blog.csdn.net/weixin_42752574/article/details/122594056</span></span><br></pre></td></tr></table></figure><ol><li><p>在此文件夹的cmd命令窗口输入 docker build -t react-web .    // (react-web)是自己取的镜像名 构建react-web镜像</p></li><li><p>然后docker images 查看当前所有的镜像</p></li><li><p>docker run -d -p 12231:80    react-web  将nginx服务器的80端口映射给电脑的12231端口</p></li><li><p>docker ps   查看运行的容器</p></li><li><p>可以在本机上输入localhost:12231进入查看项目了</p></li></ol><p>阿里云操作</p><p><a href="https://www.acwing.com/blog/content/20977/">https://www.acwing.com/blog/content/20977/</a></p><p>1.创建云服务器ECS实例<br>2.点击实例列表中的远程连接，方式选Workbench远程连接然后输入密码<br>3.通过以下四个命令添加yum源 </p><p><img src="/img/articles/image-20221112150553901.png" alt=""></p><p>4.安装docker yum install docker-io -y<br>5.启动docker systemctl start docker<br>6.查看安装结果docker info<br>7.启动阿里云的容器镜像服务 </p><p>先开启阿里云容器镜像服务，然后进入镜像加速器，按照指引把命令复制到终端运行（然后docker加速器就添加成功了）</p><p>8.接下里就是本课第五步，本地构建课程实战项目的docker镜像<br>打开命令行，cd 到项目文件夹<br>使用命令docker build -t react-web . ，然后镜像就创建成功了<br>运行docker images查看一下</p><p>9.课程的第六步：在阿里云镜像服务中创建我们的私人docker镜像仓库<br>打开阿里云容器镜像服务，点击镜像仓库，点击创建镜像仓库（代码源选本地仓库），然后点击仓库进入仓库的操作文档</p><p>首先复制第一条命令登录仓库，然后填写阿里云登陆密码<br>然后复制第3命令去推送镜像，其中命令里的版本号是自定义的（比如1.0.0），ImageId可以在docker images里找到。</p><p>在镜像仓库文档页面左侧点击镜像版本，就可以看到刚上传好的镜像了<br>接下来就要在ECS服务器上部署这个docker镜像了，所以到仓库基本信息页复制第2条命令<br>拉取成功之后就要部署这个镜像了docker run -d -p 12231:80 第2里的命令pull后面<strong>跟着的仓库地址</strong><br>然后docker就运行起来了，运行docker ps查看一下状态</p><p>10.由于ECS服务器的实例安全策略，我们暂时没法从外部访问项目的端口12231，所以我们需要配置一下</p><p>打开ECS实例列表，点击实例名称，在基本信息栏中找到配置安全组规则，然后在普通安全组中找到配置规则，点击手动添加，在端口范围目的中输入12231/12231，授权对象源输入0.0.0.0/0【表示不对外部 ip 做任何显示】</p><p>然后等待几分钟，等安全策略规则响应，然后回到实例列表，复制ECS实例公网地址+端口号:12231到浏览器</p>]]></content>
      
      
      <categories>
          
          <category> 部署与上线 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署与上线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五 webpack</title>
      <link href="/2022/10/15/5/"/>
      <url>/2022/10/15/5/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="1-webpack的构建流程"><a href="#1-webpack的构建流程" class="headerlink" title="1. webpack的构建流程"></a>1. webpack的构建流程</h2><ul><li>初始化流程：从配置文件和 <code>Shell</code> 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</li><li>编译构建流程：从 Entry 发出，针对每个 Module 调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li><li>输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统</li></ul><p><img src="/img/articles/image-20230315103216597.png" alt=""></p><h2 id="2-loader"><a href="#2-loader" class="headerlink" title="2. loader"></a>2. loader</h2><p>loader 让 webpack 能够去<strong>处理那些非 JavaScript 文件</strong>（<strong>webpack 自身只理解 JavaScript</strong>）loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块。loader扮演一个翻译官的角色</p><p>常见的<code>loader</code>如下：</p><ul><li>style-loader: 将css添加到DOM的内联样式标签style里</li><li>css-loader :允许将css文件通过require的方式引入，并返回css代码</li><li>less-loader: 处理less</li><li>sass-loader: 处理sass</li><li>postcss-loader: 用postcss来处理CSS</li><li>autoprefixer-loader: 处理CSS3属性前缀，已被弃用，建议直接使用postcss</li><li>file-loader: 分发文件到output目录并返回相对路径</li><li>url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url</li><li>html-minify-loader: 压缩HTML</li><li>babel-loader :用babel来转换ES6文件到ES5</li></ul><h2 id="3-plugin"><a href="#3-plugin" class="headerlink" title="3. plugin"></a>3. plugin</h2><p>plugin是插件的意思,对webpack现有功能的各种扩展.</p><p>例如打包优化、资源管理、环境变量注入等，它们会运行在 <code>webpack</code> 的不同阶段，贯穿了<code>webpack</code>整个编译周期,目的在于解决<code>loader</code> 无法实现的其他事.</p><h2 id="4-loader和plugin的区别："><a href="#4-loader和plugin的区别：" class="headerlink" title="4. loader和plugin的区别："></a>4. loader和plugin的区别：</h2><p>作用：</p><ul><li>loader主要用于转换某些类型的模块为wepack能够识别的js模块，是一个加载器；</li><li>plugin是插件，对webpack本身进行扩展，是一个扩展器；</li></ul><p>作用时机：plugin运行在 <code>webpack</code> 的不同阶段，贯穿了<code>webpack</code>整个编译周期，loader在模块转换阶段</p><h2 id="5-热更新"><a href="#5-热更新" class="headerlink" title="5. 热更新"></a>5. 热更新</h2><p>它可以使得代码修改之后，不用刷新浏览器就可以更新，在应用过程中替换添加删出模块，无需重新加载整个页面，是高级版的自动刷新浏览器。</p><h2 id="6-webpack-proxy"><a href="#6-webpack-proxy" class="headerlink" title="6. webpack proxy"></a>6. webpack proxy</h2><p>即<code>webpack</code>提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在<strong>开发模式下</strong>解决跨域问题，想要实现代理首先需要一个中间服务器，<code>webpack</code>中提供服务器的工具为<code>webpack-dev-server</code></p><p><strong>服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制</strong></p><h2 id="7-如何借助webpack来优化前端性能"><a href="#7-如何借助webpack来优化前端性能" class="headerlink" title="7. 如何借助webpack来优化前端性能"></a>7. 如何借助webpack来优化前端性能</h2><ul><li>JS代码压缩    压缩：删除多余的代码、注释、简化代码的写法等等⽅式</li><li>CSS代码压缩</li><li>Html文件代码压缩</li><li>文件大小压缩</li><li>图片压缩</li><li>Tree Shaking 将未用到的代码进行删除</li><li>代码分离</li><li>内联 chunk</li><li>利用CDN加速</li><li>使用mode:production 自动开启代码压缩 还会自动使用Tree Shaking</li></ul><h2 id="8-如何优化构建速度"><a href="#8-如何优化构建速度" class="headerlink" title="8. 如何优化构建速度"></a>8. 如何优化构建速度</h2><p>npm install 过程中的优化 使用 yarn去安装npm包</p><p>具体仓库地址的选择，选择使用淘宝提供的npm仓库镜像</p><p><img src="/img/articles/image-20230315105441362.png" alt=""></p><p>1、优化lodaer配置</p><p>在使用<code>loader</code>时，可以通过配置<code>include</code>、<code>exclude</code>、<code>test</code>属性来匹配文件。</p><ul><li><code>include</code>：包含，只处理<code>xxx</code>文件</li><li><code>exclude</code>：排除，除了<code>xxx</code>文件以外其他文件都处理</li></ul><p>需要注意的是<code>include</code>和<code>exclude</code>只能二选一</p><p>2、优化 resolve.alias</p><p><code>alias</code>给一些常用的路径起一个别名，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是<code>./../../</code>的形式、</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">resolve</span>:&#123;</span><br><span class="line">        <span class="attr">alias</span>:&#123;</span><br><span class="line">            <span class="string">&quot;@&quot;</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;./src&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用cache-loader</p><p>在一些性能开销较大的 <code>loader</code>之前添加 <code>cache-loader</code>，以将结果缓存到磁盘里，显著提升二次构建速度。</p><p>保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 <code>loader</code> 使用此<code>loader</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.ext$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [<span class="string">&#x27;cache-loader&#x27;</span>, ...loaders],</span><br><span class="line">                <span class="attr">include</span>: path.<span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4、happyPack 多进程打包</p><p>JS（Node.js/Webpack）是<strong>单线程</strong>的，因此如果开启<strong>多进程</strong>打包，可以提高构建速度（特别是多核 CPU）。</p><p>项目较大，打包较慢，开启多进程能提高速度</p><p>项目较小，打包很快，开启多进程会降低速度（进程开销）</p><p>5、开启多进程压缩（生产）</p><p>Webpack 内置了 Uglify 工具压缩 JS，但它是单进程的。开启多进程压缩会更快，和 happyPack 同理。</p><p>首先需要安装 ParallelUglifyPlugin：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-parallel-uglify-plugin --save-dev</span><br></pre></td></tr></table></figure><p>6、开启热更新(开发)</p><p>热更新：新代码生效，网页不刷新，状态不丢失</p><p>代码配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="comment">// 开启 HMR 特性</span></span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment">// hotOnly: true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过上述这种配置，如果我们修改并保存css文件，确实能够以不刷新的形式更新到页面中。但是，当我们修改并保存js文件之后，页面依旧自动刷新了，这里并没有触发热模块。所以，HMR并不像 Webpack 的其他特性一样可以开箱即用，需要有一些额外的操作。我们需要去指定哪些模块发生更新时进行HRM，如下代码：</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">module</span>.<span class="property">hot</span>)&#123;</span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(<span class="string">&#x27;./util.js&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;util.js更新了&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、使用tree sharking 将未用到的代码进行删除</p><p>8、使用 DLLPlugin 插件(开发)</p><p><code>DLL</code>全称是 动态链接库，是为软件在winodw种实现共享函数库的一种实现方式，而Webpack也内置了DLL的功能，为的就是可以共享，不经常改变的代码，抽成一个共享的库。这个库在之后的编译过程中，会被引入到其他项目的代码中</p><p>使用步骤分成两部分：</p><ul><li>打包一个 DLL 库</li><li>引入 DLL 库</li></ul><p>9、noParse</p><p>这是module中的一个属性，作用：不去解析属性值代表的库的依赖</p><h2 id="9、前端为何要进行打包和构建？"><a href="#9、前端为何要进行打包和构建？" class="headerlink" title="9、前端为何要进行打包和构建？"></a>9、前端为何要进行打包和构建？</h2><p>1、代码层面</p><ul><li>代码体积更小（Tree-Shaking、压缩、合并），加载更快</li><li>编译高级语言或语法（TS，ES6+，模块化，scss）</li><li>兼容性和错误检查（Polyfill，postcss，eslint）</li></ul><p>2、前端工程化</p><ul><li>统一、高效的开发环境</li><li>统一的构建流程和产出标准</li><li>集成公司构建规范（提测、上线等）</li></ul><h2 id="10、module-chunk-bundle-的区别"><a href="#10、module-chunk-bundle-的区别" class="headerlink" title="10、module chunk bundle 的区别"></a>10、module chunk bundle 的区别</h2><ul><li>module-各个源码文件，webpack 中一切皆模块</li><li>chunk-多模块合并成的，如 entry import（）splitChunk </li><li>bundle-最终的输出文件</li></ul><p><img src="/img/articles/image-20230528160202149.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四 计算机网络</title>
      <link href="/2022/09/01/4/"/>
      <url>/2022/09/01/4/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1-http2-与-http1-之间的区别？"><a href="#1-http2-与-http1-之间的区别？" class="headerlink" title="1. http2 与 http1 之间的区别？"></a>1. http2 与 http1 之间的区别？</h2><p>1.<strong>新的二进制格式</strong>：HTTP2 采用二进制格式而 HTTP1 使用文本格式。</p><p>2.<strong>多路复用</strong>：HTTP2 是完全多路复用的，而非有序并阻塞的，只需一个连接即可实现并行。HTTP1 一个连接只能发送一个请求。</p><p>3.<strong>首部压缩</strong>：HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。</p><p>4.<strong>服务器推送</strong>：HTTP2 在客端请求资源的时候，会把相关的资源一起发送给客户端，而不需要客户端再次发起请求获取资源。</p><p>原文链接：<a href="https://blog.csdn.net/weixin_40300870/article/details/127305593">https://blog.csdn.net/weixin_40300870/article/details/127305593</a></p><h2 id="2-websocket"><a href="#2-websocket" class="headerlink" title="2. websocket"></a>2. websocket</h2><p>WebSocket 是 HTML5 下一种基于 tcp 的能够全双工通信的持久化协议。</p><p>同：都是基于 tcp 协议的，都是可靠的传输协议。都是应用层的。</p><p>http 协议是单向的、无状态、无连接的通信协议，通信只能客户端请求，服务器回答，一次 tcp 连接只能发起一次请求。而 Websocket 允许客户端和服务器全双工通讯，只需一次连接，长久通信。</p><h2 id="3-强制缓存与协商缓存"><a href="#3-强制缓存与协商缓存" class="headerlink" title="3. 强制缓存与协商缓存"></a>3. 强制缓存与协商缓存</h2><p><a href="https://www.jianshu.com/p/fb59c770160c/">https://www.jianshu.com/p/fb59c770160c/</a></p><p>缓存的原理：在首次请求后保存一份请求资源的响应副本，当用户再次发起相同请求后，如果判断缓存命中则拦截请求，将之前存储的响应副本返回给用户，从而避免重新向服务器发起资源请求。</p><p>强制缓存： 通过 cache-control 和 expires 判断资源是否过期，没过期直接使用缓存资源，返回 200，过期重新发起请求，与强制缓存相关的两个字段：<strong>expires、cache-control</strong><br>协商缓存：通过 get 去<strong>请求服务器验证</strong>资源是否更新，如果没更新返回 304 继续使用本地缓存，过期就返回 200。主要通过<strong>last-modified</strong>和<strong>etag</strong>值判断</p><h2 id="4-在浏览器输入-url-后会发生的过程："><a href="#4-在浏览器输入-url-后会发生的过程：" class="headerlink" title="4. 在浏览器输入 url 后会发生的过程："></a>4. 在浏览器输入 url 后会发生的过程：</h2><p>1.DNS 对域名进行解析； 2.建立 TCP 连接（<a href="https://so.csdn.net/so/search?q=三次握手&amp;spm=1001.2101.3001.7020">三次握手</a>）； 3.发送 HTTP 请求； 4.服务器处理请求； 5.返回响应结果； 6.关闭 TCP 连接（四次挥手）； 7.浏览器解析 HTML； 8.浏览器布局渲染；</p><h2 id="5-http-和-https-区别"><a href="#5-http-和-https-区别" class="headerlink" title="5. http 和 https 区别"></a>5. http 和 https 区别</h2><p>1、HTTP 协议以明文方式发送内容，不提供任何方式的数据加密。HTTP 协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。https 则是具有安全性的 ssl 加密传输协议。2、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。3、并且 https 协议需要到 ca 申请证书。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。</p><ol><li>网络攻击 XSS 和 CSRF</li></ol><p>xss，即 Cross Site Script，中文翻译是跨站脚本攻击。XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。</p><p>应对：1、<strong>HttpOnly 防止劫取 Cookie</strong>， 2、<strong>输入检查</strong>，一般是检查用户输入的数据中是否包含 &lt;，&gt; 等特殊字符，如果存在，则对特殊字符进行过滤或编码，3、<strong>输出检查</strong></p><p>CSRF，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p><p>应对：1 添加 token 认证，2 验证码，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。</p><h2 id="6-从输入-url-到页面完成加载发生了什么"><a href="#6-从输入-url-到页面完成加载发生了什么" class="headerlink" title="6. 从输入 url 到页面完成加载发生了什么"></a>6. 从输入 url 到页面完成加载发生了什么</h2><p><a href="https://blog.csdn.net/china_coding/article/details/127188830">https://blog.csdn.net/china_coding/article/details/127188830</a></p><ul><li><p>DNS 解析：将域名解析成 IP 地址</p></li><li><p>TCP 连接：TCP 三次握手</p></li><li><p>发送 HTTP 请求</p></li><li><p>服务器处理请求并返回 HTTP 报文</p></li><li><p>浏览器解析渲染页面</p></li></ul><h2 id="7-CDN"><a href="#7-CDN" class="headerlink" title="7. CDN"></a>7. CDN</h2><p>Content Delivery Network，内容分发⽹络，CDN 是指⼀种通过互联⽹互相连接的⽹络系统，利⽤最靠近⽤户的服务器，更快、更可靠地将资源发送给⽤户。</p><p>CDN 的作⽤ ：</p><p>CDN ⼀般会⽤来托管 Web 资源（包括⽂本、图⽚和脚本等），可供下载的资源（媒体⽂件、软件、⽂档 等），应⽤程序（⻔户⽹站等）。使⽤ CDN 来加速这些资源的访问。</p><p>（1）在性能⽅⾯，引⼊ CDN 的作⽤在于： ⽤户收到的内容来⾃最近的数据中⼼，延迟更低，内容加载更快，部分资源请求分配给了 CDN，减少了服务器的负载。</p><p>（2）在安全⽅⾯，CDN 有助于防御 DDoS、MITM 等⽹络攻击： 针对 DDoS：通过监控分析异常流量，限制其请求频率 针对 MITM：从源服务器到 CDN 节点到 ISP（Internet Service Provider），全链路 HTTPS 通信 除此之外，CDN 作为⼀种基础的云服务，同样具有资源托管、按需扩展（能够应对流量⾼峰）等⽅⾯的 优势。</p><h2 id="8-浏览器状态码"><a href="#8-浏览器状态码" class="headerlink" title="8. 浏览器状态码"></a>8. 浏览器状态码</h2><p><img src="/img/articles/image-20230401170135854.png" alt=""></p><p><strong>1xx</strong></p><p>100：（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</p><p>101：（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</p><p>102：由 WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</p><p><strong>2XX</strong></p><p>200：（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</p><p>201：（已创建） 请求成功并且服务器创建了新的资源。</p><p>202：（已接受） 服务器已接受请求，但尚未处理。</p><p>203：（非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</p><p>204：（无内容） 服务器成功处理了请求，但没有返回任何内容。</p><p>205：（重置内容） 服务器成功处理了请求，但没有返回任何内容。</p><p>206：（部分内容） 服务器成功处理了部分 GET 请求。</p><p>208：（已经报告）一个 DAV 的绑定成员被前一个请求枚举，并且没有被再一次包括。</p><p>226：（IM Used）服务器已经满足了请求所要的资源，并且响应是一个或者多个实例操作应用于当前实例的结果。</p><p><strong>3XX</strong></p><p>300：（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</p><p>301：（<strong>永久移动</strong>） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</p><p>302：（<strong>临时移动</strong>） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>303：（<strong>查看其他位置</strong>） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</p><p>304：（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</p><p>305：（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</p><p>307：（<strong>临时重定向</strong>） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>308：（永久转移）这个请求和以后的请求都应该被另一个 URI 地址重新发送。307、308 和 302、301 有相同的表现，但是不允许 HTTP 方法改变。例如，请求表单到一个永久转移的资源将会继续顺利地执行。</p><p><strong>4XX</strong></p><p>400:（错误请求) 服务器不理解请求的语法。</p><p>401：(未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p><p>402：该状态码是为了将来可能的需求而预留的。</p><p>403：（禁止) 服务器拒绝请求。</p><p>404：（未找到) 服务器找不到请求的网页。</p><p><strong>5XX</strong></p><p>500：（服务器内部错误） 服务器遇到错误，无法完成请求。</p><p>501：（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</p><p>502：（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</p><p>503：（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</p><p>504：（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p><p>505：（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p><p>200 表示服务器<strong>响应成功</strong></p><p>301 代表的是<strong>永久性的重定向</strong></p><p>302 代表<strong>临时跳转</strong>，URL 地址 A 可以向 URL 地址 B 上跳转</p><p>304 可以告诉客户端<strong>请求资源成功</strong></p><p>403 代表请求的服务器资源<strong>权限不够</strong></p><p>404 代表服务器上<strong>没有该资源</strong></p><p>500 代表<strong>程序错误</strong></p><h2 id="9-get-和-post-的区别"><a href="#9-get-和-post-的区别" class="headerlink" title="9. get 和 post 的区别"></a>9. get 和 post 的区别</h2><p><strong>本质区别：</strong>GET 是从服务器上<strong>获得数据</strong>；POST 是向服务器<strong>传递数据</strong></p><p><strong>数据传输上：</strong></p><p>get，通过拼接 url 进行传递参数；</p><p>post，通过 body 体传输参数</p><p><strong>缓存性：</strong></p><p>get 请求是可以缓存的</p><p>post 请求不可以缓存</p><p><strong>后退页面的反应：</strong></p><p>get 请求页面后退时，不产生影响</p><p>post 请求页面后退时，会重新提交请求</p><p><strong>大小限制</strong></p><p>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有</p><h2 id="10-浏览器渲染流程"><a href="#10-浏览器渲染流程" class="headerlink" title="10. 浏览器渲染流程"></a>10. 浏览器渲染流程</h2><p><img src="/img/articles/image-20230401204636208.png" alt=""></p><p>1、解析 html 文件，生成 dom 树，并行下载 css/js/img 文件</p><p>2、css 下载完成后，生成 cssom 树</p><p>3、根据 dom 树和 css 树，生成 render 树</p><p>4、重排：计算各元素的位置和大小</p><p>5、重绘：将计算的结果渲染到页面上</p><p><img src="/img/articles/image-20230401203143141.png" alt=""></p><p>（js 执行会阻塞 DOM 树的解析和渲染），所以可以加上 defer 和 async</p><p>正常情况下，当浏览器在解析 HTML 源文件时如果遇到外部的 script，那么解析过程会暂停，并发送请求来下载 script 文件，只有 script 完全下载并执行后才会继续执行 DOM 解析。</p><p>defer(延期、推迟)</p><p>让 js 脚本在文档解析完成后才执行，DOMContentLoaded 之前执行</p><p><img src="/img/articles/image-20230401204044605.png" alt=""></p><p>ansyc(异步)</p><p>js 脚本和浏览器的渲染是异步执行的</p><ul><li>css 加载不会阻塞 DOM 树的解析</li><li>css 加载会阻塞 DOM 树的渲染</li><li>css 加载会阻塞后面 js 语句的执行 原因（由于 js 可能会操作之前的 Dom 节点和 css 样式，因此浏览器会维持 html 中 css 和 js 的顺序，因此，样式表会在后面的 js 执行前先加载执行完毕。所以 css 会阻塞后面 js 的执行。）</li></ul><p>css 加载会不会阻塞 js 的加载？（不会）</p><p>css 加载会不会阻塞 js 的执行？（会）</p><p>css 加载会不会阻塞 DOM 的解析？（不会）</p><p>css 加载会不会阻塞 DOM 的渲染？（会）</p><p>js 加载会不会阻塞 DOM 的解析？（会）</p><p>js 加载会不会阻塞 DOM 的渲染？（会）</p><p><strong>DOMContentLoaded 与 onload 区别</strong></p><p>1、 <code>onload</code> 页面的所有资源都加载完成才会触发，这些资源包括 css、js、图片视频等。</p><p>2、当 <code>DOMContentLoaded</code> 事件触发时，仅当 DOM 加载完成，不包括样式表，图片，flash。</p>]]></content>
      
      
      <categories>
          
          <category> computer internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三 Git</title>
      <link href="/2022/08/10/3/"/>
      <url>/2022/08/10/3/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><strong>上传到github</strong>先git init, git add . ,git commit -m ‘ ‘, 再关联远程库</p><p>Git 中的三个<strong>区域</strong>：工作区、暂存区、Git 仓库。</p><p>工作区：处理工作的区域</p><p>暂存区：已完成的工作的临时存放区域，等待被提交</p><p>Git 仓库：最终的存放区域</p><p>Git 中的三种<strong>状态</strong>：已修改 modified 已暂存 staged 已提交 committed</p><p><strong>已修改</strong>：表示修改了文件，但还没将修改的结果放到暂存区。</p><p><strong>已暂存</strong>：表示对已修改文件的当前 版本做了标记，使之包含 在下次提交的列表中。</p><p><strong>已提交</strong>：表示文件已经安全地保存 在本地的 Git 仓库中。</p><p>注意：</p><p>⚫ 工作区的文件被修改了，但还没有放到暂存区，就是已修改状态。</p><p>⚫ 如果文件已修改并放入暂存区，就属于已暂存状态。</p><p>⚫ 如果 Git 仓库中保存着特定版本的文件，就属于已提交状态。</p><h2 id="Git的基本操作"><a href="#Git的基本操作" class="headerlink" title="Git的基本操作"></a>Git的基本操作</h2><ol><li><p>git init 命令会创建一个名为 .git 的隐藏目录，这个 .git 目录就是当前项目的 Git 仓库，里面包含了初始的必要文件，这些文件是 Git 仓库的必要组成部分。</p></li><li><p>git add 开始跟踪一个文件，git add . 一次性将所有的新增和修改过的文件加入暂存区</p></li><li><p>git status 命令查看文件处于什么状态</p></li><li><p>git commit 命令进行提交, 其中 -m 选项后面是本次的提交消息，用来对提交的内容做进一步的描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;什么信息&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>跳过使用暂存区域</p></li></ol><p>Git 标准的工作流程是<strong>工作区 → 暂存区 → Git 仓库</strong>。Git 工作的流程简化为了<strong>工作区 → Git 仓库</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">&#x27;描述信息&#x27;</span></span><br></pre></td></tr></table></figure><ol><li><p>移除文件</p><p>从 Git 仓库中移除文件的方式有两种： </p><p>① 从 Git 仓库和工作区中同时移除对应的文件 </p><p>② 只从 Git 仓库中移除指定的文件，但保留工作区中对应的文件</p></li></ol><p><img src="/img/articles/image-20221025163441508.png" alt=""></p><h2 id="Git分支的概念"><a href="#Git分支的概念" class="headerlink" title="Git分支的概念"></a>Git分支的概念</h2><p>master 主分支</p><p>功能分支</p><ol><li><p>创建新分支       <strong>git branch 分支名称</strong>  </p><p>基于当前分支，创建一个新的分支，创建好分支后，当前位置还是在master分支上</p></li><li><p>切换分支     <strong>git checkout 分支名称</strong>     </p><p>可以切换到指定的分支上进行开发</p></li><li><p>分支的快速创建和切换  <strong>git checkout -b 分支名称</strong></p></li><li><p>合并分支   先切换到 master分支上，再运行 <strong>git merge 分支名称</strong> 命令，来合并功能分支</p><p>功能分支的代码开发测试完毕之后，可以使用命令，将完成后的代码合并到 master 主分支上</p></li><li><p>删除分支 <strong>git branch -d 分支名称</strong></p><p>当把功能分支的代码合并到 master 主分支上以后，就可以使用命令，删除对应的功能分支</p></li></ol><p>​    6、git remote prune origin 清理本地仓库中与远程仓库中origin关联的已经不存在的分支引用</p><h2 id="远程分支操作"><a href="#远程分支操作" class="headerlink" title="远程分支操作"></a>远程分支操作</h2><ol><li>将本地分支推送到远程仓库</li></ol><p>​        如果是第一次将本地分支推送到远程仓库，需要运行如下的命令：<br><img src="/img/articles/image-20221025164401144.png" alt=""></p><p>gitlab的操作，git pull origin 分支名</p><ol><li><p>查看远程仓库中所有的分支列表</p><p>通过如下的命令，可以查看远程仓库中，所有的分支列表的信息：<br><img src="/img/articles/image-20221025164457908.png" alt=""></p></li></ol><ol><li>跟踪分支</li></ol><p>​        跟踪分支指的是：从远程仓库中，把远程分支下载到本地仓库中。需要运行的命令如下：<br><img src="/img/articles/image-20221025164539512.png" alt=""></p><ol><li><p>拉取远程分支的最新的代码</p><p>首先切换到本地分支</p><p>git pull origin 远程分支名</p><p>可以使用如下的命令，把远程分支最新的代码下载到本地对应的分支中：<br><img src="/img/articles/image-20221025164618940.png" alt=""></p></li></ol><ol><li><p>删除远程分支</p><p>可以使用如下的命令，删除远程仓库中指定的分支：<br><img src="/img/articles/image-20221025164652215.png" alt=""></p></li><li><p>合并分支冲突</p></li></ol><p>如果在两个不同的分支中，对同一个文件进行了不同的修改，Git 就没法干净的合并它们。 此时，我们需要打开 这些包含冲突的文件然后手动解决冲突。、</p><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>git init</p><p>然后git clone +url</p><p>如果连接不上就</p><p><a href="https://blog.csdn.net/greatcoder/article/details/126138230">https://blog.csdn.net/greatcoder/article/details/126138230</a></p><p>git clone <a href="https://ghproxy.com/+github网站地址">https://ghproxy.com/+github网站地址</a></p><p>就比如 git clone <a href="https://ghproxy.com/https://github.com/HaogegeShy/jingdong.git">https://ghproxy.com/https://github.com/HaogegeShy/jingdong.git</a></p><h2 id="git问题error-remote-origin-already-exists"><a href="#git问题error-remote-origin-already-exists" class="headerlink" title="git问题error: remote origin already exists"></a>git问题error: remote origin already exists</h2><p><a href="https://blog.csdn.net/qq_39208536/article/details/125231265">https://blog.csdn.net/qq_39208536/article/details/125231265</a></p><p>如果你clone下来一个别人的仓库，在此基础上完成你的代码，推送到自己的仓库可能遇到如下问题：<br>error: remote origin already exists.表示远程仓库已存在。<br>因此你要进行以下操作：<br>1、先输入git remote rm origin 删除关联的origin的远程库<br>2、关联自己的仓库 git remote add origin <a href="https://gitee.com/xxxxxx.git">https://gitee.com/xxxxxx.git</a><br>3、最后git push origin master，这样就推送到自己的仓库了。</p><h2 id="git代码提交到远程仓库时"><a href="#git代码提交到远程仓库时" class="headerlink" title="git代码提交到远程仓库时"></a>git代码提交到远程仓库时</h2><p>选用ssh的方式</p><h2 id="git-rebase和git-merge的区别"><a href="#git-rebase和git-merge的区别" class="headerlink" title="git rebase和git merge的区别"></a>git rebase和git merge的区别</h2><p>1、rebase变基，把当前的commit放到公共分支的最后面，merge把当前的commit和公共分支合并在一起，会产生一个合并的commit；</p><p>2、用merge命令解决完冲突后会产生一个commit，而用rebase命令解决完冲突后不会产生额外的commit。</p><p>merge中fast-forward 不会产生commit提交，—no-ff 会产生commit提交</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二 VUE底层原理</title>
      <link href="/2022/08/05/2/"/>
      <url>/2022/08/05/2/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-原理"><a href="#vue-原理" class="headerlink" title="vue 原理"></a>vue 原理</h1><h2 id="1、mvvm"><a href="#1、mvvm" class="headerlink" title="1、mvvm"></a>1、mvvm</h2><ul><li>M：模型 Model —-&gt;也就是 data 中的数据</li><li>V：视图 View —-&gt;也就是 dom</li><li>VM：视图模型 ViewModel —-&gt;也就是 Vue 实例（vm）</li></ul><p><img src="/img/articles/image-20230521163900590.png" alt=""></p><h2 id="2、vue-响应式原理"><a href="#2、vue-响应式原理" class="headerlink" title="2、vue 响应式原理"></a>2、vue 响应式原理</h2><h3 id="核心-api-object-defineProperty"><a href="#核心-api-object-defineProperty" class="headerlink" title="核心 api object.defineProperty"></a>核心 api object.defineProperty</h3><p><img src="/img/articles/image-20230521164959631.png" alt=""></p><p>vue 响应式也叫作数据双向绑定，大致原理阐述：</p><p>首先我们需要通过 Object.defineProperty()方法把数据(data)设置为 getter 和 setter 的访问形式，这样我们就可以在数据被修改时在 setter 方法设置监视修改页面信息，也就是说每当数据被修改，就会触发对应的 set 方法，然后我们可以在 set 方法中去调用操作 dom 的方法。</p><p>此外，如果页面有 input 用 v-model 绑定数据，我们需要在这种绑定了 data 的 input 元素上添加监听，添加 input 事件监听，每当 input 事件被触发时，就修改对应的 data</p><p>原文链接：<a href="https://blog.csdn.net/weixin_48181168/article/details/120158346">https://blog.csdn.net/weixin_48181168/article/details/120158346</a></p><p><img src="/img/articles/image-20230521192401756.png" alt=""></p><h3 id="vue3-启用-proxy"><a href="#vue3-启用-proxy" class="headerlink" title="vue3 启用 proxy"></a><strong>vue3 启用 proxy</strong></h3><p><a href="https://blog.csdn.net/pagnzong/article/details/120389514">https://blog.csdn.net/pagnzong/article/details/120389514</a></p><p>代码</p><p><img src="/img/articles/image-20230522155235201.png" alt=""></p><h3 id="proxy-和-object-defineProperty-响应式的对比"><a href="#proxy-和-object-defineProperty-响应式的对比" class="headerlink" title="proxy 和 object.defineProperty 响应式的对比"></a>proxy 和 object.defineProperty 响应式的对比</h3><p>vue2 响应式的缺点：</p><ul><li>检测不到对象属性的添加和删除 （需要使用 vue.set, vue.delete）</li><li>数组<code>API</code>方法无法监听到 (需要特殊处理)</li><li>深度监听需要递归到底，造成性能问题</li></ul><p>proxy 解决的问题</p><ul><li>克服了 vue2 响应式的问题</li><li>缺点：没有兼容 ie 等其他浏览器，无法实现 polyfill</li></ul><h2 id="3、虚拟-dom-和-diff-算法和-react-diff-的区别"><a href="#3、虚拟-dom-和-diff-算法和-react-diff-的区别" class="headerlink" title="3、虚拟 dom 和 diff 算法和 react diff 的区别"></a>3、虚拟 dom 和 diff 算法和 react diff 的区别</h2><p>用 JS 模拟 DOM 结构（vnode）<br>增量更新： 新旧 vnode 对比，得出最小的更新范围，最后更新 DOM</p><p>数据驱动视图的模式下，有效控制 DOM 操作</p><p><img src="/img/articles/image-20230521193406678.png" alt=""></p><p>diff 算法</p><ul><li><p>当数据发生改变时，订阅者<code>watcher</code>就会调用<code>patch</code>给真实的<code>DOM</code>打补丁</p></li><li><p>通过<code>isSameVnode</code>进行判断，相同则调用<code>patchVnode</code>方法</p></li><li><p>```<br>patchVnode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  做了以下操作：</span><br><span class="line"></span><br><span class="line">  - 找到对应的真实`dom`，称为`el`</span><br><span class="line">  - 如果都有都有文本节点且不相等，将`el`文本节点设置为`Vnode`的文本节点</span><br><span class="line">  - 如果`oldVnode`有子节点而`VNode`没有，则删除`el`子节点</span><br><span class="line">  - 如果`oldVnode`没有子节点而`VNode`有，则将`VNode`的子节点真实化后添加到`el`</span><br><span class="line">  - 如果两者都有子节点，则执行`updateChildren`函数比较子节点</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  updateChildren</span><br></pre></td></tr></table></figure><p>主要做了以下操作：</p><ul><li>设置新旧<code>VNode</code>的头尾指针</li><li>新旧头尾指针进行比较，循环向中间靠拢，根据情况调用<code>patchVnode</code>进行<code>patch</code>重复流程、调用<code>createElem</code>创建一个新节点，从哈希表寻找 <code>key</code>一致的<code>VNode</code> 节点再分情况操作</li></ul></li></ul><p><strong>相同点：</strong><br>Vue 和 react 的 diff 算法，都是不进行跨层级比较，只做同级比较</p><p><strong>不同点：</strong></p><ol><li>vue 会在 patch 函数中给被操作的节点打补丁（patchflag），在 diff 的时候更清晰</li><li>vue 对比节点，当节点元素类型相同，但是 className 不同时，认为是不同类型的元素，删除重新创建；而 react 则认为是同类型节点，进行修改操作</li><li>diff 策略，vue 的性能优于 react</li></ol><h2 id="4、模板编译-template"><a href="#4、模板编译-template" class="headerlink" title="4、模板编译 template"></a>4、模板编译 template</h2><p>template-&gt;render-&gt;h-&gt;vdom-&gt;true dom</p><h2 id="5、vue-组件的渲染和更新流程"><a href="#5、vue-组件的渲染和更新流程" class="headerlink" title="5、vue 组件的渲染和更新流程"></a>5、vue 组件的渲染和更新流程</h2><p>初次渲染<br><img src="/img/articles/image-20230521212323764.png" alt=""></p><p>更新<br><img src="/img/articles/image-20230521212411230.png" alt=""></p><p>完整流程图<br><img src="/img/articles/image-20230521212545143.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一 React底层原理</title>
      <link href="/2022/07/30/1/"/>
      <url>/2022/07/30/1/</url>
      
        <content type="html"><![CDATA[<h1 id="React-底层原理"><a href="#React-底层原理" class="headerlink" title="React 底层原理"></a>React 底层原理</h1><p>至此我们介绍了 react 的理念，如何解决 cpu 和 io 的瓶颈，关键是实现异步可中断的更新</p><p>我们介绍了 react 源码架构（ui=fn(state)），从 scheduler 开始调度（根据过期事件判断优先级，时间分片），经过 render 阶段的深度优先遍历形成 effectList（中间会执行 reconcile|diff），交给 commit 处理真实节点（中间穿插生命周期和部分 hooks），而这些调度的过程都离不开 Fiber 的支撑，<strong>Fiber 是工作单元，也是节点优先级、更新 UpdateQueue、节点信息的载体</strong>，Fiber 双缓存则提供了对比前后节点更新的基础。我们还介绍了 jsx 是 React.createElement 的语法糖。Lane 模型则提供了更细粒度的优先级对比和计算，这一切都为 concurrent mode 提供了基础，在这之上变可以实现 Suspense 和 batchedUpdate（16、17 版本实现的逻辑不一样），context 的 valueStack 和 valueCursor 在整个架构中运行机制，最后介绍了新版事件系统，包括事件生产、监听和触发</p><h2 id="1-react-的架构"><a href="#1-react-的架构" class="headerlink" title="1. react 的架构"></a>1. react 的架构</h2><p><a href="https://juejin.cn/post/7211072055780573221#heading-0">https://juejin.cn/post/7211072055780573221#heading-0</a></p><p><a href="https://juejin.cn/post/6926432527980691470">https://juejin.cn/post/6926432527980691470</a></p><p>作为架构来说，之前<code>React15</code>的<code>Reconciler</code>采用递归的方式执行，数据保存在递归调用栈中，所以被称为<code>stack Reconciler</code>。<code>React16</code>的<code>Reconciler</code>基于<code>Fiber节点</code>实现，被称为<code>Fiber Reconciler</code>。</p><p>新版 React 架构分为三大部分：</p><ul><li>Scheduler 调度器： 排序优先级，让优先级高的任务先进行 reconcile</li><li>Reconciler 协调器：接受更新，创建虚拟 dom 树，找出哪些节点发生了改变，并打上不同的 effectTag</li><li>Renderer 渲染器：将 Reconciler 中打好标签的节点渲染到视图上</li></ul><p>Fiber 这种数据结构后，能完成哪些事情呢，</p><ul><li><strong>工作单元 任务分解</strong> ：Fiber 最重要的功能就是作为工作单元，保存原生节点或者组件节点对应信息（包括优先级），这些节点通过指针的形似形成 Fiber 树</li><li><strong>增量渲染</strong>：通过 jsx 对象和 current Fiber 的对比，生成最小的差异补丁，应用到真实节点上</li><li><strong>根据优先级暂停、继续、排列优先级</strong>：Fiber 节点上保存了优先级，能通过不同节点优先级的对比，达到任务的暂停、继续、排列优先级等能力，也为上层实现批量更新、Suspense 提供了基础</li><li><strong>保存状态：</strong>因为 Fiber 能保存状态和更新的信息，所以就能实现函数组件的状态更新，也就是 hooks</li><li><a href="https://songhaoyong.blogspot.com/2023/07/react.html">https://songhaoyong.blogspot.com/2023/07/react.html</a></li></ul><h2 id="2-render-阶段"><a href="#2-render-阶段" class="headerlink" title="2. render 阶段"></a>2. render 阶段</h2><p>render：Reconciler 工作的阶段被称为 render 阶段。因为在该阶段会调用组件的 render 方法</p><p>render 阶段的主要工作是构建 Fiber 树和生成 effectList</p><p>开始工作前会先找到 div#root 对应的<code>rootFiber，称为</code>hostRootFiber<code>，然后开始生成</code>wip Fiber 树<code>。 这个过程分为两个部分：beginWork</code>和 completeWork。 这是一个深度优先遍历的过程。<br><p class='p left green'>beginwork</p><br>主要的工作是创建或复用子 fiber 节点（同时涉及到 diff 算法，为结点打上 effectTags）</p><p>从根节点 rootFiber 开始，遍历到叶子节点，每次遍历到的节点都会执行 beginWork，并且传入当前 Fiber 节点，然后创建或复用它的子 Fiber 节点，并赋值给 workInProgress.child。</p><p class='p left red'>completework</p><p>主要工作是处理 fiber 的 props、创建 dom、创建 effectList</p><p>1、(处理 props 将变化的部分賦值给 workInProgerss.updateQueue)</p><p>2、mount 时 调用 createInstance 创建 dom，将后代 dom 节点插入刚创建的 dom 中</p><p>3、将 effectTag 的节点，加入到 effectList 中</p><p>当遍历到子节点后，会执行 completeWork 方法，执行完成之后会判断此节点的兄弟节点存不存在，如果存在就会为兄弟节点执行 completeWork，当全部兄弟节点执行完之后，会向上回到父节点执行 completeWork，直到 rootFiber。</p><p>shouldYiled 方法就是判断待处理的任务队列有没有优先级更高的任务，有的话就先处理那边的 fiber，这边的先暂停一下。</p><h2 id="3-commit-阶段"><a href="#3-commit-阶段" class="headerlink" title="3. commit 阶段"></a>3. commit 阶段</h2><p>commit：Renderer 工作的阶段被称为 commit 阶段。commit 阶段会把 render 阶段提交的信息渲染在页面上</p><p>遍历 render 阶段生成的 effectList，effectList 上的 Fiber 节点保存着对应的 props 变化。之后会遍历 effectList 进行对应的 dom 操作和生命周期、hooks 回调或销毁函数。</p><p><strong>commit 阶段</strong>的主要工作（即 Renderer 的工作流程）分为三部分：</p><ul><li>before mutation 阶段（执行 DOM 操作前）</li></ul><p>​ 这个阶段 DOM 节点还没有被渲染到界面上去，过程中会触发 <code>getSnapshotBeforeUpdate</code>，也会处理 <code>useEffect</code> 钩子相关的调度逻辑。</p><ul><li>mutation 阶段（执行 DOM 操作）</li></ul><p>​ 这个阶段负责 DOM 节点的渲染。在渲染过程中，会遍历 effectList，根据 effectTag 的不同，执行不同的 DOM 操作。</p><ul><li><p>layout 阶段（执行 DOM 操作后）</p><p>这个阶段处理 DOM 渲染完毕之后的收尾逻辑。比如调用 <code>componentDidMount/componentDidUpdate</code>，调用 <code>useLayoutEffect</code> 钩子函数的回调等。除了这些之外，它还会把 fiberRoot 的 current 指针指向 workInProgress Fiber 树。</p></li></ul><h2 id="4-render-函数"><a href="#4-render-函数" class="headerlink" title="4. render 函数"></a>4. render 函数</h2><p><strong>legacy 模式</strong></p><p>render 调用 legacyRenderSubtreeIntoContainer，作用是</p><p>1、创建 FiberRootNode 和 rootFiber 节点, （调用 createRootImpl，其会调用到 createFiberRoot 创建 fiberRootNode,然后调用 createHostRootFiber 创建 rootFiber）</p><p>2、调用 updateContainer 创建创建 Update 对象挂载到 updateQueue 的环形链表上，（然后执行 scheduleUpdateOnFiber 调用 performSyncWorkOnRoot 进入 render 阶段和 commit 阶段）</p><p><strong>concurrent 模式：</strong></p><p>调用 ReactDOMRoot.prototype.render 执行 updateContainer，调用 updateContainer 创建创建 Update 对象挂载到 updateQueue 的环形链表上，（然后 scheduleUpdateOnFiber 异步调度 performConcurrentWorkOnRoot 进入 render 阶段和 commit 阶段）</p><h2 id="5-fiber"><a href="#5-fiber" class="headerlink" title="5. fiber"></a>5. fiber</h2><p>Fiber 是一个 js 对象，能承载节点信息、优先级、updateQueue，同时它还是一个工作单元。</p><ul><li><strong>工作单元 任务分解</strong> ：Fiber 最重要的功能就是作为工作单元，保存原生节点或者组件节点对应信息（包括优先级），这些节点通过指针的形似形成 Fiber 树</li><li><strong>增量渲染</strong>：通过 jsx 对象和 current Fiber 的对比，生成最小的差异补丁，应用到真实节点上。（<code>fiber</code>将<code>react</code>中的渲染任务拆分到每一帧）</li><li><strong>根据优先级暂停、继续、排列优先级</strong>：Fiber 节点上保存了优先级，能通过不同节点优先级的对比，达到任务的暂停、继续、排列优先级等能力，也为上层实现批量更新、Suspense 提供了基础</li><li><strong>保存状态：</strong>因为 Fiber 能保存状态和更新的信息，所以就能实现函数组件的状态更新，也就是 hooks</li></ul><h2 id="6-hooks-的实现原理"><a href="#6-hooks-的实现原理" class="headerlink" title="6. hooks 的实现原理"></a>6. hooks 的实现原理</h2><p><strong>在函数式组件中，hooks 的实现就是基于 fiber 的，多个 hook 会形成 hook 链表，保存在 Fiber 的 memoizedState 的上</strong>。hook 不能写在条件判断中正因为 hook 会按顺序存储在链表中，如果 hook 写在条件判断中，就没法保持链表的顺序，会造成乱序。</p><p>hook 调用入口</p><p>在 hook 源码中 hook 存在于 Dispatcher 中，Dispatcher 就是一个对象，不同 hook 调用的函数不一样，全局变量 ReactCurrentDispatcher.current 会根据是 mount 还是 update 赋值为 HooksDispatcherOnMount 或 HooksDispatcherOnUpdate。</p><p>usestate 的工作原理</p><p>useState 分为 onMount 和 upDate 两种情况，通过全局变量 ReactCurrentDispatcher.current 来判断。</p><p>onMount 时，hook.memoizedState 记录初始的值</p><p>update 更新时：</p><p>其中 hooks 的<code>memoizedState</code>是用来记录这个<code>useState</code>应该返回的结果的，而<code>next</code>指向的是下一次<code>useState</code>对应的`Hook 对象。</p><p>memoizedState 装着 state，而 dispatchAction 就是 setState</p><p>dispatchAction 创建新的 update 对象，将这些更新对象放到 hook.queue.pending 的环形链表中，最后重新渲染 app</p><p>hooks 的数据结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">hook</span>: <span class="title class_">Hook</span> = &#123;</span><br><span class="line">  <span class="attr">memoizedState</span>: <span class="literal">null</span>,<span class="comment">//对于不同hook，有不同的值</span></span><br><span class="line">  <span class="attr">baseState</span>: <span class="literal">null</span>,<span class="comment">//初始state</span></span><br><span class="line">  <span class="attr">baseQueue</span>: <span class="literal">null</span>,<span class="comment">//初始queue队列</span></span><br><span class="line">  <span class="attr">queue</span>: <span class="literal">null</span> <span class="comment">// &#123; pending:这是一个链表储存着update&#125;,//需要更新的update</span></span><br><span class="line">  <span class="attr">next</span>: <span class="literal">null</span>,<span class="comment">//下一个hook</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7、react-的状态更新流程"><a href="#7、react-的状态更新流程" class="headerlink" title="7、react 的状态更新流程"></a>7、react 的状态更新流程</h2><p><img src="/img/articles/image-20230511104437245.png" alt=""><br><!-- <img src="/source/img/articles/image-20230511104437245.png" alt="image-20230511104437245" style="zoom:150%;" /> --></p><p>触发更新后，会在函数 createUpdate 中创建 update 更新，并将其加入到 updateQueue 中，会从触发更新的节点开始向上遍历到 rootFiber，遍历的过程会处理节点的优先级。然后根据优先级调度 render 阶段的入口函数。最后进行 render 阶段和 commit 阶段。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
